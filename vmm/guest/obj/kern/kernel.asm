
vmm/guest/obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
_head64:

# Save multiboot_info addr passed by bootloader
#ifdef VMM_GUEST
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
  100000:	b8 01 00 00 00       	mov    $0x1,%eax
    vmcall
  100005:	0f 01 c1             	vmcall 
#endif

    movl $multiboot_info, %eax
  100008:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  10000d:	89 18                	mov    %ebx,(%rax)
#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
#endif

# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  10000f:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100014:	e8 cc 00 00 00       	callq  1000e5 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  100019:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif
    movl %eax,%cr4
  10001e:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100021:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100026:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100028:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002d:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  10002f:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100034:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  100039:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  10003f:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100041:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100046:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  100049:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004c:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  10004f:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100054:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  100059:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  10005f:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100061:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100066:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006b:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006e:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100071:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100073:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100078:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007d:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100082:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100088:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008d:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  10008f:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100091:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100094:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100097:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009c:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  10009f:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a2:	75 e9                	jne    10008d <_head64+0x8d>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a4:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000a9:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b1:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b3:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b7:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000b9:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bc:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000bf:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c4:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000c9:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000ce:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d1:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d4:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000d9:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dc:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000de:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e3:	50                   	push   %rax

00000000001000e4 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e4:	cb                   	lret   

00000000001000e5 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e5:	9c                   	pushfq 
    popl %eax
  1000e6:	58                   	pop    %rax
    movl %eax,%ecx
  1000e7:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000e9:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ee:	50                   	push   %rax
    popfl
  1000ef:	9d                   	popfq  
    pushfl
  1000f0:	9c                   	pushfq 
    popl %eax
  1000f1:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f2:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f4:	74 1c                	je     100112 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f6:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fb:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fd:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100100:	72 10                	jb     100112 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100102:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100107:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  100109:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  10010f:	74 01                	je     100112 <verify_cpu_no_longmode>

    ret
  100111:	c3                   	retq   

0000000000100112 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100112:	eb fe                	jmp    100112 <verify_cpu_no_longmode>
  100114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011b:	00 00 00 
  10011e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100125:	00 00 00 
  100128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10012f:	00 00 00 
  100132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100139:	00 00 00 
  10013c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100143:	00 00 00 
  100146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014d:	00 00 00 
  100150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100157:	00 00 00 
  10015a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100161:	00 00 00 
  100164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016b:	00 00 00 
  10016e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100175:	00 00 00 
  100178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10017f:	00 00 00 
  100182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100189:	00 00 00 
  10018c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100193:	00 00 00 
  100196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019d:	00 00 00 
  1001a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a7:	00 00 00 
  1001aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b1:	00 00 00 
  1001b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bb:	00 00 00 
  1001be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c5:	00 00 00 
  1001c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001cf:	00 00 00 
  1001d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d9:	00 00 00 
  1001dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e3:	00 00 00 
  1001e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ed:	00 00 00 
  1001f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f7:	00 00 00 
  1001fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100201:	00 00 00 
  100204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020b:	00 00 00 
  10020e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100215:	00 00 00 
  100218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10021f:	00 00 00 
  100222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100229:	00 00 00 
  10022c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100233:	00 00 00 
  100236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023d:	00 00 00 
  100240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100247:	00 00 00 
  10024a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100251:	00 00 00 
  100254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025b:	00 00 00 
  10025e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100265:	00 00 00 
  100268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10026f:	00 00 00 
  100272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100279:	00 00 00 
  10027c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100283:	00 00 00 
  100286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028d:	00 00 00 
  100290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100297:	00 00 00 
  10029a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a1:	00 00 00 
  1002a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ab:	00 00 00 
  1002ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b5:	00 00 00 
  1002b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002bf:	00 00 00 
  1002c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c9:	00 00 00 
  1002cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d3:	00 00 00 
  1002d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002dd:	00 00 00 
  1002e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e7:	00 00 00 
  1002ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f1:	00 00 00 
  1002f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fb:	00 00 00 
  1002fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100305:	00 00 00 
  100308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10030f:	00 00 00 
  100312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100319:	00 00 00 
  10031c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100323:	00 00 00 
  100326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032d:	00 00 00 
  100330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100337:	00 00 00 
  10033a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100341:	00 00 00 
  100344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034b:	00 00 00 
  10034e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100355:	00 00 00 
  100358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10035f:	00 00 00 
  100362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100369:	00 00 00 
  10036c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100373:	00 00 00 
  100376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037d:	00 00 00 
  100380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100387:	00 00 00 
  10038a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100391:	00 00 00 
  100394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039b:	00 00 00 
  10039e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a5:	00 00 00 
  1003a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003af:	00 00 00 
  1003b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b9:	00 00 00 
  1003bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c3:	00 00 00 
  1003c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003cd:	00 00 00 
  1003d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d7:	00 00 00 
  1003da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e1:	00 00 00 
  1003e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003eb:	00 00 00 
  1003ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f5:	00 00 00 
  1003f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ff:	00 00 00 
  100402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100409:	00 00 00 
  10040c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100413:	00 00 00 
  100416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041d:	00 00 00 
  100420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100427:	00 00 00 
  10042a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100431:	00 00 00 
  100434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043b:	00 00 00 
  10043e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100445:	00 00 00 
  100448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10044f:	00 00 00 
  100452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100459:	00 00 00 
  10045c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100463:	00 00 00 
  100466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046d:	00 00 00 
  100470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100477:	00 00 00 
  10047a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100481:	00 00 00 
  100484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048b:	00 00 00 
  10048e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100495:	00 00 00 
  100498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10049f:	00 00 00 
  1004a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a9:	00 00 00 
  1004ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b3:	00 00 00 
  1004b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004bd:	00 00 00 
  1004c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c7:	00 00 00 
  1004ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d1:	00 00 00 
  1004d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004db:	00 00 00 
  1004de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e5:	00 00 00 
  1004e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004ef:	00 00 00 
  1004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f9:	00 00 00 
  1004fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100503:	00 00 00 
  100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050d:	00 00 00 
  100510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100517:	00 00 00 
  10051a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100521:	00 00 00 
  100524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052b:	00 00 00 
  10052e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100535:	00 00 00 
  100538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10053f:	00 00 00 
  100542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100549:	00 00 00 
  10054c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100553:	00 00 00 
  100556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055d:	00 00 00 
  100560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100567:	00 00 00 
  10056a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100571:	00 00 00 
  100574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057b:	00 00 00 
  10057e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100585:	00 00 00 
  100588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10058f:	00 00 00 
  100592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100599:	00 00 00 
  10059c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a3:	00 00 00 
  1005a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ad:	00 00 00 
  1005b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b7:	00 00 00 
  1005ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c1:	00 00 00 
  1005c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cb:	00 00 00 
  1005ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d5:	00 00 00 
  1005d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005df:	00 00 00 
  1005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e9:	00 00 00 
  1005ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f3:	00 00 00 
  1005f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fd:	00 00 00 
  100600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100607:	00 00 00 
  10060a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100611:	00 00 00 
  100614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061b:	00 00 00 
  10061e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100625:	00 00 00 
  100628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10062f:	00 00 00 
  100632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100639:	00 00 00 
  10063c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100643:	00 00 00 
  100646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064d:	00 00 00 
  100650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100657:	00 00 00 
  10065a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100661:	00 00 00 
  100664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066b:	00 00 00 
  10066e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100675:	00 00 00 
  100678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10067f:	00 00 00 
  100682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100689:	00 00 00 
  10068c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100693:	00 00 00 
  100696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069d:	00 00 00 
  1006a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a7:	00 00 00 
  1006aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b1:	00 00 00 
  1006b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bb:	00 00 00 
  1006be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c5:	00 00 00 
  1006c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006cf:	00 00 00 
  1006d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d9:	00 00 00 
  1006dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e3:	00 00 00 
  1006e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ed:	00 00 00 
  1006f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f7:	00 00 00 
  1006fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100701:	00 00 00 
  100704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070b:	00 00 00 
  10070e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100715:	00 00 00 
  100718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10071f:	00 00 00 
  100722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100729:	00 00 00 
  10072c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100733:	00 00 00 
  100736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073d:	00 00 00 
  100740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100747:	00 00 00 
  10074a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100751:	00 00 00 
  100754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075b:	00 00 00 
  10075e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100765:	00 00 00 
  100768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10076f:	00 00 00 
  100772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100779:	00 00 00 
  10077c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100783:	00 00 00 
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078d:	00 00 00 
  100790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100797:	00 00 00 
  10079a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a1:	00 00 00 
  1007a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ab:	00 00 00 
  1007ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b5:	00 00 00 
  1007b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007bf:	00 00 00 
  1007c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c9:	00 00 00 
  1007cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d3:	00 00 00 
  1007d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007dd:	00 00 00 
  1007e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e7:	00 00 00 
  1007ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f1:	00 00 00 
  1007f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fb:	00 00 00 
  1007fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100805:	00 00 00 
  100808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10080f:	00 00 00 
  100812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100819:	00 00 00 
  10081c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100823:	00 00 00 
  100826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082d:	00 00 00 
  100830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100837:	00 00 00 
  10083a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100841:	00 00 00 
  100844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084b:	00 00 00 
  10084e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100855:	00 00 00 
  100858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10085f:	00 00 00 
  100862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100869:	00 00 00 
  10086c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100873:	00 00 00 
  100876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087d:	00 00 00 
  100880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100887:	00 00 00 
  10088a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100891:	00 00 00 
  100894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089b:	00 00 00 
  10089e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a5:	00 00 00 
  1008a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008af:	00 00 00 
  1008b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b9:	00 00 00 
  1008bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c3:	00 00 00 
  1008c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008cd:	00 00 00 
  1008d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d7:	00 00 00 
  1008da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e1:	00 00 00 
  1008e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008eb:	00 00 00 
  1008ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f5:	00 00 00 
  1008f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ff:	00 00 00 
  100902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100909:	00 00 00 
  10090c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100913:	00 00 00 
  100916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091d:	00 00 00 
  100920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100927:	00 00 00 
  10092a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100931:	00 00 00 
  100934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093b:	00 00 00 
  10093e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100945:	00 00 00 
  100948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10094f:	00 00 00 
  100952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100959:	00 00 00 
  10095c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100963:	00 00 00 
  100966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096d:	00 00 00 
  100970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100977:	00 00 00 
  10097a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100981:	00 00 00 
  100984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098b:	00 00 00 
  10098e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100995:	00 00 00 
  100998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10099f:	00 00 00 
  1009a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a9:	00 00 00 
  1009ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b3:	00 00 00 
  1009b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009bd:	00 00 00 
  1009c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c7:	00 00 00 
  1009ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d1:	00 00 00 
  1009d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009db:	00 00 00 
  1009de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e5:	00 00 00 
  1009e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009ef:	00 00 00 
  1009f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f9:	00 00 00 
  1009fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a03:	00 00 00 
  100a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0d:	00 00 00 
  100a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a17:	00 00 00 
  100a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a21:	00 00 00 
  100a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2b:	00 00 00 
  100a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a35:	00 00 00 
  100a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a3f:	00 00 00 
  100a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a49:	00 00 00 
  100a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a53:	00 00 00 
  100a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5d:	00 00 00 
  100a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a67:	00 00 00 
  100a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a71:	00 00 00 
  100a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7b:	00 00 00 
  100a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a85:	00 00 00 
  100a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a8f:	00 00 00 
  100a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a99:	00 00 00 
  100a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa3:	00 00 00 
  100aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aad:	00 00 00 
  100ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab7:	00 00 00 
  100aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac1:	00 00 00 
  100ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acb:	00 00 00 
  100ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad5:	00 00 00 
  100ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100adf:	00 00 00 
  100ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae9:	00 00 00 
  100aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af3:	00 00 00 
  100af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afd:	00 00 00 
  100b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b07:	00 00 00 
  100b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b11:	00 00 00 
  100b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1b:	00 00 00 
  100b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b25:	00 00 00 
  100b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b2f:	00 00 00 
  100b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b39:	00 00 00 
  100b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b43:	00 00 00 
  100b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4d:	00 00 00 
  100b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b57:	00 00 00 
  100b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b61:	00 00 00 
  100b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6b:	00 00 00 
  100b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b75:	00 00 00 
  100b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b7f:	00 00 00 
  100b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b89:	00 00 00 
  100b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b93:	00 00 00 
  100b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9d:	00 00 00 
  100ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba7:	00 00 00 
  100baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb1:	00 00 00 
  100bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbb:	00 00 00 
  100bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc5:	00 00 00 
  100bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bcf:	00 00 00 
  100bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd9:	00 00 00 
  100bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be3:	00 00 00 
  100be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bed:	00 00 00 
  100bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf7:	00 00 00 
  100bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c01:	00 00 00 
  100c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0b:	00 00 00 
  100c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c15:	00 00 00 
  100c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c1f:	00 00 00 
  100c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c29:	00 00 00 
  100c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c33:	00 00 00 
  100c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3d:	00 00 00 
  100c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c47:	00 00 00 
  100c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c51:	00 00 00 
  100c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5b:	00 00 00 
  100c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c65:	00 00 00 
  100c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c6f:	00 00 00 
  100c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c79:	00 00 00 
  100c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c83:	00 00 00 
  100c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8d:	00 00 00 
  100c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c97:	00 00 00 
  100c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca1:	00 00 00 
  100ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cab:	00 00 00 
  100cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb5:	00 00 00 
  100cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cbf:	00 00 00 
  100cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc9:	00 00 00 
  100ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd3:	00 00 00 
  100cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cdd:	00 00 00 
  100ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce7:	00 00 00 
  100cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf1:	00 00 00 
  100cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfb:	00 00 00 
  100cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d05:	00 00 00 
  100d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d0f:	00 00 00 
  100d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d19:	00 00 00 
  100d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d23:	00 00 00 
  100d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2d:	00 00 00 
  100d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d37:	00 00 00 
  100d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d41:	00 00 00 
  100d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4b:	00 00 00 
  100d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d55:	00 00 00 
  100d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d5f:	00 00 00 
  100d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d69:	00 00 00 
  100d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d73:	00 00 00 
  100d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7d:	00 00 00 
  100d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d87:	00 00 00 
  100d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d91:	00 00 00 
  100d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9b:	00 00 00 
  100d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da5:	00 00 00 
  100da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100daf:	00 00 00 
  100db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db9:	00 00 00 
  100dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc3:	00 00 00 
  100dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dcd:	00 00 00 
  100dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd7:	00 00 00 
  100dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de1:	00 00 00 
  100de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100deb:	00 00 00 
  100dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df5:	00 00 00 
  100df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dff:	00 00 00 
  100e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e09:	00 00 00 
  100e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e13:	00 00 00 
  100e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1d:	00 00 00 
  100e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e27:	00 00 00 
  100e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e31:	00 00 00 
  100e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3b:	00 00 00 
  100e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e45:	00 00 00 
  100e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e4f:	00 00 00 
  100e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e59:	00 00 00 
  100e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e63:	00 00 00 
  100e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6d:	00 00 00 
  100e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e77:	00 00 00 
  100e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e81:	00 00 00 
  100e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8b:	00 00 00 
  100e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e95:	00 00 00 
  100e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e9f:	00 00 00 
  100ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea9:	00 00 00 
  100eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb3:	00 00 00 
  100eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebd:	00 00 00 
  100ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec7:	00 00 00 
  100eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed1:	00 00 00 
  100ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edb:	00 00 00 
  100ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee5:	00 00 00 
  100ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eef:	00 00 00 
  100ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef9:	00 00 00 
  100efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f03:	00 00 00 
  100f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0d:	00 00 00 
  100f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f17:	00 00 00 
  100f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f21:	00 00 00 
  100f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2b:	00 00 00 
  100f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f35:	00 00 00 
  100f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f3f:	00 00 00 
  100f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f49:	00 00 00 
  100f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f53:	00 00 00 
  100f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5d:	00 00 00 
  100f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f67:	00 00 00 
  100f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f71:	00 00 00 
  100f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7b:	00 00 00 
  100f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f85:	00 00 00 
  100f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f8f:	00 00 00 
  100f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f99:	00 00 00 
  100f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa3:	00 00 00 
  100fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fad:	00 00 00 
  100fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb7:	00 00 00 
  100fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc1:	00 00 00 
  100fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcb:	00 00 00 
  100fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd5:	00 00 00 
  100fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fdf:	00 00 00 
  100fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe9:	00 00 00 
  100fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff3:	00 00 00 
  100ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ffd:	00 00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 9e 01 20 04 80 	movabs $0x800420019e,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 38          	sub    $0x38,%rsp
  8004200061:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004200064:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  8004200068:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420006c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200070:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  8004200074:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200077:	0f a2                	cpuid  
  8004200079:	89 de                	mov    %ebx,%esi
  800420007b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420007e:	89 75 f0             	mov    %esi,-0x10(%rbp)
  8004200081:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  8004200084:	89 55 e8             	mov    %edx,-0x18(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  8004200087:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420008c:	74 09                	je     8004200097 <cpuid+0x3f>
		*eaxp = eax;
  800420008e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200092:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200095:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  8004200097:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420009c:	74 09                	je     80042000a7 <cpuid+0x4f>
		*ebxp = ebx;
  800420009e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042000a2:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042000a5:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  80042000a7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042000ac:	74 09                	je     80042000b7 <cpuid+0x5f>
		*ecxp = ecx;
  80042000ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042000b2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042000b5:	89 10                	mov    %edx,(%rax)
	if (edxp)
  80042000b7:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042000bc:	74 09                	je     80042000c7 <cpuid+0x6f>
		*edxp = edx;
  80042000be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042000c2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042000c5:	89 10                	mov    %edx,(%rax)
}
  80042000c7:	48 83 c4 38          	add    $0x38,%rsp
  80042000cb:	5b                   	pop    %rbx
  80042000cc:	5d                   	pop    %rbp
  80042000cd:	c3                   	retq   

00000080042000ce <xchg>:

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042000ce:	55                   	push   %rbp
  80042000cf:	48 89 e5             	mov    %rsp,%rbp
  80042000d2:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042000d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042000da:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042000dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042000e1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042000e4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042000e8:	f0 87 02             	lock xchg %eax,(%rdx)
  80042000eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042000ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042000f1:	c9                   	leaveq 
  80042000f2:	c3                   	retq   

00000080042000f3 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042000f3:	55                   	push   %rbp
  80042000f4:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042000f7:	48 bf 60 b9 22 04 80 	movabs $0x800422b960,%rdi
  80042000fe:	00 00 00 
  8004200101:	48 b8 e5 61 21 04 80 	movabs $0x80042161e5,%rax
  8004200108:	00 00 00 
  800420010b:	ff d0                	callq  *%rax
}
  800420010d:	5d                   	pop    %rbp
  800420010e:	c3                   	retq   

000000800420010f <vmcall>:
#ifdef VMM_GUEST

static void boot_virtual_aps(void);

int64_t vmcall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420010f:	55                   	push   %rbp
  8004200110:	48 89 e5             	mov    %rsp,%rbp
  8004200113:	53                   	push   %rbx
  8004200114:	48 83 ec 48          	sub    $0x48,%rsp
  8004200118:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420011b:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420011e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004200122:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200126:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  800420012a:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    int64_t ret;
    asm volatile("vmcall\n" : "=a" (ret) : "a" (num), "d" (a1), "c" (a2), "b" (a3), "D" (a4), "S" (a5) : "cc", "memory");
  800420012e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200131:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004200135:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004200139:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  800420013d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004200141:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004200145:	4c 89 c3             	mov    %r8,%rbx
  8004200148:	0f 01 c1             	vmcall 
  800420014b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(check && ret > 0) panic("vmcall %d returned %d (> 0)", num, ret);
  800420014f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8004200153:	74 3e                	je     8004200193 <vmcall+0x84>
  8004200155:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420015a:	7e 37                	jle    8004200193 <vmcall+0x84>
  800420015c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004200160:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200163:	49 89 d0             	mov    %rdx,%r8
  8004200166:	89 c1                	mov    %eax,%ecx
  8004200168:	48 ba c0 70 21 04 80 	movabs $0x80042170c0,%rdx
  800420016f:	00 00 00 
  8004200172:	be 28 00 00 00       	mov    $0x28,%esi
  8004200177:	48 bf dc 70 21 04 80 	movabs $0x80042170dc,%rdi
  800420017e:	00 00 00 
  8004200181:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200186:	49 b9 08 06 20 04 80 	movabs $0x8004200608,%r9
  800420018d:	00 00 00 
  8004200190:	41 ff d1             	callq  *%r9
    return ret;
  8004200193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004200197:	48 83 c4 48          	add    $0x48,%rsp
  800420019b:	5b                   	pop    %rbx
  800420019c:	5d                   	pop    %rbp
  800420019d:	c3                   	retq   

000000800420019e <i386_init>:
#endif


void
i386_init(void)
{
  800420019e:	55                   	push   %rbp
  800420019f:	48 89 e5             	mov    %rsp,%rbp
  80042001a2:	48 83 ec 10          	sub    $0x10,%rsp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  80042001a6:	48 ba 10 80 3b 04 80 	movabs $0x80043b8010,%rdx
  80042001ad:	00 00 00 
  80042001b0:	48 b8 3e 34 37 04 80 	movabs $0x800437343e,%rax
  80042001b7:	00 00 00 
  80042001ba:	48 29 c2             	sub    %rax,%rdx
  80042001bd:	48 89 d0             	mov    %rdx,%rax
  80042001c0:	48 89 c2             	mov    %rax,%rdx
  80042001c3:	be 00 00 00 00       	mov    $0x0,%esi
  80042001c8:	48 bf 3e 34 37 04 80 	movabs $0x800437343e,%rdi
  80042001cf:	00 00 00 
  80042001d2:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042001de:	48 b8 07 13 20 04 80 	movabs $0x8004201307,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042001ea:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042001ef:	48 bf e8 70 21 04 80 	movabs $0x80042170e8,%rdi
  80042001f6:	00 00 00 
  80042001f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001fe:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004200205:	00 00 00 
  8004200208:	ff d2                	callq  *%rdx

#ifdef VMM_GUEST
	/* Guest VMX extension exposure check */
	{
		uint32_t ecx = 0;
  800420020a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		cpuid(0x1, NULL, NULL, &ecx, NULL);
  8004200211:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004200215:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420021b:	48 89 c1             	mov    %rax,%rcx
  800420021e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004200223:	be 00 00 00 00       	mov    $0x0,%esi
  8004200228:	bf 01 00 00 00       	mov    $0x1,%edi
  800420022d:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200234:	00 00 00 
  8004200237:	ff d0                	callq  *%rax
		if (ecx & 0x20)
  8004200239:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420023c:	83 e0 20             	and    $0x20,%eax
  800420023f:	85 c0                	test   %eax,%eax
  8004200241:	74 2a                	je     800420026d <i386_init+0xcf>
			panic("[ERR] VMX extension exposed to guest.\n");
  8004200243:	48 ba 08 71 21 04 80 	movabs $0x8004217108,%rdx
  800420024a:	00 00 00 
  800420024d:	be 46 00 00 00       	mov    $0x46,%esi
  8004200252:	48 bf dc 70 21 04 80 	movabs $0x80042170dc,%rdi
  8004200259:	00 00 00 
  800420025c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200261:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004200268:	00 00 00 
  800420026b:	ff d1                	callq  *%rcx
		else
			cprintf("VMX extension hidden from guest.\n");
  800420026d:	48 bf 30 71 21 04 80 	movabs $0x8004217130,%rdi
  8004200274:	00 00 00 
  8004200277:	b8 00 00 00 00       	mov    $0x0,%eax
  800420027c:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004200283:	00 00 00 
  8004200286:	ff d2                	callq  *%rdx
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200288:	b8 00 00 00 00       	mov    $0x0,%eax
  800420028d:	48 ba 9d 31 20 04 80 	movabs $0x800420319d,%rdx
  8004200294:	00 00 00 
  8004200297:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200299:	48 b8 4b 84 20 04 80 	movabs $0x800420844b,%rax
  80042002a0:	00 00 00 
  80042002a3:	ff d0                	callq  *%rax
	trap_init();
  80042002a5:	48 b8 f7 98 20 04 80 	movabs $0x80042098f7,%rax
  80042002ac:	00 00 00 
  80042002af:	ff d0                	callq  *%rax
	mp_init();
	lapic_init();
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  80042002b1:	48 b8 7f 94 20 04 80 	movabs $0x800420947f,%rax
  80042002b8:	00 00 00 
  80042002bb:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  80042002bd:	48 b8 00 70 21 04 80 	movabs $0x8004217000,%rax
  80042002c4:	00 00 00 
  80042002c7:	ff d0                	callq  *%rax
	pci_init();
  80042002c9:	48 b8 c4 6f 21 04 80 	movabs $0x8004216fc4,%rax
  80042002d0:	00 00 00 
  80042002d3:	ff d0                	callq  *%rax


	


	lock_kernel();
  80042002d5:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  80042002dc:	00 00 00 
  80042002df:	ff d0                	callq  *%rax
	// Starting non-boot CPUs
	boot_aps();
  80042002e1:	48 b8 3b 03 20 04 80 	movabs $0x800420033b,%rax
  80042002e8:	00 00 00 
  80042002eb:	ff d0                	callq  *%rax
// Start fs.

	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042002ed:	be 01 00 00 00       	mov    $0x1,%esi
  80042002f2:	48 bf 07 0d 2a 04 80 	movabs $0x80042a0d07,%rdi
  80042002f9:	00 00 00 
  80042002fc:	48 b8 16 8b 20 04 80 	movabs $0x8004208b16,%rax
  8004200303:	00 00 00 
  8004200306:	ff d0                	callq  *%rax
	// Touch all you want.
#if defined(TEST_EPT_MAP)
	test_ept_map();
#endif

	ENV_CREATE(user_icode, ENV_TYPE_USER);
  8004200308:	be 00 00 00 00       	mov    $0x0,%esi
  800420030d:	48 bf 48 c1 28 04 80 	movabs $0x800428c148,%rdi
  8004200314:	00 00 00 
  8004200317:	48 b8 16 8b 20 04 80 	movabs $0x8004208b16,%rax
  800420031e:	00 00 00 
  8004200321:	ff d0                	callq  *%rax


#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  8004200323:	48 b8 39 11 20 04 80 	movabs $0x8004201139,%rax
  800420032a:	00 00 00 
  800420032d:	ff d0                	callq  *%rax


	// Schedule and run the first user environment!
	sched_yield();
  800420032f:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004200336:	00 00 00 
  8004200339:	ff d0                	callq  *%rax

000000800420033b <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  800420033b:	55                   	push   %rbp
  800420033c:	48 89 e5             	mov    %rsp,%rbp
  800420033f:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200343:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  800420034a:	00 
  800420034b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420034f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004200353:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200356:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200359:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004200360:	00 00 00 
  8004200363:	48 8b 00             	mov    (%rax),%rax
  8004200366:	48 39 c2             	cmp    %rax,%rdx
  8004200369:	72 32                	jb     800420039d <boot_aps+0x62>
  800420036b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420036f:	48 89 c1             	mov    %rax,%rcx
  8004200372:	48 ba 58 71 21 04 80 	movabs $0x8004217158,%rdx
  8004200379:	00 00 00 
  800420037c:	be 9f 00 00 00       	mov    $0x9f,%esi
  8004200381:	48 bf dc 70 21 04 80 	movabs $0x80042170dc,%rdi
  8004200388:	00 00 00 
  800420038b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200390:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004200397:	00 00 00 
  800420039a:	41 ff d0             	callq  *%r8
  800420039d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042003a4:	00 00 00 
  80042003a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042003ab:	48 01 d0             	add    %rdx,%rax
  80042003ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042003b2:	48 ba 2e 53 21 04 80 	movabs $0x800421532e,%rdx
  80042003b9:	00 00 00 
  80042003bc:	48 b8 48 52 21 04 80 	movabs $0x8004215248,%rax
  80042003c3:	00 00 00 
  80042003c6:	48 29 c2             	sub    %rax,%rdx
  80042003c9:	48 89 d0             	mov    %rdx,%rax
  80042003cc:	48 89 c2             	mov    %rax,%rdx
  80042003cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003d3:	48 be 48 52 21 04 80 	movabs $0x8004215248,%rsi
  80042003da:	00 00 00 
  80042003dd:	48 89 c7             	mov    %rax,%rdi
  80042003e0:	48 b8 db ee 20 04 80 	movabs $0x800420eedb,%rax
  80042003e7:	00 00 00 
  80042003ea:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003ec:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  80042003f3:	00 00 00 
  80042003f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042003fa:	e9 0e 01 00 00       	jmpq   800420050d <boot_aps+0x1d2>
		if (c == cpus + cpunum())  // We've started already.
  80042003ff:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004200406:	00 00 00 
  8004200409:	ff d0                	callq  *%rax
  800420040b:	48 98                	cltq   
  800420040d:	48 c1 e0 03          	shl    $0x3,%rax
  8004200411:	48 89 c2             	mov    %rax,%rdx
  8004200414:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200418:	48 01 c2             	add    %rax,%rdx
  800420041b:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  8004200422:	00 00 00 
  8004200425:	48 01 d0             	add    %rdx,%rax
  8004200428:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420042c:	75 05                	jne    8004200433 <boot_aps+0xf8>
			continue;
  800420042e:	e9 d2 00 00 00       	jmpq   8004200505 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200433:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200437:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  800420043e:	00 00 00 
  8004200441:	48 29 c2             	sub    %rax,%rdx
  8004200444:	48 89 d0             	mov    %rdx,%rax
  8004200447:	48 c1 f8 03          	sar    $0x3,%rax
  800420044b:	48 89 c2             	mov    %rax,%rdx
  800420044e:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  8004200455:	f0 f0 f0 
  8004200458:	48 0f af c2          	imul   %rdx,%rax
  800420045c:	48 83 c0 01          	add    $0x1,%rax
  8004200460:	48 c1 e0 10          	shl    $0x10,%rax
  8004200464:	48 89 c2             	mov    %rax,%rdx
  8004200467:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  800420046e:	00 00 00 
  8004200471:	48 01 c2             	add    %rax,%rdx
  8004200474:	48 b8 58 57 37 04 80 	movabs $0x8004375758,%rax
  800420047b:	00 00 00 
  800420047e:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200481:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200485:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200489:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200490:	00 00 00 
  8004200493:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200497:	77 32                	ja     80042004cb <boot_aps+0x190>
  8004200499:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420049d:	48 89 c1             	mov    %rax,%rcx
  80042004a0:	48 ba 80 71 21 04 80 	movabs $0x8004217180,%rdx
  80042004a7:	00 00 00 
  80042004aa:	be a9 00 00 00       	mov    $0xa9,%esi
  80042004af:	48 bf dc 70 21 04 80 	movabs $0x80042170dc,%rdi
  80042004b6:	00 00 00 
  80042004b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042004be:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042004c5:	00 00 00 
  80042004c8:	41 ff d0             	callq  *%r8
  80042004cb:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042004d2:	ff ff ff 
  80042004d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042004d9:	48 01 d0             	add    %rdx,%rax
  80042004dc:	89 c2                	mov    %eax,%edx
  80042004de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042004e2:	0f b6 00             	movzbl (%rax),%eax
  80042004e5:	0f b6 c0             	movzbl %al,%eax
  80042004e8:	89 d6                	mov    %edx,%esi
  80042004ea:	89 c7                	mov    %eax,%edi
  80042004ec:	48 b8 ca 5e 21 04 80 	movabs $0x8004215eca,%rax
  80042004f3:	00 00 00 
  80042004f6:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042004f8:	90                   	nop
  80042004f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042004fd:	8b 40 04             	mov    0x4(%rax),%eax
  8004200500:	83 f8 01             	cmp    $0x1,%eax
  8004200503:	75 f4                	jne    80042004f9 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200505:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  800420050c:	00 
  800420050d:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  8004200514:	00 00 00 
  8004200517:	8b 00                	mov    (%rax),%eax
  8004200519:	48 98                	cltq   
  800420051b:	48 c1 e0 03          	shl    $0x3,%rax
  800420051f:	48 89 c2             	mov    %rax,%rdx
  8004200522:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200526:	48 01 c2             	add    %rax,%rdx
  8004200529:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  8004200530:	00 00 00 
  8004200533:	48 01 d0             	add    %rdx,%rax
  8004200536:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420053a:	0f 87 bf fe ff ff    	ja     80042003ff <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  8004200540:	c9                   	leaveq 
  8004200541:	c3                   	retq   

0000008004200542 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  8004200542:	55                   	push   %rbp
  8004200543:	48 89 e5             	mov    %rsp,%rbp
  8004200546:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  800420054a:	48 b8 68 57 37 04 80 	movabs $0x8004375768,%rax
  8004200551:	00 00 00 
  8004200554:	48 8b 00             	mov    (%rax),%rax
  8004200557:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420055b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420055f:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  8004200562:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004200569:	00 00 00 
  800420056c:	ff d0                	callq  *%rax
  800420056e:	89 c6                	mov    %eax,%esi
  8004200570:	48 bf a4 71 21 04 80 	movabs $0x80042171a4,%rdi
  8004200577:	00 00 00 
  800420057a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420057f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004200586:	00 00 00 
  8004200589:	ff d2                	callq  *%rdx

	lapic_init();
  800420058b:	48 b8 63 5c 21 04 80 	movabs $0x8004215c63,%rax
  8004200592:	00 00 00 
  8004200595:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200597:	48 b8 6f 85 20 04 80 	movabs $0x800420856f,%rax
  800420059e:	00 00 00 
  80042005a1:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042005a3:	48 b8 65 ae 20 04 80 	movabs $0x800420ae65,%rax
  80042005aa:	00 00 00 
  80042005ad:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042005af:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042005b6:	00 00 00 
  80042005b9:	ff d0                	callq  *%rax
  80042005bb:	48 98                	cltq   
  80042005bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042005c1:	48 89 c2             	mov    %rax,%rdx
  80042005c4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042005c8:	48 01 d0             	add    %rdx,%rax
  80042005cb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042005d2:	00 00 00 
  80042005d5:	48 01 d0             	add    %rdx,%rax
  80042005d8:	48 83 c0 04          	add    $0x4,%rax
  80042005dc:	be 01 00 00 00       	mov    $0x1,%esi
  80042005e1:	48 89 c7             	mov    %rax,%rdi
  80042005e4:	48 b8 ce 00 20 04 80 	movabs $0x80042000ce,%rax
  80042005eb:	00 00 00 
  80042005ee:	ff d0                	callq  *%rax
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:


	lock_kernel();
  80042005f0:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  80042005f7:	00 00 00 
  80042005fa:	ff d0                	callq  *%rax
	sched_yield();
  80042005fc:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004200603:	00 00 00 
  8004200606:	ff d0                	callq  *%rax

0000008004200608 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200608:	55                   	push   %rbp
  8004200609:	48 89 e5             	mov    %rsp,%rbp
  800420060c:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200613:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420061a:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200620:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200627:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420062e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200635:	84 c0                	test   %al,%al
  8004200637:	74 20                	je     8004200659 <_panic+0x51>
  8004200639:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420063d:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200641:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200645:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200649:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420064d:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200651:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200655:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200659:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200660:	48 b8 50 57 37 04 80 	movabs $0x8004375750,%rax
  8004200667:	00 00 00 
  800420066a:	48 8b 00             	mov    (%rax),%rax
  800420066d:	48 85 c0             	test   %rax,%rax
  8004200670:	74 05                	je     8004200677 <_panic+0x6f>
		goto dead;
  8004200672:	e9 b5 00 00 00       	jmpq   800420072c <_panic+0x124>
	panicstr = fmt;
  8004200677:	48 b8 50 57 37 04 80 	movabs $0x8004375750,%rax
  800420067e:	00 00 00 
  8004200681:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200688:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  800420068b:	fa                   	cli    
  800420068c:	fc                   	cld    

	va_start(ap, fmt);
  800420068d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200694:	00 00 00 
  8004200697:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420069e:	00 00 00 
  80042006a1:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006a5:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006ac:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006b3:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042006ba:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042006c1:	00 00 00 
  80042006c4:	ff d0                	callq  *%rax
  80042006c6:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042006cc:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042006d3:	89 c6                	mov    %eax,%esi
  80042006d5:	48 bf c0 71 21 04 80 	movabs $0x80042171c0,%rdi
  80042006dc:	00 00 00 
  80042006df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006e4:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  80042006eb:	00 00 00 
  80042006ee:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  80042006f1:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006f8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006ff:	48 89 d6             	mov    %rdx,%rsi
  8004200702:	48 89 c7             	mov    %rax,%rdi
  8004200705:	48 b8 20 97 20 04 80 	movabs $0x8004209720,%rax
  800420070c:	00 00 00 
  800420070f:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200711:	48 bf e2 71 21 04 80 	movabs $0x80042171e2,%rdi
  8004200718:	00 00 00 
  800420071b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200720:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004200727:	00 00 00 
  800420072a:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  800420072c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200731:	48 b8 e7 24 20 04 80 	movabs $0x80042024e7,%rax
  8004200738:	00 00 00 
  800420073b:	ff d0                	callq  *%rax
  800420073d:	eb ed                	jmp    800420072c <_panic+0x124>

000000800420073f <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420073f:	55                   	push   %rbp
  8004200740:	48 89 e5             	mov    %rsp,%rbp
  8004200743:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420074a:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200751:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200757:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420075e:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200765:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420076c:	84 c0                	test   %al,%al
  800420076e:	74 20                	je     8004200790 <_warn+0x51>
  8004200770:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200774:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200778:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420077c:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200780:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200784:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200788:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420078c:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200790:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200797:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420079e:	00 00 00 
  80042007a1:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042007a8:	00 00 00 
  80042007ab:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042007af:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042007b6:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042007bd:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042007c4:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042007ca:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042007d1:	48 89 c6             	mov    %rax,%rsi
  80042007d4:	48 bf e4 71 21 04 80 	movabs $0x80042171e4,%rdi
  80042007db:	00 00 00 
  80042007de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042007e3:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  80042007ea:	00 00 00 
  80042007ed:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042007ef:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042007f6:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042007fd:	48 89 d6             	mov    %rdx,%rsi
  8004200800:	48 89 c7             	mov    %rax,%rdi
  8004200803:	48 b8 20 97 20 04 80 	movabs $0x8004209720,%rax
  800420080a:	00 00 00 
  800420080d:	ff d0                	callq  *%rax
	cprintf("\n");
  800420080f:	48 bf e2 71 21 04 80 	movabs $0x80042171e2,%rdi
  8004200816:	00 00 00 
  8004200819:	b8 00 00 00 00       	mov    $0x0,%eax
  800420081e:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004200825:	00 00 00 
  8004200828:	ff d2                	callq  *%rdx
	va_end(ap);
}
  800420082a:	c9                   	leaveq 
  800420082b:	c3                   	retq   

000000800420082c <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  800420082c:	55                   	push   %rbp
  800420082d:	48 89 e5             	mov    %rsp,%rbp
  8004200830:	48 83 ec 20          	sub    $0x20,%rsp
  8004200834:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420083b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420083e:	89 c2                	mov    %eax,%edx
  8004200840:	ec                   	in     (%dx),%al
  8004200841:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200844:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  800420084b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420084e:	89 c2                	mov    %eax,%edx
  8004200850:	ec                   	in     (%dx),%al
  8004200851:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004200854:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  800420085b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420085e:	89 c2                	mov    %eax,%edx
  8004200860:	ec                   	in     (%dx),%al
  8004200861:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200864:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  800420086b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420086e:	89 c2                	mov    %eax,%edx
  8004200870:	ec                   	in     (%dx),%al
  8004200871:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200874:	c9                   	leaveq 
  8004200875:	c3                   	retq   

0000008004200876 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200876:	55                   	push   %rbp
  8004200877:	48 89 e5             	mov    %rsp,%rbp
  800420087a:	48 83 ec 10          	sub    $0x10,%rsp
  800420087e:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  8004200885:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200888:	89 c2                	mov    %eax,%edx
  800420088a:	ec                   	in     (%dx),%al
  800420088b:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  800420088e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  8004200892:	0f b6 c0             	movzbl %al,%eax
  8004200895:	83 e0 01             	and    $0x1,%eax
  8004200898:	85 c0                	test   %eax,%eax
  800420089a:	75 07                	jne    80042008a3 <serial_proc_data+0x2d>
		return -1;
  800420089c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042008a1:	eb 17                	jmp    80042008ba <serial_proc_data+0x44>
  80042008a3:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042008ad:	89 c2                	mov    %eax,%edx
  80042008af:	ec                   	in     (%dx),%al
  80042008b0:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  80042008b3:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042008b7:	0f b6 c0             	movzbl %al,%eax
}
  80042008ba:	c9                   	leaveq 
  80042008bb:	c3                   	retq   

00000080042008bc <serial_intr>:

void
serial_intr(void)
{
  80042008bc:	55                   	push   %rbp
  80042008bd:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042008c0:	48 b8 00 40 37 04 80 	movabs $0x8004374000,%rax
  80042008c7:	00 00 00 
  80042008ca:	0f b6 00             	movzbl (%rax),%eax
  80042008cd:	84 c0                	test   %al,%al
  80042008cf:	74 16                	je     80042008e7 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042008d1:	48 bf 76 08 20 04 80 	movabs $0x8004200876,%rdi
  80042008d8:	00 00 00 
  80042008db:	48 b8 8a 11 20 04 80 	movabs $0x800420118a,%rax
  80042008e2:	00 00 00 
  80042008e5:	ff d0                	callq  *%rax
}
  80042008e7:	5d                   	pop    %rbp
  80042008e8:	c3                   	retq   

00000080042008e9 <serial_putc>:

static void
serial_putc(int c)
{
  80042008e9:	55                   	push   %rbp
  80042008ea:	48 89 e5             	mov    %rsp,%rbp
  80042008ed:	48 83 ec 28          	sub    $0x28,%rsp
  80042008f1:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  80042008f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042008fb:	eb 10                	jmp    800420090d <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  80042008fd:	48 b8 2c 08 20 04 80 	movabs $0x800420082c,%rax
  8004200904:	00 00 00 
  8004200907:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200909:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420090d:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200914:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200917:	89 c2                	mov    %eax,%edx
  8004200919:	ec                   	in     (%dx),%al
  800420091a:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  800420091d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200921:	0f b6 c0             	movzbl %al,%eax
  8004200924:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200927:	85 c0                	test   %eax,%eax
  8004200929:	75 09                	jne    8004200934 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420092b:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200932:	7e c9                	jle    80042008fd <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200934:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200937:	0f b6 c0             	movzbl %al,%eax
  800420093a:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  8004200941:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200944:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200948:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420094b:	ee                   	out    %al,(%dx)
}
  800420094c:	c9                   	leaveq 
  800420094d:	c3                   	retq   

000000800420094e <serial_init>:

static void
serial_init(void)
{
  800420094e:	55                   	push   %rbp
  800420094f:	48 89 e5             	mov    %rsp,%rbp
  8004200952:	48 83 ec 50          	sub    $0x50,%rsp
  8004200956:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  800420095d:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  8004200961:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200965:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200968:	ee                   	out    %al,(%dx)
  8004200969:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  8004200970:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  8004200974:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004200978:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420097b:	ee                   	out    %al,(%dx)
  800420097c:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  8004200983:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  8004200987:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420098b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420098e:	ee                   	out    %al,(%dx)
  800420098f:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  8004200996:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  800420099a:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420099e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042009a1:	ee                   	out    %al,(%dx)
  80042009a2:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042009a9:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042009ad:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042009b1:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042009b4:	ee                   	out    %al,(%dx)
  80042009b5:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042009bc:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042009c0:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042009c4:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042009c7:	ee                   	out    %al,(%dx)
  80042009c8:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  80042009cf:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  80042009d3:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042009d7:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042009da:	ee                   	out    %al,(%dx)
  80042009db:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009e2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042009e5:	89 c2                	mov    %eax,%edx
  80042009e7:	ec                   	in     (%dx),%al
  80042009e8:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  80042009eb:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  80042009ef:	3c ff                	cmp    $0xff,%al
  80042009f1:	0f 95 c2             	setne  %dl
  80042009f4:	48 b8 00 40 37 04 80 	movabs $0x8004374000,%rax
  80042009fb:	00 00 00 
  80042009fe:	88 10                	mov    %dl,(%rax)
  8004200a00:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a07:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200a0a:	89 c2                	mov    %eax,%edx
  8004200a0c:	ec                   	in     (%dx),%al
  8004200a0d:	88 45 bb             	mov    %al,-0x45(%rbp)
  8004200a10:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200a17:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200a1a:	89 c2                	mov    %eax,%edx
  8004200a1c:	ec                   	in     (%dx),%al
  8004200a1d:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  8004200a20:	48 b8 00 40 37 04 80 	movabs $0x8004374000,%rax
  8004200a27:	00 00 00 
  8004200a2a:	0f b6 00             	movzbl (%rax),%eax
  8004200a2d:	84 c0                	test   %al,%al
  8004200a2f:	74 23                	je     8004200a54 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200a31:	48 b8 d2 b6 22 04 80 	movabs $0x800422b6d2,%rax
  8004200a38:	00 00 00 
  8004200a3b:	0f b7 00             	movzwl (%rax),%eax
  8004200a3e:	0f b7 c0             	movzwl %ax,%eax
  8004200a41:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200a46:	89 c7                	mov    %eax,%edi
  8004200a48:	48 b8 d1 95 20 04 80 	movabs $0x80042095d1,%rax
  8004200a4f:	00 00 00 
  8004200a52:	ff d0                	callq  *%rax
}
  8004200a54:	c9                   	leaveq 
  8004200a55:	c3                   	retq   

0000008004200a56 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200a56:	55                   	push   %rbp
  8004200a57:	48 89 e5             	mov    %rsp,%rbp
  8004200a5a:	48 83 ec 38          	sub    $0x38,%rsp
  8004200a5e:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a61:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200a68:	eb 10                	jmp    8004200a7a <lpt_putc+0x24>
		delay();
  8004200a6a:	48 b8 2c 08 20 04 80 	movabs $0x800420082c,%rax
  8004200a71:	00 00 00 
  8004200a74:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200a76:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200a7a:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200a81:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200a84:	89 c2                	mov    %eax,%edx
  8004200a86:	ec                   	in     (%dx),%al
  8004200a87:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  8004200a8a:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200a8e:	84 c0                	test   %al,%al
  8004200a90:	78 09                	js     8004200a9b <lpt_putc+0x45>
  8004200a92:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200a99:	7e cf                	jle    8004200a6a <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200a9b:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200a9e:	0f b6 c0             	movzbl %al,%eax
  8004200aa1:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  8004200aa8:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200aab:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200aaf:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200ab2:	ee                   	out    %al,(%dx)
  8004200ab3:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200aba:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200abe:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200ac2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200ac5:	ee                   	out    %al,(%dx)
  8004200ac6:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200acd:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200ad1:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200ad5:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200ad8:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200ad9:	c9                   	leaveq 
  8004200ada:	c3                   	retq   

0000008004200adb <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200adb:	55                   	push   %rbp
  8004200adc:	48 89 e5             	mov    %rsp,%rbp
  8004200adf:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200ae3:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200aea:	00 00 00 
  8004200aed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200af1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200af5:	0f b7 00             	movzwl (%rax),%eax
  8004200af8:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200afc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b00:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200b05:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b09:	0f b7 00             	movzwl (%rax),%eax
  8004200b0c:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200b10:	74 20                	je     8004200b32 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200b12:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200b19:	00 00 00 
  8004200b1c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200b20:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200b27:	00 00 00 
  8004200b2a:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200b30:	eb 1b                	jmp    8004200b4d <cga_init+0x72>
	} else {
		*cp = was;
  8004200b32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b36:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200b3a:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200b3d:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200b44:	00 00 00 
  8004200b47:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200b4d:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200b54:	00 00 00 
  8004200b57:	8b 00                	mov    (%rax),%eax
  8004200b59:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200b5c:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200b60:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200b64:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200b67:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200b68:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200b6f:	00 00 00 
  8004200b72:	8b 00                	mov    (%rax),%eax
  8004200b74:	83 c0 01             	add    $0x1,%eax
  8004200b77:	89 45 e4             	mov    %eax,-0x1c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b7a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200b7d:	89 c2                	mov    %eax,%edx
  8004200b7f:	ec                   	in     (%dx),%al
  8004200b80:	88 45 e3             	mov    %al,-0x1d(%rbp)
    return data;
  8004200b83:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200b87:	0f b6 c0             	movzbl %al,%eax
  8004200b8a:	c1 e0 08             	shl    $0x8,%eax
  8004200b8d:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200b90:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200b97:	00 00 00 
  8004200b9a:	8b 00                	mov    (%rax),%eax
  8004200b9c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200b9f:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200ba3:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200ba7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200baa:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200bab:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200bb2:	00 00 00 
  8004200bb5:	8b 00                	mov    (%rax),%eax
  8004200bb7:	83 c0 01             	add    $0x1,%eax
  8004200bba:	89 45 d4             	mov    %eax,-0x2c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200bbd:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200bc0:	89 c2                	mov    %eax,%edx
  8004200bc2:	ec                   	in     (%dx),%al
  8004200bc3:	88 45 d3             	mov    %al,-0x2d(%rbp)
    return data;
  8004200bc6:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200bca:	0f b6 c0             	movzbl %al,%eax
  8004200bcd:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200bd0:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200bd7:	00 00 00 
  8004200bda:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200bde:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200be1:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200be4:	89 c2                	mov    %eax,%edx
  8004200be6:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200bed:	00 00 00 
  8004200bf0:	66 89 10             	mov    %dx,(%rax)
}
  8004200bf3:	c9                   	leaveq 
  8004200bf4:	c3                   	retq   

0000008004200bf5 <cga_putc>:



static void
cga_putc(int c)
{
  8004200bf5:	55                   	push   %rbp
  8004200bf6:	48 89 e5             	mov    %rsp,%rbp
  8004200bf9:	48 83 ec 40          	sub    $0x40,%rsp
  8004200bfd:	89 7d cc             	mov    %edi,-0x34(%rbp)
	c|= current_color<<8;
  8004200c00:	48 b8 60 57 37 04 80 	movabs $0x8004375760,%rax
  8004200c07:	00 00 00 
  8004200c0a:	8b 00                	mov    (%rax),%eax
  8004200c0c:	c1 e0 08             	shl    $0x8,%eax
  8004200c0f:	09 45 cc             	or     %eax,-0x34(%rbp)
	// if no attribute given, then use black on white
	// if (!(c & ~0xFF))
	// 	c |= 0x0700;

	switch (c & 0xff) {
  8004200c12:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c15:	0f b6 c0             	movzbl %al,%eax
  8004200c18:	83 f8 09             	cmp    $0x9,%eax
  8004200c1b:	0f 84 f6 00 00 00    	je     8004200d17 <cga_putc+0x122>
  8004200c21:	83 f8 09             	cmp    $0x9,%eax
  8004200c24:	7f 0a                	jg     8004200c30 <cga_putc+0x3b>
  8004200c26:	83 f8 08             	cmp    $0x8,%eax
  8004200c29:	74 18                	je     8004200c43 <cga_putc+0x4e>
  8004200c2b:	e9 3e 01 00 00       	jmpq   8004200d6e <cga_putc+0x179>
  8004200c30:	83 f8 0a             	cmp    $0xa,%eax
  8004200c33:	74 75                	je     8004200caa <cga_putc+0xb5>
  8004200c35:	83 f8 0d             	cmp    $0xd,%eax
  8004200c38:	0f 84 89 00 00 00    	je     8004200cc7 <cga_putc+0xd2>
  8004200c3e:	e9 2b 01 00 00       	jmpq   8004200d6e <cga_putc+0x179>
	case '\b':
		if (crt_pos > 0) {
  8004200c43:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200c4a:	00 00 00 
  8004200c4d:	0f b7 00             	movzwl (%rax),%eax
  8004200c50:	66 85 c0             	test   %ax,%ax
  8004200c53:	74 50                	je     8004200ca5 <cga_putc+0xb0>
			crt_pos--;
  8004200c55:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200c5c:	00 00 00 
  8004200c5f:	0f b7 00             	movzwl (%rax),%eax
  8004200c62:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200c65:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200c6c:	00 00 00 
  8004200c6f:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200c72:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200c79:	00 00 00 
  8004200c7c:	48 8b 10             	mov    (%rax),%rdx
  8004200c7f:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200c86:	00 00 00 
  8004200c89:	0f b7 00             	movzwl (%rax),%eax
  8004200c8c:	0f b7 c0             	movzwl %ax,%eax
  8004200c8f:	48 01 c0             	add    %rax,%rax
  8004200c92:	48 01 c2             	add    %rax,%rdx
  8004200c95:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c98:	b0 00                	mov    $0x0,%al
  8004200c9a:	83 c8 20             	or     $0x20,%eax
  8004200c9d:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200ca0:	e9 04 01 00 00       	jmpq   8004200da9 <cga_putc+0x1b4>
  8004200ca5:	e9 ff 00 00 00       	jmpq   8004200da9 <cga_putc+0x1b4>
	case '\n':
		crt_pos += CRT_COLS;
  8004200caa:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200cb1:	00 00 00 
  8004200cb4:	0f b7 00             	movzwl (%rax),%eax
  8004200cb7:	8d 50 50             	lea    0x50(%rax),%edx
  8004200cba:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200cc1:	00 00 00 
  8004200cc4:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200cc7:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200cce:	00 00 00 
  8004200cd1:	0f b7 30             	movzwl (%rax),%esi
  8004200cd4:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200cdb:	00 00 00 
  8004200cde:	0f b7 08             	movzwl (%rax),%ecx
  8004200ce1:	0f b7 c1             	movzwl %cx,%eax
  8004200ce4:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200cea:	c1 e8 10             	shr    $0x10,%eax
  8004200ced:	89 c2                	mov    %eax,%edx
  8004200cef:	66 c1 ea 06          	shr    $0x6,%dx
  8004200cf3:	89 d0                	mov    %edx,%eax
  8004200cf5:	c1 e0 02             	shl    $0x2,%eax
  8004200cf8:	01 d0                	add    %edx,%eax
  8004200cfa:	c1 e0 04             	shl    $0x4,%eax
  8004200cfd:	29 c1                	sub    %eax,%ecx
  8004200cff:	89 ca                	mov    %ecx,%edx
  8004200d01:	29 d6                	sub    %edx,%esi
  8004200d03:	89 f2                	mov    %esi,%edx
  8004200d05:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200d0c:	00 00 00 
  8004200d0f:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200d12:	e9 92 00 00 00       	jmpq   8004200da9 <cga_putc+0x1b4>
	case '\t':
		cons_putc(' ');
  8004200d17:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d1c:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004200d23:	00 00 00 
  8004200d26:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d28:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d2d:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004200d34:	00 00 00 
  8004200d37:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d39:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d3e:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004200d45:	00 00 00 
  8004200d48:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d4a:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d4f:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004200d56:	00 00 00 
  8004200d59:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d5b:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d60:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004200d67:	00 00 00 
  8004200d6a:	ff d0                	callq  *%rax
		break;
  8004200d6c:	eb 3b                	jmp    8004200da9 <cga_putc+0x1b4>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200d6e:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200d75:	00 00 00 
  8004200d78:	48 8b 30             	mov    (%rax),%rsi
  8004200d7b:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200d82:	00 00 00 
  8004200d85:	0f b7 00             	movzwl (%rax),%eax
  8004200d88:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200d8b:	48 ba 10 40 37 04 80 	movabs $0x8004374010,%rdx
  8004200d92:	00 00 00 
  8004200d95:	66 89 0a             	mov    %cx,(%rdx)
  8004200d98:	0f b7 c0             	movzwl %ax,%eax
  8004200d9b:	48 01 c0             	add    %rax,%rax
  8004200d9e:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200da2:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200da5:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200da8:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200da9:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200db0:	00 00 00 
  8004200db3:	0f b7 00             	movzwl (%rax),%eax
  8004200db6:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200dba:	0f 86 89 00 00 00    	jbe    8004200e49 <cga_putc+0x254>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200dc0:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200dc7:	00 00 00 
  8004200dca:	48 8b 00             	mov    (%rax),%rax
  8004200dcd:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200dd4:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200ddb:	00 00 00 
  8004200dde:	48 8b 00             	mov    (%rax),%rax
  8004200de1:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200de6:	48 89 ce             	mov    %rcx,%rsi
  8004200de9:	48 89 c7             	mov    %rax,%rdi
  8004200dec:	48 b8 db ee 20 04 80 	movabs $0x800420eedb,%rax
  8004200df3:	00 00 00 
  8004200df6:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200df8:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200dff:	eb 22                	jmp    8004200e23 <cga_putc+0x22e>
			crt_buf[i] = 0x0700 | ' ';
  8004200e01:	48 b8 08 40 37 04 80 	movabs $0x8004374008,%rax
  8004200e08:	00 00 00 
  8004200e0b:	48 8b 00             	mov    (%rax),%rax
  8004200e0e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200e11:	48 63 d2             	movslq %edx,%rdx
  8004200e14:	48 01 d2             	add    %rdx,%rdx
  8004200e17:	48 01 d0             	add    %rdx,%rax
  8004200e1a:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200e1f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200e23:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200e2a:	7e d5                	jle    8004200e01 <cga_putc+0x20c>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200e2c:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200e33:	00 00 00 
  8004200e36:	0f b7 00             	movzwl (%rax),%eax
  8004200e39:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200e3c:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200e43:	00 00 00 
  8004200e46:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200e49:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200e50:	00 00 00 
  8004200e53:	8b 00                	mov    (%rax),%eax
  8004200e55:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200e58:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200e5c:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200e60:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200e63:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200e64:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200e6b:	00 00 00 
  8004200e6e:	0f b7 00             	movzwl (%rax),%eax
  8004200e71:	66 c1 e8 08          	shr    $0x8,%ax
  8004200e75:	0f b6 c0             	movzbl %al,%eax
  8004200e78:	48 ba 04 40 37 04 80 	movabs $0x8004374004,%rdx
  8004200e7f:	00 00 00 
  8004200e82:	8b 12                	mov    (%rdx),%edx
  8004200e84:	83 c2 01             	add    $0x1,%edx
  8004200e87:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200e8a:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200e8d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200e91:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200e94:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200e95:	48 b8 04 40 37 04 80 	movabs $0x8004374004,%rax
  8004200e9c:	00 00 00 
  8004200e9f:	8b 00                	mov    (%rax),%eax
  8004200ea1:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200ea4:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200ea8:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200eac:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200eaf:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200eb0:	48 b8 10 40 37 04 80 	movabs $0x8004374010,%rax
  8004200eb7:	00 00 00 
  8004200eba:	0f b7 00             	movzwl (%rax),%eax
  8004200ebd:	0f b6 c0             	movzbl %al,%eax
  8004200ec0:	48 ba 04 40 37 04 80 	movabs $0x8004374004,%rdx
  8004200ec7:	00 00 00 
  8004200eca:	8b 12                	mov    (%rdx),%edx
  8004200ecc:	83 c2 01             	add    $0x1,%edx
  8004200ecf:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200ed2:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200ed5:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200ed9:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200edc:	ee                   	out    %al,(%dx)
}
  8004200edd:	c9                   	leaveq 
  8004200ede:	c3                   	retq   

0000008004200edf <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200edf:	55                   	push   %rbp
  8004200ee0:	48 89 e5             	mov    %rsp,%rbp
  8004200ee3:	48 83 ec 30          	sub    $0x30,%rsp
  8004200ee7:	c7 45 f0 64 00 00 00 	movl   $0x64,-0x10(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200eee:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200ef1:	89 c2                	mov    %eax,%edx
  8004200ef3:	ec                   	in     (%dx),%al
  8004200ef4:	88 45 ef             	mov    %al,-0x11(%rbp)
    return data;
  8004200ef7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200efb:	0f b6 c0             	movzbl %al,%eax
  8004200efe:	83 e0 01             	and    $0x1,%eax
  8004200f01:	85 c0                	test   %eax,%eax
  8004200f03:	75 0a                	jne    8004200f0f <kbd_proc_data+0x30>
		return -1;
  8004200f05:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200f0a:	e9 28 02 00 00       	jmpq   8004201137 <kbd_proc_data+0x258>
  8004200f0f:	c7 45 e8 60 00 00 00 	movl   $0x60,-0x18(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200f16:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200f19:	89 c2                	mov    %eax,%edx
  8004200f1b:	ec                   	in     (%dx),%al
  8004200f1c:	88 45 e7             	mov    %al,-0x19(%rbp)
    return data;
  8004200f1f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax

	data = inb(KBDATAP);
  8004200f23:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200f26:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200f2a:	75 27                	jne    8004200f53 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200f2c:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200f33:	00 00 00 
  8004200f36:	8b 00                	mov    (%rax),%eax
  8004200f38:	83 c8 40             	or     $0x40,%eax
  8004200f3b:	89 c2                	mov    %eax,%edx
  8004200f3d:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200f44:	00 00 00 
  8004200f47:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f4e:	e9 e4 01 00 00       	jmpq   8004201137 <kbd_proc_data+0x258>
	} else if (data & 0x80) {
  8004200f53:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f57:	84 c0                	test   %al,%al
  8004200f59:	79 65                	jns    8004200fc0 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200f5b:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200f62:	00 00 00 
  8004200f65:	8b 00                	mov    (%rax),%eax
  8004200f67:	83 e0 40             	and    $0x40,%eax
  8004200f6a:	85 c0                	test   %eax,%eax
  8004200f6c:	75 09                	jne    8004200f77 <kbd_proc_data+0x98>
  8004200f6e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f72:	83 e0 7f             	and    $0x7f,%eax
  8004200f75:	eb 04                	jmp    8004200f7b <kbd_proc_data+0x9c>
  8004200f77:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f7b:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200f7e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f82:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200f89:	00 00 00 
  8004200f8c:	48 98                	cltq   
  8004200f8e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f92:	83 c8 40             	or     $0x40,%eax
  8004200f95:	0f b6 c0             	movzbl %al,%eax
  8004200f98:	f7 d0                	not    %eax
  8004200f9a:	89 c2                	mov    %eax,%edx
  8004200f9c:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200fa3:	00 00 00 
  8004200fa6:	8b 00                	mov    (%rax),%eax
  8004200fa8:	21 c2                	and    %eax,%edx
  8004200faa:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200fb1:	00 00 00 
  8004200fb4:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200fb6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200fbb:	e9 77 01 00 00       	jmpq   8004201137 <kbd_proc_data+0x258>
	} else if (shift & E0ESC) {
  8004200fc0:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200fc7:	00 00 00 
  8004200fca:	8b 00                	mov    (%rax),%eax
  8004200fcc:	83 e0 40             	and    $0x40,%eax
  8004200fcf:	85 c0                	test   %eax,%eax
  8004200fd1:	74 21                	je     8004200ff4 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200fd3:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200fd7:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200fde:	00 00 00 
  8004200fe1:	8b 00                	mov    (%rax),%eax
  8004200fe3:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200fe6:	89 c2                	mov    %eax,%edx
  8004200fe8:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004200fef:	00 00 00 
  8004200ff2:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200ff4:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ff8:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200fff:	00 00 00 
  8004201002:	48 98                	cltq   
  8004201004:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201008:	0f b6 d0             	movzbl %al,%edx
  800420100b:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004201012:	00 00 00 
  8004201015:	8b 00                	mov    (%rax),%eax
  8004201017:	09 c2                	or     %eax,%edx
  8004201019:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004201020:	00 00 00 
  8004201023:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004201025:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004201029:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  8004201030:	00 00 00 
  8004201033:	48 98                	cltq   
  8004201035:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201039:	0f b6 d0             	movzbl %al,%edx
  800420103c:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004201043:	00 00 00 
  8004201046:	8b 00                	mov    (%rax),%eax
  8004201048:	31 c2                	xor    %eax,%edx
  800420104a:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  8004201051:	00 00 00 
  8004201054:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004201056:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  800420105d:	00 00 00 
  8004201060:	8b 00                	mov    (%rax),%eax
  8004201062:	83 e0 03             	and    $0x3,%eax
  8004201065:	89 c2                	mov    %eax,%edx
  8004201067:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  800420106e:	00 00 00 
  8004201071:	89 d2                	mov    %edx,%edx
  8004201073:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004201077:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420107b:	48 01 d0             	add    %rdx,%rax
  800420107e:	0f b6 00             	movzbl (%rax),%eax
  8004201081:	0f b6 c0             	movzbl %al,%eax
  8004201084:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004201087:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  800420108e:	00 00 00 
  8004201091:	8b 00                	mov    (%rax),%eax
  8004201093:	83 e0 08             	and    $0x8,%eax
  8004201096:	85 c0                	test   %eax,%eax
  8004201098:	74 22                	je     80042010bc <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  800420109a:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  800420109e:	7e 0c                	jle    80042010ac <kbd_proc_data+0x1cd>
  80042010a0:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  80042010a4:	7f 06                	jg     80042010ac <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  80042010a6:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  80042010aa:	eb 10                	jmp    80042010bc <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  80042010ac:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  80042010b0:	7e 0a                	jle    80042010bc <kbd_proc_data+0x1dd>
  80042010b2:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  80042010b6:	7f 04                	jg     80042010bc <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  80042010b8:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  80042010bc:	48 b8 28 42 37 04 80 	movabs $0x8004374228,%rax
  80042010c3:	00 00 00 
  80042010c6:	8b 00                	mov    (%rax),%eax
  80042010c8:	f7 d0                	not    %eax
  80042010ca:	83 e0 06             	and    $0x6,%eax
  80042010cd:	85 c0                	test   %eax,%eax
  80042010cf:	75 37                	jne    8004201108 <kbd_proc_data+0x229>
  80042010d1:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  80042010d8:	75 2e                	jne    8004201108 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  80042010da:	48 bf fe 71 21 04 80 	movabs $0x80042171fe,%rdi
  80042010e1:	00 00 00 
  80042010e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042010e9:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042010f0:	00 00 00 
  80042010f3:	ff d2                	callq  *%rdx
  80042010f5:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%rbp)
  80042010fc:	c6 45 df 03          	movb   $0x3,-0x21(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004201100:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004201104:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004201107:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
#ifdef VMM_GUEST
	if (c == 0x1b) {
  8004201108:	83 7d fc 1b          	cmpl   $0x1b,-0x4(%rbp)
  800420110c:	75 26                	jne    8004201134 <kbd_proc_data+0x255>
		cprintf("ESC pressed\n");
  800420110e:	48 bf 0a 72 21 04 80 	movabs $0x800421720a,%rdi
  8004201115:	00 00 00 
  8004201118:	b8 00 00 00 00       	mov    $0x0,%eax
  800420111d:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201124:	00 00 00 
  8004201127:	ff d2                	callq  *%rdx
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
  8004201129:	b8 05 00 00 00       	mov    $0x5,%eax
  800420112e:	0f 01 c1             	vmcall 
  8004201131:	89 45 f4             	mov    %eax,-0xc(%rbp)
	}
#endif
	return c;
  8004201134:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201137:	c9                   	leaveq 
  8004201138:	c3                   	retq   

0000008004201139 <kbd_intr>:

void
kbd_intr(void)
{
  8004201139:	55                   	push   %rbp
  800420113a:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  800420113d:	48 bf df 0e 20 04 80 	movabs $0x8004200edf,%rdi
  8004201144:	00 00 00 
  8004201147:	48 b8 8a 11 20 04 80 	movabs $0x800420118a,%rax
  800420114e:	00 00 00 
  8004201151:	ff d0                	callq  *%rax
}
  8004201153:	5d                   	pop    %rbp
  8004201154:	c3                   	retq   

0000008004201155 <kbd_init>:

static void
kbd_init(void)
{
  8004201155:	55                   	push   %rbp
  8004201156:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201159:	48 b8 39 11 20 04 80 	movabs $0x8004201139,%rax
  8004201160:	00 00 00 
  8004201163:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201165:	48 b8 d2 b6 22 04 80 	movabs $0x800422b6d2,%rax
  800420116c:	00 00 00 
  800420116f:	0f b7 00             	movzwl (%rax),%eax
  8004201172:	0f b7 c0             	movzwl %ax,%eax
  8004201175:	25 fd ff 00 00       	and    $0xfffd,%eax
  800420117a:	89 c7                	mov    %eax,%edi
  800420117c:	48 b8 d1 95 20 04 80 	movabs $0x80042095d1,%rax
  8004201183:	00 00 00 
  8004201186:	ff d0                	callq  *%rax
}
  8004201188:	5d                   	pop    %rbp
  8004201189:	c3                   	retq   

000000800420118a <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  800420118a:	55                   	push   %rbp
  800420118b:	48 89 e5             	mov    %rsp,%rbp
  800420118e:	48 83 ec 20          	sub    $0x20,%rsp
  8004201192:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004201196:	eb 6a                	jmp    8004201202 <cons_intr+0x78>
		if (c == 0)
  8004201198:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420119c:	75 02                	jne    80042011a0 <cons_intr+0x16>
			continue;
  800420119e:	eb 62                	jmp    8004201202 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  80042011a0:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  80042011a7:	00 00 00 
  80042011aa:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042011b0:	8d 48 01             	lea    0x1(%rax),%ecx
  80042011b3:	48 ba 20 40 37 04 80 	movabs $0x8004374020,%rdx
  80042011ba:	00 00 00 
  80042011bd:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042011c3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042011c6:	89 d1                	mov    %edx,%ecx
  80042011c8:	48 ba 20 40 37 04 80 	movabs $0x8004374020,%rdx
  80042011cf:	00 00 00 
  80042011d2:	89 c0                	mov    %eax,%eax
  80042011d4:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042011d7:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  80042011de:	00 00 00 
  80042011e1:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042011e7:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011ec:	75 14                	jne    8004201202 <cons_intr+0x78>
			cons.wpos = 0;
  80042011ee:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  80042011f5:	00 00 00 
  80042011f8:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  80042011ff:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  8004201202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201206:	ff d0                	callq  *%rax
  8004201208:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420120b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420120f:	75 87                	jne    8004201198 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201211:	c9                   	leaveq 
  8004201212:	c3                   	retq   

0000008004201213 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201213:	55                   	push   %rbp
  8004201214:	48 89 e5             	mov    %rsp,%rbp
  8004201217:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  800420121b:	48 b8 bc 08 20 04 80 	movabs $0x80042008bc,%rax
  8004201222:	00 00 00 
  8004201225:	ff d0                	callq  *%rax
	kbd_intr();
  8004201227:	48 b8 39 11 20 04 80 	movabs $0x8004201139,%rax
  800420122e:	00 00 00 
  8004201231:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201233:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  800420123a:	00 00 00 
  800420123d:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201243:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  800420124a:	00 00 00 
  800420124d:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201253:	39 c2                	cmp    %eax,%edx
  8004201255:	74 69                	je     80042012c0 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201257:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  800420125e:	00 00 00 
  8004201261:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201267:	8d 48 01             	lea    0x1(%rax),%ecx
  800420126a:	48 ba 20 40 37 04 80 	movabs $0x8004374020,%rdx
  8004201271:	00 00 00 
  8004201274:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  800420127a:	48 ba 20 40 37 04 80 	movabs $0x8004374020,%rdx
  8004201281:	00 00 00 
  8004201284:	89 c0                	mov    %eax,%eax
  8004201286:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420128a:	0f b6 c0             	movzbl %al,%eax
  800420128d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  8004201290:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  8004201297:	00 00 00 
  800420129a:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042012a0:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042012a5:	75 14                	jne    80042012bb <cons_getc+0xa8>
			cons.rpos = 0;
  80042012a7:	48 b8 20 40 37 04 80 	movabs $0x8004374020,%rax
  80042012ae:	00 00 00 
  80042012b1:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042012b8:	00 00 00 
		return c;
  80042012bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012be:	eb 05                	jmp    80042012c5 <cons_getc+0xb2>
	}
	return 0;
  80042012c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042012c5:	c9                   	leaveq 
  80042012c6:	c3                   	retq   

00000080042012c7 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042012c7:	55                   	push   %rbp
  80042012c8:	48 89 e5             	mov    %rsp,%rbp
  80042012cb:	48 83 ec 10          	sub    $0x10,%rsp
  80042012cf:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042012d2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012d5:	89 c7                	mov    %eax,%edi
  80042012d7:	48 b8 e9 08 20 04 80 	movabs $0x80042008e9,%rax
  80042012de:	00 00 00 
  80042012e1:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042012e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012e6:	89 c7                	mov    %eax,%edi
  80042012e8:	48 b8 56 0a 20 04 80 	movabs $0x8004200a56,%rax
  80042012ef:	00 00 00 
  80042012f2:	ff d0                	callq  *%rax
	cga_putc(c);
  80042012f4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012f7:	89 c7                	mov    %eax,%edi
  80042012f9:	48 b8 f5 0b 20 04 80 	movabs $0x8004200bf5,%rax
  8004201300:	00 00 00 
  8004201303:	ff d0                	callq  *%rax
}
  8004201305:	c9                   	leaveq 
  8004201306:	c3                   	retq   

0000008004201307 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201307:	55                   	push   %rbp
  8004201308:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  800420130b:	48 b8 db 0a 20 04 80 	movabs $0x8004200adb,%rax
  8004201312:	00 00 00 
  8004201315:	ff d0                	callq  *%rax
	kbd_init();
  8004201317:	48 b8 55 11 20 04 80 	movabs $0x8004201155,%rax
  800420131e:	00 00 00 
  8004201321:	ff d0                	callq  *%rax
	serial_init();
  8004201323:	48 b8 4e 09 20 04 80 	movabs $0x800420094e,%rax
  800420132a:	00 00 00 
  800420132d:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420132f:	48 b8 00 40 37 04 80 	movabs $0x8004374000,%rax
  8004201336:	00 00 00 
  8004201339:	0f b6 00             	movzbl (%rax),%eax
  800420133c:	83 f0 01             	xor    $0x1,%eax
  800420133f:	84 c0                	test   %al,%al
  8004201341:	74 1b                	je     800420135e <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201343:	48 bf 17 72 21 04 80 	movabs $0x8004217217,%rdi
  800420134a:	00 00 00 
  800420134d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201352:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201359:	00 00 00 
  800420135c:	ff d2                	callq  *%rdx
}
  800420135e:	5d                   	pop    %rbp
  800420135f:	c3                   	retq   

0000008004201360 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  8004201360:	55                   	push   %rbp
  8004201361:	48 89 e5             	mov    %rsp,%rbp
  8004201364:	48 83 ec 10          	sub    $0x10,%rsp
  8004201368:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  800420136b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420136e:	89 c7                	mov    %eax,%edi
  8004201370:	48 b8 c7 12 20 04 80 	movabs $0x80042012c7,%rax
  8004201377:	00 00 00 
  800420137a:	ff d0                	callq  *%rax
}
  800420137c:	c9                   	leaveq 
  800420137d:	c3                   	retq   

000000800420137e <getchar>:

int
getchar(void)
{
  800420137e:	55                   	push   %rbp
  800420137f:	48 89 e5             	mov    %rsp,%rbp
  8004201382:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201386:	48 b8 13 12 20 04 80 	movabs $0x8004201213,%rax
  800420138d:	00 00 00 
  8004201390:	ff d0                	callq  *%rax
  8004201392:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201395:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201399:	74 eb                	je     8004201386 <getchar+0x8>
		/* do nothing */;
	return c;
  800420139b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420139e:	c9                   	leaveq 
  800420139f:	c3                   	retq   

00000080042013a0 <iscons>:

int
iscons(int fdnum)
{
  80042013a0:	55                   	push   %rbp
  80042013a1:	48 89 e5             	mov    %rsp,%rbp
  80042013a4:	48 83 ec 04          	sub    $0x4,%rsp
  80042013a8:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042013ab:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042013b0:	c9                   	leaveq 
  80042013b1:	c3                   	retq   

00000080042013b2 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042013b2:	55                   	push   %rbp
  80042013b3:	48 89 e5             	mov    %rsp,%rbp
  80042013b6:	48 83 ec 30          	sub    $0x30,%rsp
  80042013ba:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042013bd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042013c1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042013c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042013cc:	eb 6c                	jmp    800420143a <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042013ce:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042013d5:	00 00 00 
  80042013d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013db:	48 63 d0             	movslq %eax,%rdx
  80042013de:	48 89 d0             	mov    %rdx,%rax
  80042013e1:	48 01 c0             	add    %rax,%rax
  80042013e4:	48 01 d0             	add    %rdx,%rax
  80042013e7:	48 c1 e0 03          	shl    $0x3,%rax
  80042013eb:	48 01 c8             	add    %rcx,%rax
  80042013ee:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042013f2:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  80042013f9:	00 00 00 
  80042013fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013ff:	48 63 d0             	movslq %eax,%rdx
  8004201402:	48 89 d0             	mov    %rdx,%rax
  8004201405:	48 01 c0             	add    %rax,%rax
  8004201408:	48 01 d0             	add    %rdx,%rax
  800420140b:	48 c1 e0 03          	shl    $0x3,%rax
  800420140f:	48 01 f0             	add    %rsi,%rax
  8004201412:	48 8b 00             	mov    (%rax),%rax
  8004201415:	48 89 ca             	mov    %rcx,%rdx
  8004201418:	48 89 c6             	mov    %rax,%rsi
  800420141b:	48 bf c3 72 21 04 80 	movabs $0x80042172c3,%rdi
  8004201422:	00 00 00 
  8004201425:	b8 00 00 00 00       	mov    $0x0,%eax
  800420142a:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004201431:	00 00 00 
  8004201434:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201436:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420143a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420143d:	83 f8 07             	cmp    $0x7,%eax
  8004201440:	76 8c                	jbe    80042013ce <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  8004201442:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201447:	c9                   	leaveq 
  8004201448:	c3                   	retq   

0000008004201449 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201449:	55                   	push   %rbp
  800420144a:	48 89 e5             	mov    %rsp,%rbp
  800420144d:	48 83 ec 30          	sub    $0x30,%rsp
  8004201451:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201454:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201458:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  800420145c:	48 bf cc 72 21 04 80 	movabs $0x80042172cc,%rdi
  8004201463:	00 00 00 
  8004201466:	b8 00 00 00 00       	mov    $0x0,%eax
  800420146b:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201472:	00 00 00 
  8004201475:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  8004201477:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  800420147e:	00 00 00 
  8004201481:	48 bf e8 72 21 04 80 	movabs $0x80042172e8,%rdi
  8004201488:	00 00 00 
  800420148b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201490:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201497:	00 00 00 
  800420149a:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420149c:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042014a3:	00 00 00 
  80042014a6:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042014ad:	00 00 00 
  80042014b0:	48 bf 10 73 21 04 80 	movabs $0x8004217310,%rdi
  80042014b7:	00 00 00 
  80042014ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014bf:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  80042014c6:	00 00 00 
  80042014c9:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042014cb:	48 ba a3 70 21 00 00 	movabs $0x2170a3,%rdx
  80042014d2:	00 00 00 
  80042014d5:	48 be a3 70 21 04 80 	movabs $0x80042170a3,%rsi
  80042014dc:	00 00 00 
  80042014df:	48 bf 38 73 21 04 80 	movabs $0x8004217338,%rdi
  80042014e6:	00 00 00 
  80042014e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014ee:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  80042014f5:	00 00 00 
  80042014f8:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  80042014fa:	48 ba 3e 34 37 00 00 	movabs $0x37343e,%rdx
  8004201501:	00 00 00 
  8004201504:	48 be 3e 34 37 04 80 	movabs $0x800437343e,%rsi
  800420150b:	00 00 00 
  800420150e:	48 bf 60 73 21 04 80 	movabs $0x8004217360,%rdi
  8004201515:	00 00 00 
  8004201518:	b8 00 00 00 00       	mov    $0x0,%eax
  800420151d:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004201524:	00 00 00 
  8004201527:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201529:	48 ba 10 80 3b 00 00 	movabs $0x3b8010,%rdx
  8004201530:	00 00 00 
  8004201533:	48 be 10 80 3b 04 80 	movabs $0x80043b8010,%rsi
  800420153a:	00 00 00 
  800420153d:	48 bf 88 73 21 04 80 	movabs $0x8004217388,%rdi
  8004201544:	00 00 00 
  8004201547:	b8 00 00 00 00       	mov    $0x0,%eax
  800420154c:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004201553:	00 00 00 
  8004201556:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201558:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420155f:	00 
  8004201560:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201567:	00 00 00 
  800420156a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420156e:	48 29 c2             	sub    %rax,%rdx
  8004201571:	48 b8 10 80 3b 04 80 	movabs $0x80043b8010,%rax
  8004201578:	00 00 00 
  800420157b:	48 83 e8 01          	sub    $0x1,%rax
  800420157f:	48 01 d0             	add    %rdx,%rax
  8004201582:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004201586:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420158a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420158f:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201593:	48 89 d0             	mov    %rdx,%rax
  8004201596:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420159a:	48 29 c2             	sub    %rax,%rdx
  800420159d:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042015a0:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042015a7:	48 85 c0             	test   %rax,%rax
  80042015aa:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042015ae:	48 c1 f8 0a          	sar    $0xa,%rax
  80042015b2:	48 89 c6             	mov    %rax,%rsi
  80042015b5:	48 bf b0 73 21 04 80 	movabs $0x80042173b0,%rdi
  80042015bc:	00 00 00 
  80042015bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015c4:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042015cb:	00 00 00 
  80042015ce:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042015d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042015d5:	c9                   	leaveq 
  80042015d6:	c3                   	retq   

00000080042015d7 <mon_backtrace>:


int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042015d7:	55                   	push   %rbp
  80042015d8:	48 89 e5             	mov    %rsp,%rbp
  80042015db:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  80042015e2:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  80042015e8:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  80042015ef:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042015f6:	48 89 e8             	mov    %rbp,%rax
  80042015f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    return rbp;
  80042015fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	// Your cod1e here.

	uint64_t *rbp = (uint64_t *)read_rbp();
  8004201601:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint64_t rip;
	read_rip(rip);
  8004201605:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 800420160c <mon_backtrace+0x35>
  800420160c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cprintf("Stack backtrace: \n");
  8004201610:	48 bf da 73 21 04 80 	movabs $0x80042173da,%rdi
  8004201617:	00 00 00 
  800420161a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420161f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201626:	00 00 00 
  8004201629:	ff d2                	callq  *%rdx

	do {
		
		cprintf("rbp %16.0x   rip %16.0x\n", rbp, rip);
  800420162b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420162f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201633:	48 89 c6             	mov    %rax,%rsi
  8004201636:	48 bf ed 73 21 04 80 	movabs $0x80042173ed,%rdi
  800420163d:	00 00 00 
  8004201640:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201645:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800420164c:	00 00 00 
  800420164f:	ff d1                	callq  *%rcx
		struct Ripdebuginfo info;
		debuginfo_rip(rip, &info);
  8004201651:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201658:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420165c:	48 89 d6             	mov    %rdx,%rsi
  800420165f:	48 89 c7             	mov    %rax,%rdi
  8004201662:	48 b8 7b da 20 04 80 	movabs $0x800420da7b,%rax
  8004201669:	00 00 00 
  800420166c:	ff d0                	callq  *%rax
		//file name and line within that file of the stack frame's rip, followed by the name of the function and the offset of the rip from the first instruction of the function 
        int offset=rip-info.rip_fn_addr;
  800420166e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201672:	89 c2                	mov    %eax,%edx
  8004201674:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420167b:	29 c2                	sub    %eax,%edx
  800420167d:	89 d0                	mov    %edx,%eax
  800420167f:	89 45 e8             	mov    %eax,-0x18(%rbp)
		cprintf(" %s:%d: %s+%16.0x ",info.rip_file, info.rip_line, info.rip_fn_name,offset);
  8004201682:	48 8b 8d 10 fb ff ff 	mov    -0x4f0(%rbp),%rcx
  8004201689:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  800420168f:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201696:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8004201699:	41 89 f0             	mov    %esi,%r8d
  800420169c:	48 89 c6             	mov    %rax,%rsi
  800420169f:	48 bf 06 74 21 04 80 	movabs $0x8004217406,%rdi
  80042016a6:	00 00 00 
  80042016a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016ae:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  80042016b5:	00 00 00 
  80042016b8:	41 ff d1             	callq  *%r9
		
		cprintf("args:%x ",info.rip_fn_narg); //number of arguments
  80042016bb:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042016c1:	89 c6                	mov    %eax,%esi
  80042016c3:	48 bf 19 74 21 04 80 	movabs $0x8004217419,%rdi
  80042016ca:	00 00 00 
  80042016cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016d2:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042016d9:	00 00 00 
  80042016dc:	ff d2                	callq  *%rdx
		int i;
		for(i = 1; i <= info.rip_fn_narg; i++) 
  80042016de:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  80042016e5:	eb 39                	jmp    8004201720 <mon_backtrace+0x149>
			cprintf("%16.0x ", *((int *)(rbp) -i));     
  80042016e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042016ea:	48 98                	cltq   
  80042016ec:	48 c1 e0 02          	shl    $0x2,%rax
  80042016f0:	48 f7 d8             	neg    %rax
  80042016f3:	48 89 c2             	mov    %rax,%rdx
  80042016f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016fa:	48 01 d0             	add    %rdx,%rax
  80042016fd:	8b 00                	mov    (%rax),%eax
  80042016ff:	89 c6                	mov    %eax,%esi
  8004201701:	48 bf 22 74 21 04 80 	movabs $0x8004217422,%rdi
  8004201708:	00 00 00 
  800420170b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201710:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201717:	00 00 00 
  800420171a:	ff d2                	callq  *%rdx
        int offset=rip-info.rip_fn_addr;
		cprintf(" %s:%d: %s+%16.0x ",info.rip_file, info.rip_line, info.rip_fn_name,offset);
		
		cprintf("args:%x ",info.rip_fn_narg); //number of arguments
		int i;
		for(i = 1; i <= info.rip_fn_narg; i++) 
  800420171c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201720:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  8004201726:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201729:	7d bc                	jge    80042016e7 <mon_backtrace+0x110>
			cprintf("%16.0x ", *((int *)(rbp) -i));     
		cprintf("\n");
  800420172b:	48 bf 2a 74 21 04 80 	movabs $0x800421742a,%rdi
  8004201732:	00 00 00 
  8004201735:	b8 00 00 00 00       	mov    $0x0,%eax
  800420173a:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201741:	00 00 00 
  8004201744:	ff d2                	callq  *%rdx
		rip = (uint64_t) *(rbp+1);
  8004201746:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420174a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420174e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rbp = (uint64_t *)(*rbp);
  8004201752:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201756:	48 8b 00             	mov    (%rax),%rax
  8004201759:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	} while (rbp!=0);
  800420175d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201762:	0f 85 c3 fe ff ff    	jne    800420162b <mon_backtrace+0x54>
	return 0;
  8004201768:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420176d:	c9                   	leaveq 
  800420176e:	c3                   	retq   

000000800420176f <mon_showmappings>:

int
mon_showmappings(int argc, char **argv, struct Trapframe *tf)
{
  800420176f:	55                   	push   %rbp
  8004201770:	48 89 e5             	mov    %rsp,%rbp
  8004201773:	48 83 ec 70          	sub    $0x70,%rsp
  8004201777:	89 7d ac             	mov    %edi,-0x54(%rbp)
  800420177a:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420177e:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
	
	if (argc!=3)
  8004201782:	83 7d ac 03          	cmpl   $0x3,-0x54(%rbp)
  8004201786:	74 05                	je     800420178d <mon_showmappings+0x1e>
		goto usage;
  8004201788:	e9 8e 02 00 00       	jmpq   8004201a1b <mon_showmappings+0x2ac>
	char *rest;
	uint64_t lower_addr,upper_addr,i;
	lower_addr=strtol(argv[1],&rest,16);
  800420178d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201791:	48 83 c0 08          	add    $0x8,%rax
  8004201795:	48 8b 00             	mov    (%rax),%rax
  8004201798:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  800420179c:	ba 10 00 00 00       	mov    $0x10,%edx
  80042017a1:	48 89 ce             	mov    %rcx,%rsi
  80042017a4:	48 89 c7             	mov    %rax,%rdi
  80042017a7:	48 b8 e3 f0 20 04 80 	movabs $0x800420f0e3,%rax
  80042017ae:	00 00 00 
  80042017b1:	ff d0                	callq  *%rax
  80042017b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (strcmp(rest,"")!=0){
  80042017b7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042017bb:	48 be 2c 74 21 04 80 	movabs $0x800421742c,%rsi
  80042017c2:	00 00 00 
  80042017c5:	48 89 c7             	mov    %rax,%rdi
  80042017c8:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  80042017cf:	00 00 00 
  80042017d2:	ff d0                	callq  *%rax
  80042017d4:	85 c0                	test   %eax,%eax
  80042017d6:	74 05                	je     80042017dd <mon_showmappings+0x6e>
		goto usage;
  80042017d8:	e9 3e 02 00 00       	jmpq   8004201a1b <mon_showmappings+0x2ac>
	}
	upper_addr=strtol(argv[2],&rest,16);
  80042017dd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042017e1:	48 83 c0 10          	add    $0x10,%rax
  80042017e5:	48 8b 00             	mov    (%rax),%rax
  80042017e8:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  80042017ec:	ba 10 00 00 00       	mov    $0x10,%edx
  80042017f1:	48 89 ce             	mov    %rcx,%rsi
  80042017f4:	48 89 c7             	mov    %rax,%rdi
  80042017f7:	48 b8 e3 f0 20 04 80 	movabs $0x800420f0e3,%rax
  80042017fe:	00 00 00 
  8004201801:	ff d0                	callq  *%rax
  8004201803:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (strcmp(rest,"")!=0){
  8004201807:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420180b:	48 be 2c 74 21 04 80 	movabs $0x800421742c,%rsi
  8004201812:	00 00 00 
  8004201815:	48 89 c7             	mov    %rax,%rdi
  8004201818:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  800420181f:	00 00 00 
  8004201822:	ff d0                	callq  *%rax
  8004201824:	85 c0                	test   %eax,%eax
  8004201826:	74 05                	je     800420182d <mon_showmappings+0xbe>
		goto usage;
  8004201828:	e9 ee 01 00 00       	jmpq   8004201a1b <mon_showmappings+0x2ac>
	}
	if (upper_addr!=ROUNDUP(upper_addr,PGSIZE) || lower_addr!=ROUNDUP(lower_addr,PGSIZE))
  800420182d:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004201834:	00 
  8004201835:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201839:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420183d:	48 01 d0             	add    %rdx,%rax
  8004201840:	48 83 e8 01          	sub    $0x1,%rax
  8004201844:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004201848:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420184c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201851:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004201855:	48 89 d0             	mov    %rdx,%rax
  8004201858:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420185c:	48 29 c2             	sub    %rax,%rdx
  800420185f:	48 89 d0             	mov    %rdx,%rax
  8004201862:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004201866:	75 3b                	jne    80042018a3 <mon_showmappings+0x134>
  8004201868:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  800420186f:	00 
  8004201870:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201874:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201878:	48 01 d0             	add    %rdx,%rax
  800420187b:	48 83 e8 01          	sub    $0x1,%rax
  800420187f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004201883:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201887:	ba 00 00 00 00       	mov    $0x0,%edx
  800420188c:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004201890:	48 89 d0             	mov    %rdx,%rax
  8004201893:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004201897:	48 29 c2             	sub    %rax,%rdx
  800420189a:	48 89 d0             	mov    %rdx,%rax
  800420189d:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042018a1:	74 25                	je     80042018c8 <mon_showmappings+0x159>
	{
		cprintf("showmappings: address must be aligned in PGSIZE!\n");
  80042018a3:	48 bf 30 74 21 04 80 	movabs $0x8004217430,%rdi
  80042018aa:	00 00 00 
  80042018ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b2:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042018b9:	00 00 00 
  80042018bc:	ff d2                	callq  *%rdx
		return 0;
  80042018be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018c3:	e9 73 01 00 00       	jmpq   8004201a3b <mon_showmappings+0x2cc>
	}
	if (upper_addr<lower_addr)
  80042018c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042018cc:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042018d0:	73 25                	jae    80042018f7 <mon_showmappings+0x188>
	{
		cprintf("showmappings: upper_address must not be less than lower_address!\n");
  80042018d2:	48 bf 68 74 21 04 80 	movabs $0x8004217468,%rdi
  80042018d9:	00 00 00 
  80042018dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018e1:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042018e8:	00 00 00 
  80042018eb:	ff d2                	callq  *%rdx
		return 0;
  80042018ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018f2:	e9 44 01 00 00       	jmpq   8004201a3b <mon_showmappings+0x2cc>
	}


	//cprintf("suc!\n");
	pte_t *pte;
	cprintf("   Virtual Address\t  Physical Address\tPTE_P\tPTE_W\tPTE_U\n");
  80042018f7:	48 bf b0 74 21 04 80 	movabs $0x80042174b0,%rdi
  80042018fe:	00 00 00 
  8004201901:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201906:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420190d:	00 00 00 
  8004201910:	ff d2                	callq  *%rdx
	i=lower_addr;
  8004201912:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201916:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while(i<=upper_addr)
  800420191a:	e9 e7 00 00 00       	jmpq   8004201a06 <mon_showmappings+0x297>
	{
		//cprintf("boot_pml4e:%x\n",boot_pml4e);
		pte=pml4e_walk(boot_pml4e,(void *)i,0);
  800420191f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004201923:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420192a:	00 00 00 
  800420192d:	48 8b 00             	mov    (%rax),%rax
  8004201930:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201935:	48 89 ce             	mov    %rcx,%rsi
  8004201938:	48 89 c7             	mov    %rax,%rdi
  800420193b:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004201942:	00 00 00 
  8004201945:	ff d0                	callq  *%rax
  8004201947:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		cprintf("0x%016x\t",i);
  800420194b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420194f:	48 89 c6             	mov    %rax,%rsi
  8004201952:	48 bf e9 74 21 04 80 	movabs $0x80042174e9,%rdi
  8004201959:	00 00 00 
  800420195c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201961:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201968:	00 00 00 
  800420196b:	ff d2                	callq  *%rdx
		if (!pte) {
  800420196d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004201972:	75 1d                	jne    8004201991 <mon_showmappings+0x222>
			cprintf("address not mapped\n");
  8004201974:	48 bf f2 74 21 04 80 	movabs $0x80042174f2,%rdi
  800420197b:	00 00 00 
  800420197e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201983:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420198a:	00 00 00 
  800420198d:	ff d2                	callq  *%rdx
  800420198f:	eb 6d                	jmp    80042019fe <mon_showmappings+0x28f>
			
		}
		else
		cprintf("0x%016x\t%5d\t%5d\t%5d\n",PTE_ADDR(*pte),(*pte & PTE_P)?1:0,(*pte& PTE_W)?1:0,(*pte & PTE_U)?1:0);
  8004201991:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201995:	48 8b 00             	mov    (%rax),%rax
  8004201998:	83 e0 04             	and    $0x4,%eax
  800420199b:	48 85 c0             	test   %rax,%rax
  800420199e:	0f 95 c0             	setne  %al
  80042019a1:	0f b6 f8             	movzbl %al,%edi
  80042019a4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019a8:	48 8b 00             	mov    (%rax),%rax
  80042019ab:	83 e0 02             	and    $0x2,%eax
  80042019ae:	48 85 c0             	test   %rax,%rax
  80042019b1:	0f 95 c0             	setne  %al
  80042019b4:	0f b6 d0             	movzbl %al,%edx
  80042019b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042019bb:	48 8b 00             	mov    (%rax),%rax
  80042019be:	83 e0 01             	and    $0x1,%eax
  80042019c1:	48 85 c0             	test   %rax,%rax
  80042019c4:	0f 95 c0             	setne  %al
  80042019c7:	0f b6 c0             	movzbl %al,%eax
  80042019ca:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042019ce:	48 8b 09             	mov    (%rcx),%rcx
  80042019d1:	48 89 ce             	mov    %rcx,%rsi
  80042019d4:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
  80042019db:	41 89 f8             	mov    %edi,%r8d
  80042019de:	89 d1                	mov    %edx,%ecx
  80042019e0:	89 c2                	mov    %eax,%edx
  80042019e2:	48 bf 06 75 21 04 80 	movabs $0x8004217506,%rdi
  80042019e9:	00 00 00 
  80042019ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019f1:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  80042019f8:	00 00 00 
  80042019fb:	41 ff d1             	callq  *%r9

		i+=PGSIZE;
  80042019fe:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004201a05:	00 

	//cprintf("suc!\n");
	pte_t *pte;
	cprintf("   Virtual Address\t  Physical Address\tPTE_P\tPTE_W\tPTE_U\n");
	i=lower_addr;
	while(i<=upper_addr)
  8004201a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a0a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004201a0e:	0f 86 0b ff ff ff    	jbe    800420191f <mon_showmappings+0x1b0>
		cprintf("0x%016x\t%5d\t%5d\t%5d\n",PTE_ADDR(*pte),(*pte & PTE_P)?1:0,(*pte& PTE_W)?1:0,(*pte & PTE_U)?1:0);

		i+=PGSIZE;

	};
	return 0;
  8004201a14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a19:	eb 20                	jmp    8004201a3b <mon_showmappings+0x2cc>

	usage:
	  cprintf("usage: showmappings <lower_address(base 16)> <upper_address(base 16)>\n");
  8004201a1b:	48 bf 20 75 21 04 80 	movabs $0x8004217520,%rdi
  8004201a22:	00 00 00 
  8004201a25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a2a:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201a31:	00 00 00 
  8004201a34:	ff d2                	callq  *%rdx
	  return 0;
  8004201a36:	b8 00 00 00 00       	mov    $0x0,%eax
	
}
  8004201a3b:	c9                   	leaveq 
  8004201a3c:	c3                   	retq   

0000008004201a3d <mon_setpermission>:

int
mon_setpermission(int argc, char **argv, struct Trapframe *tf)
{
  8004201a3d:	55                   	push   %rbp
  8004201a3e:	48 89 e5             	mov    %rsp,%rbp
  8004201a41:	53                   	push   %rbx
  8004201a42:	48 83 ec 48          	sub    $0x48,%rsp
  8004201a46:	89 7d cc             	mov    %edi,-0x34(%rbp)
  8004201a49:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004201a4d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	if (argc!=5)
  8004201a51:	83 7d cc 05          	cmpl   $0x5,-0x34(%rbp)
  8004201a55:	74 05                	je     8004201a5c <mon_setpermission+0x1f>
		goto usage;
  8004201a57:	e9 17 03 00 00       	jmpq   8004201d73 <mon_setpermission+0x336>
	char *rest;
	uint64_t addr;
	int permission;

	//cprintf("1\n");
	addr=strtol(argv[1],&rest,16);
  8004201a5c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201a60:	48 83 c0 08          	add    $0x8,%rax
  8004201a64:	48 8b 00             	mov    (%rax),%rax
  8004201a67:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004201a6b:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201a70:	48 89 ce             	mov    %rcx,%rsi
  8004201a73:	48 89 c7             	mov    %rax,%rdi
  8004201a76:	48 b8 e3 f0 20 04 80 	movabs $0x800420f0e3,%rax
  8004201a7d:	00 00 00 
  8004201a80:	ff d0                	callq  *%rax
  8004201a82:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (strcmp(rest,"")!=0){
  8004201a86:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201a8a:	48 be 2c 74 21 04 80 	movabs $0x800421742c,%rsi
  8004201a91:	00 00 00 
  8004201a94:	48 89 c7             	mov    %rax,%rdi
  8004201a97:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201a9e:	00 00 00 
  8004201aa1:	ff d0                	callq  *%rax
  8004201aa3:	85 c0                	test   %eax,%eax
  8004201aa5:	74 05                	je     8004201aac <mon_setpermission+0x6f>
		goto usage;
  8004201aa7:	e9 c7 02 00 00       	jmpq   8004201d73 <mon_setpermission+0x336>
	}

	if (!(strcmp(argv[2],"0")==0 || strcmp(argv[2],"1")==0))
  8004201aac:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ab0:	48 83 c0 10          	add    $0x10,%rax
  8004201ab4:	48 8b 00             	mov    (%rax),%rax
  8004201ab7:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201abe:	00 00 00 
  8004201ac1:	48 89 c7             	mov    %rax,%rdi
  8004201ac4:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201acb:	00 00 00 
  8004201ace:	ff d0                	callq  *%rax
  8004201ad0:	85 c0                	test   %eax,%eax
  8004201ad2:	74 2d                	je     8004201b01 <mon_setpermission+0xc4>
  8004201ad4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ad8:	48 83 c0 10          	add    $0x10,%rax
  8004201adc:	48 8b 00             	mov    (%rax),%rax
  8004201adf:	48 be 69 75 21 04 80 	movabs $0x8004217569,%rsi
  8004201ae6:	00 00 00 
  8004201ae9:	48 89 c7             	mov    %rax,%rdi
  8004201aec:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201af3:	00 00 00 
  8004201af6:	ff d0                	callq  *%rax
  8004201af8:	85 c0                	test   %eax,%eax
  8004201afa:	74 05                	je     8004201b01 <mon_setpermission+0xc4>
		goto usage;
  8004201afc:	e9 72 02 00 00       	jmpq   8004201d73 <mon_setpermission+0x336>
	if (!(strcmp(argv[3],"0")==0 || strcmp(argv[3],"1")==0))
  8004201b01:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b05:	48 83 c0 18          	add    $0x18,%rax
  8004201b09:	48 8b 00             	mov    (%rax),%rax
  8004201b0c:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201b13:	00 00 00 
  8004201b16:	48 89 c7             	mov    %rax,%rdi
  8004201b19:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201b20:	00 00 00 
  8004201b23:	ff d0                	callq  *%rax
  8004201b25:	85 c0                	test   %eax,%eax
  8004201b27:	74 2d                	je     8004201b56 <mon_setpermission+0x119>
  8004201b29:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b2d:	48 83 c0 18          	add    $0x18,%rax
  8004201b31:	48 8b 00             	mov    (%rax),%rax
  8004201b34:	48 be 69 75 21 04 80 	movabs $0x8004217569,%rsi
  8004201b3b:	00 00 00 
  8004201b3e:	48 89 c7             	mov    %rax,%rdi
  8004201b41:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201b48:	00 00 00 
  8004201b4b:	ff d0                	callq  *%rax
  8004201b4d:	85 c0                	test   %eax,%eax
  8004201b4f:	74 05                	je     8004201b56 <mon_setpermission+0x119>
		goto usage;
  8004201b51:	e9 1d 02 00 00       	jmpq   8004201d73 <mon_setpermission+0x336>
	if (!(strcmp(argv[4],"0")==0 || strcmp(argv[4],"1")==0))
  8004201b56:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b5a:	48 83 c0 20          	add    $0x20,%rax
  8004201b5e:	48 8b 00             	mov    (%rax),%rax
  8004201b61:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201b68:	00 00 00 
  8004201b6b:	48 89 c7             	mov    %rax,%rdi
  8004201b6e:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201b75:	00 00 00 
  8004201b78:	ff d0                	callq  *%rax
  8004201b7a:	85 c0                	test   %eax,%eax
  8004201b7c:	74 2d                	je     8004201bab <mon_setpermission+0x16e>
  8004201b7e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201b82:	48 83 c0 20          	add    $0x20,%rax
  8004201b86:	48 8b 00             	mov    (%rax),%rax
  8004201b89:	48 be 69 75 21 04 80 	movabs $0x8004217569,%rsi
  8004201b90:	00 00 00 
  8004201b93:	48 89 c7             	mov    %rax,%rdi
  8004201b96:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201b9d:	00 00 00 
  8004201ba0:	ff d0                	callq  *%rax
  8004201ba2:	85 c0                	test   %eax,%eax
  8004201ba4:	74 05                	je     8004201bab <mon_setpermission+0x16e>
		goto usage;
  8004201ba6:	e9 c8 01 00 00       	jmpq   8004201d73 <mon_setpermission+0x336>

	

	pte_t* pte=pml4e_walk(boot_pml4e,(void *)addr,0);
  8004201bab:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004201baf:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004201bb6:	00 00 00 
  8004201bb9:	48 8b 00             	mov    (%rax),%rax
  8004201bbc:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201bc1:	48 89 ce             	mov    %rcx,%rsi
  8004201bc4:	48 89 c7             	mov    %rax,%rdi
  8004201bc7:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004201bce:	00 00 00 
  8004201bd1:	ff d0                	callq  *%rax
  8004201bd3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (!pte) {
  8004201bd7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004201bdc:	75 25                	jne    8004201c03 <mon_setpermission+0x1c6>
		cprintf("address not mapped\n");
  8004201bde:	48 bf f2 74 21 04 80 	movabs $0x80042174f2,%rdi
  8004201be5:	00 00 00 
  8004201be8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bed:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201bf4:	00 00 00 
  8004201bf7:	ff d2                	callq  *%rdx
		return 0;
  8004201bf9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bfe:	e9 90 01 00 00       	jmpq   8004201d93 <mon_setpermission+0x356>
	}
	pte_t tmp=*pte;
  8004201c03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201c07:	48 8b 00             	mov    (%rax),%rax
  8004201c0a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	//permission=(strcmp(argv[2],"0")==0?0:PTE_P)|(strcmp(argv[3],"0")==0?0:PTE_W)|(strcmp(argv[4],"0")==0?0:PTE_U)
	*pte= PTE_ADDR(*pte)|(strcmp(argv[2],"0")==0?0:PTE_P)|(strcmp(argv[3],"0")==0?0:PTE_W)|(strcmp(argv[4],"0")==0?0:PTE_U);
  8004201c0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201c12:	48 8b 00             	mov    (%rax),%rax
  8004201c15:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004201c1b:	48 89 c3             	mov    %rax,%rbx
  8004201c1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c22:	48 83 c0 10          	add    $0x10,%rax
  8004201c26:	48 8b 00             	mov    (%rax),%rax
  8004201c29:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201c30:	00 00 00 
  8004201c33:	48 89 c7             	mov    %rax,%rdi
  8004201c36:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201c3d:	00 00 00 
  8004201c40:	ff d0                	callq  *%rax
  8004201c42:	85 c0                	test   %eax,%eax
  8004201c44:	0f 95 c0             	setne  %al
  8004201c47:	0f b6 c0             	movzbl %al,%eax
  8004201c4a:	48 98                	cltq   
  8004201c4c:	48 09 c3             	or     %rax,%rbx
  8004201c4f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c53:	48 83 c0 18          	add    $0x18,%rax
  8004201c57:	48 8b 00             	mov    (%rax),%rax
  8004201c5a:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201c61:	00 00 00 
  8004201c64:	48 89 c7             	mov    %rax,%rdi
  8004201c67:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201c6e:	00 00 00 
  8004201c71:	ff d0                	callq  *%rax
  8004201c73:	85 c0                	test   %eax,%eax
  8004201c75:	75 07                	jne    8004201c7e <mon_setpermission+0x241>
  8004201c77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c7c:	eb 05                	jmp    8004201c83 <mon_setpermission+0x246>
  8004201c7e:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201c83:	48 09 c3             	or     %rax,%rbx
  8004201c86:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c8a:	48 83 c0 20          	add    $0x20,%rax
  8004201c8e:	48 8b 00             	mov    (%rax),%rax
  8004201c91:	48 be 67 75 21 04 80 	movabs $0x8004217567,%rsi
  8004201c98:	00 00 00 
  8004201c9b:	48 89 c7             	mov    %rax,%rdi
  8004201c9e:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201ca5:	00 00 00 
  8004201ca8:	ff d0                	callq  *%rax
  8004201caa:	85 c0                	test   %eax,%eax
  8004201cac:	75 07                	jne    8004201cb5 <mon_setpermission+0x278>
  8004201cae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cb3:	eb 05                	jmp    8004201cba <mon_setpermission+0x27d>
  8004201cb5:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201cba:	48 09 c3             	or     %rax,%rbx
  8004201cbd:	48 89 da             	mov    %rbx,%rdx
  8004201cc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201cc4:	48 89 10             	mov    %rdx,(%rax)
	cprintf("permission changed from %d %d %d ",(tmp & PTE_P)?1:0,(tmp& PTE_W)?1:0,(tmp & PTE_U)?1:0);
  8004201cc7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201ccb:	83 e0 04             	and    $0x4,%eax
  8004201cce:	48 85 c0             	test   %rax,%rax
  8004201cd1:	0f 95 c0             	setne  %al
  8004201cd4:	0f b6 c8             	movzbl %al,%ecx
  8004201cd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201cdb:	83 e0 02             	and    $0x2,%eax
  8004201cde:	48 85 c0             	test   %rax,%rax
  8004201ce1:	0f 95 c0             	setne  %al
  8004201ce4:	0f b6 d0             	movzbl %al,%edx
  8004201ce7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201ceb:	83 e0 01             	and    $0x1,%eax
  8004201cee:	48 85 c0             	test   %rax,%rax
  8004201cf1:	0f 95 c0             	setne  %al
  8004201cf4:	0f b6 c0             	movzbl %al,%eax
  8004201cf7:	89 c6                	mov    %eax,%esi
  8004201cf9:	48 bf 70 75 21 04 80 	movabs $0x8004217570,%rdi
  8004201d00:	00 00 00 
  8004201d03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d08:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004201d0f:	00 00 00 
  8004201d12:	41 ff d0             	callq  *%r8
	cprintf("to %d %d %d \n",(*pte & PTE_P)?1:0,(*pte& PTE_W)?1:0,(*pte & PTE_U)?1:0);
  8004201d15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201d19:	48 8b 00             	mov    (%rax),%rax
  8004201d1c:	83 e0 04             	and    $0x4,%eax
  8004201d1f:	48 85 c0             	test   %rax,%rax
  8004201d22:	0f 95 c0             	setne  %al
  8004201d25:	0f b6 c8             	movzbl %al,%ecx
  8004201d28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201d2c:	48 8b 00             	mov    (%rax),%rax
  8004201d2f:	83 e0 02             	and    $0x2,%eax
  8004201d32:	48 85 c0             	test   %rax,%rax
  8004201d35:	0f 95 c0             	setne  %al
  8004201d38:	0f b6 d0             	movzbl %al,%edx
  8004201d3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201d3f:	48 8b 00             	mov    (%rax),%rax
  8004201d42:	83 e0 01             	and    $0x1,%eax
  8004201d45:	48 85 c0             	test   %rax,%rax
  8004201d48:	0f 95 c0             	setne  %al
  8004201d4b:	0f b6 c0             	movzbl %al,%eax
  8004201d4e:	89 c6                	mov    %eax,%esi
  8004201d50:	48 bf 92 75 21 04 80 	movabs $0x8004217592,%rdi
  8004201d57:	00 00 00 
  8004201d5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d5f:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004201d66:	00 00 00 
  8004201d69:	41 ff d0             	callq  *%r8
	return 0;
  8004201d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d71:	eb 20                	jmp    8004201d93 <mon_setpermission+0x356>
	usage:
	  cprintf("usage: setpermission <address(base 16)> <PTE_P(0|1)> <PTE_U(0|1)> <PTE_W(0|1)>\n");
  8004201d73:	48 bf a0 75 21 04 80 	movabs $0x80042175a0,%rdi
  8004201d7a:	00 00 00 
  8004201d7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d82:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201d89:	00 00 00 
  8004201d8c:	ff d2                	callq  *%rdx
	  return 0;
  8004201d8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201d93:	48 83 c4 48          	add    $0x48,%rsp
  8004201d97:	5b                   	pop    %rbx
  8004201d98:	5d                   	pop    %rbp
  8004201d99:	c3                   	retq   

0000008004201d9a <mon_dump>:


int
mon_dump(int argc, char **argv, struct Trapframe *tf)
{
  8004201d9a:	55                   	push   %rbp
  8004201d9b:	48 89 e5             	mov    %rsp,%rbp
  8004201d9e:	48 83 ec 70          	sub    $0x70,%rsp
  8004201da2:	89 7d ac             	mov    %edi,-0x54(%rbp)
  8004201da5:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004201da9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
	if (argc!=4)
  8004201dad:	83 7d ac 04          	cmpl   $0x4,-0x54(%rbp)
  8004201db1:	74 05                	je     8004201db8 <mon_dump+0x1e>
		goto usage;
  8004201db3:	e9 72 03 00 00       	jmpq   800420212a <mon_dump+0x390>
	char *rest;
	uint64_t lower_addr,upper_addr,i;
	if (!(strcmp(argv[1],"p")==0 || strcmp(argv[1],"v")==0))
  8004201db8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201dbc:	48 83 c0 08          	add    $0x8,%rax
  8004201dc0:	48 8b 00             	mov    (%rax),%rax
  8004201dc3:	48 be f0 75 21 04 80 	movabs $0x80042175f0,%rsi
  8004201dca:	00 00 00 
  8004201dcd:	48 89 c7             	mov    %rax,%rdi
  8004201dd0:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201dd7:	00 00 00 
  8004201dda:	ff d0                	callq  *%rax
  8004201ddc:	85 c0                	test   %eax,%eax
  8004201dde:	74 2d                	je     8004201e0d <mon_dump+0x73>
  8004201de0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201de4:	48 83 c0 08          	add    $0x8,%rax
  8004201de8:	48 8b 00             	mov    (%rax),%rax
  8004201deb:	48 be f2 75 21 04 80 	movabs $0x80042175f2,%rsi
  8004201df2:	00 00 00 
  8004201df5:	48 89 c7             	mov    %rax,%rdi
  8004201df8:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201dff:	00 00 00 
  8004201e02:	ff d0                	callq  *%rax
  8004201e04:	85 c0                	test   %eax,%eax
  8004201e06:	74 05                	je     8004201e0d <mon_dump+0x73>
		goto usage;
  8004201e08:	e9 1d 03 00 00       	jmpq   800420212a <mon_dump+0x390>
	//cprintf("1\n");
	lower_addr=strtol(argv[2],&rest,16);
  8004201e0d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201e11:	48 83 c0 10          	add    $0x10,%rax
  8004201e15:	48 8b 00             	mov    (%rax),%rax
  8004201e18:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  8004201e1c:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201e21:	48 89 ce             	mov    %rcx,%rsi
  8004201e24:	48 89 c7             	mov    %rax,%rdi
  8004201e27:	48 b8 e3 f0 20 04 80 	movabs $0x800420f0e3,%rax
  8004201e2e:	00 00 00 
  8004201e31:	ff d0                	callq  *%rax
  8004201e33:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (strcmp(rest,"")!=0){
  8004201e37:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201e3b:	48 be 2c 74 21 04 80 	movabs $0x800421742c,%rsi
  8004201e42:	00 00 00 
  8004201e45:	48 89 c7             	mov    %rax,%rdi
  8004201e48:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201e4f:	00 00 00 
  8004201e52:	ff d0                	callq  *%rax
  8004201e54:	85 c0                	test   %eax,%eax
  8004201e56:	74 05                	je     8004201e5d <mon_dump+0xc3>
		goto usage;
  8004201e58:	e9 cd 02 00 00       	jmpq   800420212a <mon_dump+0x390>
	}
	upper_addr=strtol(argv[3],&rest,16);
  8004201e5d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201e61:	48 83 c0 18          	add    $0x18,%rax
  8004201e65:	48 8b 00             	mov    (%rax),%rax
  8004201e68:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
  8004201e6c:	ba 10 00 00 00       	mov    $0x10,%edx
  8004201e71:	48 89 ce             	mov    %rcx,%rsi
  8004201e74:	48 89 c7             	mov    %rax,%rdi
  8004201e77:	48 b8 e3 f0 20 04 80 	movabs $0x800420f0e3,%rax
  8004201e7e:	00 00 00 
  8004201e81:	ff d0                	callq  *%rax
  8004201e83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (strcmp(rest,"")!=0){
  8004201e87:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004201e8b:	48 be 2c 74 21 04 80 	movabs $0x800421742c,%rsi
  8004201e92:	00 00 00 
  8004201e95:	48 89 c7             	mov    %rax,%rdi
  8004201e98:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201e9f:	00 00 00 
  8004201ea2:	ff d0                	callq  *%rax
  8004201ea4:	85 c0                	test   %eax,%eax
  8004201ea6:	74 05                	je     8004201ead <mon_dump+0x113>
		goto usage;
  8004201ea8:	e9 7d 02 00 00       	jmpq   800420212a <mon_dump+0x390>
	}

	if (upper_addr<lower_addr)
  8004201ead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201eb1:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004201eb5:	73 25                	jae    8004201edc <mon_dump+0x142>
	{
		cprintf("dump: upper_address must not be less than lower_address!\n");
  8004201eb7:	48 bf f8 75 21 04 80 	movabs $0x80042175f8,%rdi
  8004201ebe:	00 00 00 
  8004201ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ec6:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201ecd:	00 00 00 
  8004201ed0:	ff d2                	callq  *%rdx
		return 0;
  8004201ed2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ed7:	e9 6e 02 00 00       	jmpq   800420214a <mon_dump+0x3b0>
	}
	if (strcmp(argv[1],"p")==0)
  8004201edc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201ee0:	48 83 c0 08          	add    $0x8,%rax
  8004201ee4:	48 8b 00             	mov    (%rax),%rax
  8004201ee7:	48 be f0 75 21 04 80 	movabs $0x80042175f0,%rsi
  8004201eee:	00 00 00 
  8004201ef1:	48 89 c7             	mov    %rax,%rdi
  8004201ef4:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201efb:	00 00 00 
  8004201efe:	ff d0                	callq  *%rax
  8004201f00:	85 c0                	test   %eax,%eax
  8004201f02:	75 5f                	jne    8004201f63 <mon_dump+0x1c9>
	{
		if (PPN(upper_addr) >= npages){
  8004201f04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201f08:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201f0c:	48 89 c2             	mov    %rax,%rdx
  8004201f0f:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004201f16:	00 00 00 
  8004201f19:	48 8b 00             	mov    (%rax),%rax
  8004201f1c:	48 39 c2             	cmp    %rax,%rdx
  8004201f1f:	72 25                	jb     8004201f46 <mon_dump+0x1ac>
			cprintf("dump: address must not be extend across page boundaries!\n");
  8004201f21:	48 bf 38 76 21 04 80 	movabs $0x8004217638,%rdi
  8004201f28:	00 00 00 
  8004201f2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f30:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201f37:	00 00 00 
  8004201f3a:	ff d2                	callq  *%rdx
			return 0;
  8004201f3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f41:	e9 04 02 00 00       	jmpq   800420214a <mon_dump+0x3b0>
		}
		cprintf("  Physical Address\tContent of Address\n");
  8004201f46:	48 bf 78 76 21 04 80 	movabs $0x8004217678,%rdi
  8004201f4d:	00 00 00 
  8004201f50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f55:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201f5c:	00 00 00 
  8004201f5f:	ff d2                	callq  *%rdx
  8004201f61:	eb 1b                	jmp    8004201f7e <mon_dump+0x1e4>
	}
	else
		cprintf("   Virtual Address\tContent of Address\n");
  8004201f63:	48 bf a0 76 21 04 80 	movabs $0x80042176a0,%rdi
  8004201f6a:	00 00 00 
  8004201f6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f72:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004201f79:	00 00 00 
  8004201f7c:	ff d2                	callq  *%rdx


	i=lower_addr;
  8004201f7e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201f82:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while(i<=upper_addr)
  8004201f86:	e9 8a 01 00 00       	jmpq   8004202115 <mon_dump+0x37b>
	{
		cprintf("0x%016x\t0x%016x\n",i,(strcmp(argv[1],"p")==0)?*((uint64_t*)KADDR(i)):*((uint64_t*)KADDR(PADDR(i))));
  8004201f8b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f8f:	48 83 c0 08          	add    $0x8,%rax
  8004201f93:	48 8b 00             	mov    (%rax),%rax
  8004201f96:	48 be f0 75 21 04 80 	movabs $0x80042175f0,%rsi
  8004201f9d:	00 00 00 
  8004201fa0:	48 89 c7             	mov    %rax,%rdi
  8004201fa3:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004201faa:	00 00 00 
  8004201fad:	ff d0                	callq  *%rax
  8004201faf:	85 c0                	test   %eax,%eax
  8004201fb1:	75 73                	jne    8004202026 <mon_dump+0x28c>
  8004201fb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201fb7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004201fbb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201fbf:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201fc3:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004201fc6:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004201fc9:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004201fd0:	00 00 00 
  8004201fd3:	48 8b 00             	mov    (%rax),%rax
  8004201fd6:	48 39 c2             	cmp    %rax,%rdx
  8004201fd9:	72 32                	jb     800420200d <mon_dump+0x273>
  8004201fdb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004201fdf:	48 89 c1             	mov    %rax,%rcx
  8004201fe2:	48 ba c8 76 21 04 80 	movabs $0x80042176c8,%rdx
  8004201fe9:	00 00 00 
  8004201fec:	be f0 00 00 00       	mov    $0xf0,%esi
  8004201ff1:	48 bf eb 76 21 04 80 	movabs $0x80042176eb,%rdi
  8004201ff8:	00 00 00 
  8004201ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202000:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004202007:	00 00 00 
  800420200a:	41 ff d0             	callq  *%r8
  800420200d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202014:	00 00 00 
  8004202017:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420201b:	48 01 d0             	add    %rdx,%rax
  800420201e:	48 8b 00             	mov    (%rax),%rax
  8004202021:	e9 c5 00 00 00       	jmpq   80042020eb <mon_dump+0x351>
  8004202026:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420202a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420202e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202035:	00 00 00 
  8004202038:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420203c:	77 32                	ja     8004202070 <mon_dump+0x2d6>
  800420203e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202042:	48 89 c1             	mov    %rax,%rcx
  8004202045:	48 ba 00 77 21 04 80 	movabs $0x8004217700,%rdx
  800420204c:	00 00 00 
  800420204f:	be f0 00 00 00       	mov    $0xf0,%esi
  8004202054:	48 bf eb 76 21 04 80 	movabs $0x80042176eb,%rdi
  800420205b:	00 00 00 
  800420205e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202063:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420206a:	00 00 00 
  800420206d:	41 ff d0             	callq  *%r8
  8004202070:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202077:	ff ff ff 
  800420207a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420207e:	48 01 d0             	add    %rdx,%rax
  8004202081:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004202085:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202089:	48 c1 e8 0c          	shr    $0xc,%rax
  800420208d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004202090:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004202093:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420209a:	00 00 00 
  800420209d:	48 8b 00             	mov    (%rax),%rax
  80042020a0:	48 39 c2             	cmp    %rax,%rdx
  80042020a3:	72 32                	jb     80042020d7 <mon_dump+0x33d>
  80042020a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020a9:	48 89 c1             	mov    %rax,%rcx
  80042020ac:	48 ba c8 76 21 04 80 	movabs $0x80042176c8,%rdx
  80042020b3:	00 00 00 
  80042020b6:	be f0 00 00 00       	mov    $0xf0,%esi
  80042020bb:	48 bf eb 76 21 04 80 	movabs $0x80042176eb,%rdi
  80042020c2:	00 00 00 
  80042020c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020ca:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042020d1:	00 00 00 
  80042020d4:	41 ff d0             	callq  *%r8
  80042020d7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042020de:	00 00 00 
  80042020e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020e5:	48 01 d0             	add    %rdx,%rax
  80042020e8:	48 8b 00             	mov    (%rax),%rax
  80042020eb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80042020ef:	48 89 c2             	mov    %rax,%rdx
  80042020f2:	48 89 ce             	mov    %rcx,%rsi
  80042020f5:	48 bf 24 77 21 04 80 	movabs $0x8004217724,%rdi
  80042020fc:	00 00 00 
  80042020ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202104:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800420210b:	00 00 00 
  800420210e:	ff d1                	callq  *%rcx
		i+=4;
  8004202110:	48 83 45 f8 04       	addq   $0x4,-0x8(%rbp)
		cprintf("   Virtual Address\tContent of Address\n");


	i=lower_addr;

	while(i<=upper_addr)
  8004202115:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202119:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420211d:	0f 86 68 fe ff ff    	jbe    8004201f8b <mon_dump+0x1f1>

	};



	return 0;
  8004202123:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202128:	eb 20                	jmp    800420214a <mon_dump+0x3b0>
	usage:
	  cprintf("usage: dump p|v <lower_address(base 16)> <upper_address(base 16)>\n");
  800420212a:	48 bf 38 77 21 04 80 	movabs $0x8004217738,%rdi
  8004202131:	00 00 00 
  8004202134:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202139:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202140:	00 00 00 
  8004202143:	ff d2                	callq  *%rdx
	  return 0;
  8004202145:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420214a:	c9                   	leaveq 
  800420214b:	c3                   	retq   

000000800420214c <mon_continue>:

int mon_continue(int argc, char **argv, struct Trapframe *tf)
{
  800420214c:	55                   	push   %rbp
  800420214d:	48 89 e5             	mov    %rsp,%rbp
  8004202150:	48 83 ec 20          	sub    $0x20,%rsp
  8004202154:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004202157:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420215b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    if (argc!=1) goto usage;
  800420215f:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004202163:	74 26                	je     800420218b <mon_continue+0x3f>
  8004202165:	90                   	nop
    }
    tf->tf_eflags=tf->tf_eflags & ~FL_TF;
    env_run(curenv);
    return 0;
    usage:
	  cprintf("usage: setpermission <address(base 16)> <PTE_P(0|1)> <PTE_U(0|1)> <PTE_W(0|1)>\n");
  8004202166:	48 bf a0 75 21 04 80 	movabs $0x80042175a0,%rdi
  800420216d:	00 00 00 
  8004202170:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202175:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420217c:	00 00 00 
  800420217f:	ff d2                	callq  *%rdx
	  return 0;
  8004202181:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202186:	e9 84 00 00 00       	jmpq   800420220f <mon_continue+0xc3>
}

int mon_continue(int argc, char **argv, struct Trapframe *tf)
{
    if (argc!=1) goto usage;
    if (!tf) {
  800420218b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202190:	75 22                	jne    80042021b4 <mon_continue+0x68>
        cprintf("continue: trapframe null\n");
  8004202192:	48 bf 7b 77 21 04 80 	movabs $0x800421777b,%rdi
  8004202199:	00 00 00 
  800420219c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021a1:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042021a8:	00 00 00 
  80042021ab:	ff d2                	callq  *%rdx
        return 0;
  80042021ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042021b2:	eb 5b                	jmp    800420220f <mon_continue+0xc3>
    }
    tf->tf_eflags=tf->tf_eflags & ~FL_TF;
  80042021b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042021b8:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80042021bf:	80 e4 fe             	and    $0xfe,%ah
  80042021c2:	48 89 c2             	mov    %rax,%rdx
  80042021c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042021c9:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
    env_run(curenv);
  80042021d0:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042021d7:	00 00 00 
  80042021da:	ff d0                	callq  *%rax
  80042021dc:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042021e3:	00 00 00 
  80042021e6:	48 98                	cltq   
  80042021e8:	48 c1 e0 03          	shl    $0x3,%rax
  80042021ec:	48 89 c1             	mov    %rax,%rcx
  80042021ef:	48 c1 e1 04          	shl    $0x4,%rcx
  80042021f3:	48 01 c8             	add    %rcx,%rax
  80042021f6:	48 01 d0             	add    %rdx,%rax
  80042021f9:	48 83 c0 08          	add    $0x8,%rax
  80042021fd:	48 8b 00             	mov    (%rax),%rax
  8004202200:	48 89 c7             	mov    %rax,%rdi
  8004202203:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  800420220a:	00 00 00 
  800420220d:	ff d0                	callq  *%rax
    return 0;
    usage:
	  cprintf("usage: setpermission <address(base 16)> <PTE_P(0|1)> <PTE_U(0|1)> <PTE_W(0|1)>\n");
	  return 0;
}
  800420220f:	c9                   	leaveq 
  8004202210:	c3                   	retq   

0000008004202211 <mon_si>:

int mon_si(int argc, char **argv, struct Trapframe *tf) {
  8004202211:	55                   	push   %rbp
  8004202212:	48 89 e5             	mov    %rsp,%rbp
  8004202215:	48 83 ec 20          	sub    $0x20,%rsp
  8004202219:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420221c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004202220:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
   if (argc!=1) goto usage;
  8004202224:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004202228:	74 26                	je     8004202250 <mon_si+0x3f>
  800420222a:	90                   	nop
    }
    tf->tf_eflags = tf->tf_eflags| FL_TF;
    env_run(curenv);
    return 0;
    usage:
	  cprintf("usage: si\n");
  800420222b:	48 bf a9 77 21 04 80 	movabs $0x80042177a9,%rdi
  8004202232:	00 00 00 
  8004202235:	b8 00 00 00 00       	mov    $0x0,%eax
  800420223a:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202241:	00 00 00 
  8004202244:	ff d2                	callq  *%rdx
	  return 0;
  8004202246:	b8 00 00 00 00       	mov    $0x0,%eax
  800420224b:	e9 84 00 00 00       	jmpq   80042022d4 <mon_si+0xc3>
	  return 0;
}

int mon_si(int argc, char **argv, struct Trapframe *tf) {
   if (argc!=1) goto usage;
    if (!tf) {
  8004202250:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202255:	75 22                	jne    8004202279 <mon_si+0x68>
        cprintf("si: trapframe null\n");
  8004202257:	48 bf 95 77 21 04 80 	movabs $0x8004217795,%rdi
  800420225e:	00 00 00 
  8004202261:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202266:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420226d:	00 00 00 
  8004202270:	ff d2                	callq  *%rdx
        return 0;
  8004202272:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202277:	eb 5b                	jmp    80042022d4 <mon_si+0xc3>
    }
    tf->tf_eflags = tf->tf_eflags| FL_TF;
  8004202279:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420227d:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004202284:	80 cc 01             	or     $0x1,%ah
  8004202287:	48 89 c2             	mov    %rax,%rdx
  800420228a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420228e:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
    env_run(curenv);
  8004202295:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420229c:	00 00 00 
  800420229f:	ff d0                	callq  *%rax
  80042022a1:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042022a8:	00 00 00 
  80042022ab:	48 98                	cltq   
  80042022ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042022b1:	48 89 c1             	mov    %rax,%rcx
  80042022b4:	48 c1 e1 04          	shl    $0x4,%rcx
  80042022b8:	48 01 c8             	add    %rcx,%rax
  80042022bb:	48 01 d0             	add    %rdx,%rax
  80042022be:	48 83 c0 08          	add    $0x8,%rax
  80042022c2:	48 8b 00             	mov    (%rax),%rax
  80042022c5:	48 89 c7             	mov    %rax,%rdi
  80042022c8:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  80042022cf:	00 00 00 
  80042022d2:	ff d0                	callq  *%rax
    return 0;
    usage:
	  cprintf("usage: si\n");
	  return 0;
}
  80042022d4:	c9                   	leaveq 
  80042022d5:	c3                   	retq   

00000080042022d6 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  80042022d6:	55                   	push   %rbp
  80042022d7:	48 89 e5             	mov    %rsp,%rbp
  80042022da:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042022e1:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042022e8:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042022ef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042022f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042022f9:	48 98                	cltq   
  80042022fb:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004202302:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004202307:	eb 15                	jmp    800420231e <runcmd+0x48>
			*buf++ = 0;
  8004202309:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202310:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004202314:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  800420231b:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420231e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202325:	0f b6 00             	movzbl (%rax),%eax
  8004202328:	84 c0                	test   %al,%al
  800420232a:	74 2a                	je     8004202356 <runcmd+0x80>
  800420232c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004202333:	0f b6 00             	movzbl (%rax),%eax
  8004202336:	0f be c0             	movsbl %al,%eax
  8004202339:	89 c6                	mov    %eax,%esi
  800420233b:	48 bf b4 77 21 04 80 	movabs $0x80042177b4,%rdi
  8004202342:	00 00 00 
  8004202345:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  800420234c:	00 00 00 
  800420234f:	ff d0                	callq  *%rax
  8004202351:	48 85 c0             	test   %rax,%rax
  8004202354:	75 b3                	jne    8004202309 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  8004202356:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420235d:	0f b6 00             	movzbl (%rax),%eax
  8004202360:	84 c0                	test   %al,%al
  8004202362:	75 21                	jne    8004202385 <runcmd+0xaf>
			break;
  8004202364:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004202365:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202368:	48 98                	cltq   
  800420236a:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004202371:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004202376:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420237a:	0f 85 a1 00 00 00    	jne    8004202421 <runcmd+0x14b>
  8004202380:	e9 92 00 00 00       	jmpq   8004202417 <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004202385:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004202389:	75 2a                	jne    80042023b5 <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  800420238b:	be 10 00 00 00       	mov    $0x10,%esi
  8004202390:	48 bf b9 77 21 04 80 	movabs $0x80042177b9,%rdi
  8004202397:	00 00 00 
  800420239a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420239f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042023a6:	00 00 00 
  80042023a9:	ff d2                	callq  *%rdx
			return 0;
  80042023ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023b0:	e9 30 01 00 00       	jmpq   80042024e5 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  80042023b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042023b8:	8d 50 01             	lea    0x1(%rax),%edx
  80042023bb:	89 55 fc             	mov    %edx,-0x4(%rbp)
  80042023be:	48 98                	cltq   
  80042023c0:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  80042023c7:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  80042023ce:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  80042023cf:	eb 08                	jmp    80042023d9 <runcmd+0x103>
			buf++;
  80042023d1:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  80042023d8:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  80042023d9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042023e0:	0f b6 00             	movzbl (%rax),%eax
  80042023e3:	84 c0                	test   %al,%al
  80042023e5:	74 2a                	je     8004202411 <runcmd+0x13b>
  80042023e7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042023ee:	0f b6 00             	movzbl (%rax),%eax
  80042023f1:	0f be c0             	movsbl %al,%eax
  80042023f4:	89 c6                	mov    %eax,%esi
  80042023f6:	48 bf b4 77 21 04 80 	movabs $0x80042177b4,%rdi
  80042023fd:	00 00 00 
  8004202400:	48 b8 dd ed 20 04 80 	movabs $0x800420eddd,%rax
  8004202407:	00 00 00 
  800420240a:	ff d0                	callq  *%rax
  800420240c:	48 85 c0             	test   %rax,%rax
  800420240f:	74 c0                	je     80042023d1 <runcmd+0xfb>
			buf++;
	}
  8004202411:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004202412:	e9 07 ff ff ff       	jmpq   800420231e <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004202417:	b8 00 00 00 00       	mov    $0x0,%eax
  800420241c:	e9 c4 00 00 00       	jmpq   80042024e5 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004202421:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004202428:	e9 82 00 00 00       	jmpq   80042024af <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  800420242d:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004202434:	00 00 00 
  8004202437:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420243a:	48 63 d0             	movslq %eax,%rdx
  800420243d:	48 89 d0             	mov    %rdx,%rax
  8004202440:	48 01 c0             	add    %rax,%rax
  8004202443:	48 01 d0             	add    %rdx,%rax
  8004202446:	48 c1 e0 03          	shl    $0x3,%rax
  800420244a:	48 01 c8             	add    %rcx,%rax
  800420244d:	48 8b 10             	mov    (%rax),%rdx
  8004202450:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202457:	48 89 d6             	mov    %rdx,%rsi
  800420245a:	48 89 c7             	mov    %rax,%rdi
  800420245d:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004202464:	00 00 00 
  8004202467:	ff d0                	callq  *%rax
  8004202469:	85 c0                	test   %eax,%eax
  800420246b:	75 3e                	jne    80042024ab <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  800420246d:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004202474:	00 00 00 
  8004202477:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420247a:	48 63 d0             	movslq %eax,%rdx
  800420247d:	48 89 d0             	mov    %rdx,%rax
  8004202480:	48 01 c0             	add    %rax,%rax
  8004202483:	48 01 d0             	add    %rdx,%rax
  8004202486:	48 c1 e0 03          	shl    $0x3,%rax
  800420248a:	48 01 c8             	add    %rcx,%rax
  800420248d:	48 83 c0 10          	add    $0x10,%rax
  8004202491:	48 8b 00             	mov    (%rax),%rax
  8004202494:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420249b:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  80042024a2:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042024a5:	89 cf                	mov    %ecx,%edi
  80042024a7:	ff d0                	callq  *%rax
  80042024a9:	eb 3a                	jmp    80042024e5 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  80042024ab:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  80042024af:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042024b2:	83 f8 07             	cmp    $0x7,%eax
  80042024b5:	0f 86 72 ff ff ff    	jbe    800420242d <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  80042024bb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042024c2:	48 89 c6             	mov    %rax,%rsi
  80042024c5:	48 bf d6 77 21 04 80 	movabs $0x80042177d6,%rdi
  80042024cc:	00 00 00 
  80042024cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042024d4:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042024db:	00 00 00 
  80042024de:	ff d2                	callq  *%rdx
	return 0;
  80042024e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042024e5:	c9                   	leaveq 
  80042024e6:	c3                   	retq   

00000080042024e7 <monitor>:

void
monitor(struct Trapframe *tf)
{
  80042024e7:	55                   	push   %rbp
  80042024e8:	48 89 e5             	mov    %rsp,%rbp
  80042024eb:	48 83 ec 20          	sub    $0x20,%rsp
  80042024ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  80042024f3:	48 bf f0 77 21 04 80 	movabs $0x80042177f0,%rdi
  80042024fa:	00 00 00 
  80042024fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202502:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202509:	00 00 00 
  800420250c:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  800420250e:	48 bf 18 78 21 04 80 	movabs $0x8004217818,%rdi
  8004202515:	00 00 00 
  8004202518:	b8 00 00 00 00       	mov    $0x0,%eax
  800420251d:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202524:	00 00 00 
  8004202527:	ff d2                	callq  *%rdx


	if (tf != NULL)
  8004202529:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420252e:	74 13                	je     8004202543 <monitor+0x5c>
		print_trapframe(tf);
  8004202530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202534:	48 89 c7             	mov    %rax,%rdi
  8004202537:	48 b8 41 b2 20 04 80 	movabs $0x800420b241,%rax
  800420253e:	00 00 00 
  8004202541:	ff d0                	callq  *%rax

	cprintf("%C%s\n", BLUE, "BLUE");
  8004202543:	48 ba 3d 78 21 04 80 	movabs $0x800421783d,%rdx
  800420254a:	00 00 00 
  800420254d:	be 01 00 00 00       	mov    $0x1,%esi
  8004202552:	48 bf 42 78 21 04 80 	movabs $0x8004217842,%rdi
  8004202559:	00 00 00 
  800420255c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202561:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004202568:	00 00 00 
  800420256b:	ff d1                	callq  *%rcx
	cprintf("%C%s\n", GREEN, "GREEN");
  800420256d:	48 ba 48 78 21 04 80 	movabs $0x8004217848,%rdx
  8004202574:	00 00 00 
  8004202577:	be 02 00 00 00       	mov    $0x2,%esi
  800420257c:	48 bf 42 78 21 04 80 	movabs $0x8004217842,%rdi
  8004202583:	00 00 00 
  8004202586:	b8 00 00 00 00       	mov    $0x0,%eax
  800420258b:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004202592:	00 00 00 
  8004202595:	ff d1                	callq  *%rcx
	cprintf("%C%s\n", YELLOW, "YELLOW");
  8004202597:	48 ba 4e 78 21 04 80 	movabs $0x800421784e,%rdx
  800420259e:	00 00 00 
  80042025a1:	be 0e 00 00 00       	mov    $0xe,%esi
  80042025a6:	48 bf 42 78 21 04 80 	movabs $0x8004217842,%rdi
  80042025ad:	00 00 00 
  80042025b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025b5:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  80042025bc:	00 00 00 
  80042025bf:	ff d1                	callq  *%rcx
	cprintf("%C%s\n", RED, "RED");
  80042025c1:	48 ba 55 78 21 04 80 	movabs $0x8004217855,%rdx
  80042025c8:	00 00 00 
  80042025cb:	be 04 00 00 00       	mov    $0x4,%esi
  80042025d0:	48 bf 42 78 21 04 80 	movabs $0x8004217842,%rdi
  80042025d7:	00 00 00 
  80042025da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025df:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  80042025e6:	00 00 00 
  80042025e9:	ff d1                	callq  *%rcx
	cprintf("%C%s\n", BWHITE, "BRIGHT WHITE");
  80042025eb:	48 ba 59 78 21 04 80 	movabs $0x8004217859,%rdx
  80042025f2:	00 00 00 
  80042025f5:	be 0f 00 00 00       	mov    $0xf,%esi
  80042025fa:	48 bf 42 78 21 04 80 	movabs $0x8004217842,%rdi
  8004202601:	00 00 00 
  8004202604:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202609:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004202610:	00 00 00 
  8004202613:	ff d1                	callq  *%rcx
	cprintf("upages %x  kstacktop %x  kernbase %x\n",UPAGES,KSTACKTOP,KERNBASE);
  8004202615:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  800420261c:	00 00 00 
  800420261f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202626:	00 00 00 
  8004202629:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202630:	00 00 00 
  8004202633:	48 bf 68 78 21 04 80 	movabs $0x8004217868,%rdi
  800420263a:	00 00 00 
  800420263d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202642:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004202649:	00 00 00 
  800420264c:	41 ff d0             	callq  *%r8
	
	if (tf != NULL)
  800420264f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202654:	74 13                	je     8004202669 <monitor+0x182>
		print_trapframe(tf);
  8004202656:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420265a:	48 89 c7             	mov    %rax,%rdi
  800420265d:	48 b8 41 b2 20 04 80 	movabs $0x800420b241,%rax
  8004202664:	00 00 00 
  8004202667:	ff d0                	callq  *%rax
	

	while (1) {
		buf = readline("K> ");
  8004202669:	48 bf 8e 78 21 04 80 	movabs $0x800421788e,%rdi
  8004202670:	00 00 00 
  8004202673:	48 b8 f6 e9 20 04 80 	movabs $0x800420e9f6,%rax
  800420267a:	00 00 00 
  800420267d:	ff d0                	callq  *%rax
  800420267f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004202683:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202688:	74 20                	je     80042026aa <monitor+0x1c3>
			if (runcmd(buf, tf) < 0)
  800420268a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420268e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202692:	48 89 d6             	mov    %rdx,%rsi
  8004202695:	48 89 c7             	mov    %rax,%rdi
  8004202698:	48 b8 d6 22 20 04 80 	movabs $0x80042022d6,%rax
  800420269f:	00 00 00 
  80042026a2:	ff d0                	callq  *%rax
  80042026a4:	85 c0                	test   %eax,%eax
  80042026a6:	79 02                	jns    80042026aa <monitor+0x1c3>
				break;
  80042026a8:	eb 02                	jmp    80042026ac <monitor+0x1c5>
		}
  80042026aa:	eb bd                	jmp    8004202669 <monitor+0x182>
	}
  80042026ac:	c9                   	leaveq 
  80042026ad:	c3                   	retq   

00000080042026ae <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042026ae:	55                   	push   %rbp
  80042026af:	48 89 e5             	mov    %rsp,%rbp
  80042026b2:	48 83 ec 08          	sub    $0x8,%rsp
  80042026b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042026ba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042026be:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042026c5:	00 00 00 
  80042026c8:	48 8b 00             	mov    (%rax),%rax
  80042026cb:	48 29 c2             	sub    %rax,%rdx
  80042026ce:	48 89 d0             	mov    %rdx,%rax
  80042026d1:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042026d5:	c9                   	leaveq 
  80042026d6:	c3                   	retq   

00000080042026d7 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042026d7:	55                   	push   %rbp
  80042026d8:	48 89 e5             	mov    %rsp,%rbp
  80042026db:	48 83 ec 08          	sub    $0x8,%rsp
  80042026df:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042026e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042026e7:	48 89 c7             	mov    %rax,%rdi
  80042026ea:	48 b8 ae 26 20 04 80 	movabs $0x80042026ae,%rax
  80042026f1:	00 00 00 
  80042026f4:	ff d0                	callq  *%rax
  80042026f6:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042026fa:	c9                   	leaveq 
  80042026fb:	c3                   	retq   

00000080042026fc <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042026fc:	55                   	push   %rbp
  80042026fd:	48 89 e5             	mov    %rsp,%rbp
  8004202700:	48 83 ec 10          	sub    $0x10,%rsp
  8004202704:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004202708:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420270c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202710:	48 89 c2             	mov    %rax,%rdx
  8004202713:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420271a:	00 00 00 
  800420271d:	48 8b 00             	mov    (%rax),%rax
  8004202720:	48 39 c2             	cmp    %rax,%rdx
  8004202723:	72 2a                	jb     800420274f <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004202725:	48 ba 98 78 21 04 80 	movabs $0x8004217898,%rdx
  800420272c:	00 00 00 
  800420272f:	be 54 00 00 00       	mov    $0x54,%esi
  8004202734:	48 bf b7 78 21 04 80 	movabs $0x80042178b7,%rdi
  800420273b:	00 00 00 
  800420273e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202743:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420274a:	00 00 00 
  800420274d:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420274f:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004202756:	00 00 00 
  8004202759:	48 8b 00             	mov    (%rax),%rax
  800420275c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202760:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004202764:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202768:	48 01 d0             	add    %rdx,%rax
}
  800420276b:	c9                   	leaveq 
  800420276c:	c3                   	retq   

000000800420276d <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420276d:	55                   	push   %rbp
  800420276e:	48 89 e5             	mov    %rsp,%rbp
  8004202771:	48 83 ec 20          	sub    $0x20,%rsp
  8004202775:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004202779:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420277d:	48 89 c7             	mov    %rax,%rdi
  8004202780:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004202787:	00 00 00 
  800420278a:	ff d0                	callq  *%rax
  800420278c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004202790:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202794:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202798:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420279b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420279e:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042027a5:	00 00 00 
  80042027a8:	48 8b 00             	mov    (%rax),%rax
  80042027ab:	48 39 c2             	cmp    %rax,%rdx
  80042027ae:	72 32                	jb     80042027e2 <page2kva+0x75>
  80042027b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042027b4:	48 89 c1             	mov    %rax,%rcx
  80042027b7:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  80042027be:	00 00 00 
  80042027c1:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042027c6:	48 bf b7 78 21 04 80 	movabs $0x80042178b7,%rdi
  80042027cd:	00 00 00 
  80042027d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027d5:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042027dc:	00 00 00 
  80042027df:	41 ff d0             	callq  *%r8
  80042027e2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042027e9:	00 00 00 
  80042027ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042027f0:	48 01 d0             	add    %rdx,%rax
}
  80042027f3:	c9                   	leaveq 
  80042027f4:	c3                   	retq   

00000080042027f5 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  80042027f5:	55                   	push   %rbp
  80042027f6:	48 89 e5             	mov    %rsp,%rbp
  80042027f9:	48 83 ec 08          	sub    $0x8,%rsp
  80042027fd:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004202800:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004202803:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004202807:	74 06                	je     800420280f <restrictive_type+0x1a>
  8004202809:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  800420280d:	75 07                	jne    8004202816 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  800420280f:	b8 05 00 00 00       	mov    $0x5,%eax
  8004202814:	eb 3e                	jmp    8004202854 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004202816:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  800420281a:	74 06                	je     8004202822 <restrictive_type+0x2d>
  800420281c:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004202820:	75 07                	jne    8004202829 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004202822:	b8 04 00 00 00       	mov    $0x4,%eax
  8004202827:	eb 2b                	jmp    8004202854 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004202829:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  800420282d:	74 06                	je     8004202835 <restrictive_type+0x40>
  800420282f:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004202833:	75 07                	jne    800420283c <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004202835:	b8 02 00 00 00       	mov    $0x2,%eax
  800420283a:	eb 18                	jmp    8004202854 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  800420283c:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202840:	74 06                	je     8004202848 <restrictive_type+0x53>
  8004202842:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004202846:	75 07                	jne    800420284f <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004202848:	b8 03 00 00 00       	mov    $0x3,%eax
  800420284d:	eb 05                	jmp    8004202854 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  800420284f:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004202854:	c9                   	leaveq 
  8004202855:	c3                   	retq   

0000008004202856 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004202856:	55                   	push   %rbp
  8004202857:	48 89 e5             	mov    %rsp,%rbp
  800420285a:	53                   	push   %rbx
  800420285b:	48 83 ec 18          	sub    $0x18,%rsp
  800420285f:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004202862:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202865:	89 c7                	mov    %eax,%edi
  8004202867:	48 b8 03 94 20 04 80 	movabs $0x8004209403,%rax
  800420286e:	00 00 00 
  8004202871:	ff d0                	callq  *%rax
  8004202873:	89 c3                	mov    %eax,%ebx
  8004202875:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202878:	83 c0 01             	add    $0x1,%eax
  800420287b:	89 c7                	mov    %eax,%edi
  800420287d:	48 b8 03 94 20 04 80 	movabs $0x8004209403,%rax
  8004202884:	00 00 00 
  8004202887:	ff d0                	callq  *%rax
  8004202889:	c1 e0 08             	shl    $0x8,%eax
  800420288c:	09 d8                	or     %ebx,%eax
}
  800420288e:	48 83 c4 18          	add    $0x18,%rsp
  8004202892:	5b                   	pop    %rbx
  8004202893:	5d                   	pop    %rbp
  8004202894:	c3                   	retq   

0000008004202895 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004202895:	55                   	push   %rbp
  8004202896:	48 89 e5             	mov    %rsp,%rbp
  8004202899:	41 54                	push   %r12
  800420289b:	53                   	push   %rbx
  800420289c:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042028a3:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  80042028aa:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  80042028b1:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  80042028b8:	48 89 e0             	mov    %rsp,%rax
  80042028bb:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  80042028be:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042028c5:	8b 40 30             	mov    0x30(%rax),%eax
  80042028c8:	89 c0                	mov    %eax,%eax
  80042028ca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  80042028ce:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042028d5:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042028d8:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042028dd:	f7 e2                	mul    %edx
  80042028df:	89 d0                	mov    %edx,%eax
  80042028e1:	c1 e8 04             	shr    $0x4,%eax
  80042028e4:	89 c0                	mov    %eax,%eax
  80042028e6:	48 89 c2             	mov    %rax,%rdx
  80042028e9:	48 83 ea 01          	sub    $0x1,%rdx
  80042028ed:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042028f1:	49 89 c0             	mov    %rax,%r8
  80042028f4:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042028fa:	48 89 c1             	mov    %rax,%rcx
  80042028fd:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004202902:	48 c1 e0 03          	shl    $0x3,%rax
  8004202906:	48 8d 50 07          	lea    0x7(%rax),%rdx
  800420290a:	b8 10 00 00 00       	mov    $0x10,%eax
  800420290f:	48 83 e8 01          	sub    $0x1,%rax
  8004202913:	48 01 d0             	add    %rdx,%rax
  8004202916:	bb 10 00 00 00       	mov    $0x10,%ebx
  800420291b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202920:	48 f7 f3             	div    %rbx
  8004202923:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004202927:	48 29 c4             	sub    %rax,%rsp
  800420292a:	48 89 e0             	mov    %rsp,%rax
  800420292d:	48 83 c0 07          	add    $0x7,%rax
  8004202931:	48 c1 e8 03          	shr    $0x3,%rax
  8004202935:	48 c1 e0 03          	shl    $0x3,%rax
  8004202939:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  800420293d:	48 bf eb 78 21 04 80 	movabs $0x80042178eb,%rdi
  8004202944:	00 00 00 
  8004202947:	b8 00 00 00 00       	mov    $0x0,%eax
  800420294c:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202953:	00 00 00 
  8004202956:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202958:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420295f:	e9 6c 01 00 00       	jmpq   8004202ad0 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004202964:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202967:	48 63 d0             	movslq %eax,%rdx
  800420296a:	48 89 d0             	mov    %rdx,%rax
  800420296d:	48 01 c0             	add    %rax,%rax
  8004202970:	48 01 d0             	add    %rdx,%rax
  8004202973:	48 c1 e0 03          	shl    $0x3,%rax
  8004202977:	48 89 c2             	mov    %rax,%rdx
  800420297a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420297e:	48 01 d0             	add    %rdx,%rax
  8004202981:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004202985:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202989:	8b 40 08             	mov    0x8(%rax),%eax
  800420298c:	89 c0                	mov    %eax,%eax
  800420298e:	48 c1 e0 20          	shl    $0x20,%rax
  8004202992:	48 89 c2             	mov    %rax,%rdx
  8004202995:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202999:	8b 40 04             	mov    0x4(%rax),%eax
  800420299c:	89 c0                	mov    %eax,%eax
  800420299e:	48 01 d0             	add    %rdx,%rax
  80042029a1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  80042029a5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029a9:	8b 40 10             	mov    0x10(%rax),%eax
  80042029ac:	89 c0                	mov    %eax,%eax
  80042029ae:	48 c1 e0 20          	shl    $0x20,%rax
  80042029b2:	48 89 c2             	mov    %rax,%rdx
  80042029b5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029b9:	8b 40 0c             	mov    0xc(%rax),%eax
  80042029bc:	89 c0                	mov    %eax,%eax
  80042029be:	48 01 d0             	add    %rdx,%rax
  80042029c1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  80042029c5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029c9:	8b 70 14             	mov    0x14(%rax),%esi
  80042029cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029d0:	8b 00                	mov    (%rax),%eax
  80042029d2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042029d6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042029da:	41 89 f0             	mov    %esi,%r8d
  80042029dd:	89 c6                	mov    %eax,%esi
  80042029df:	48 bf 00 79 21 04 80 	movabs $0x8004217900,%rdi
  80042029e6:	00 00 00 
  80042029e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029ee:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  80042029f5:	00 00 00 
  80042029f8:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  80042029fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042029ff:	8b 40 14             	mov    0x14(%rax),%eax
  8004202a02:	83 f8 05             	cmp    $0x5,%eax
  8004202a05:	77 0b                	ja     8004202a12 <multiboot_read+0x17d>
  8004202a07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a0b:	8b 40 14             	mov    0x14(%rax),%eax
  8004202a0e:	85 c0                	test   %eax,%eax
  8004202a10:	75 0b                	jne    8004202a1d <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004202a12:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a16:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004202a1d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004202a24:	e9 85 00 00 00       	jmpq   8004202aae <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004202a29:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a2d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202a30:	48 63 d2             	movslq %edx,%rdx
  8004202a33:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202a37:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202a3b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a3f:	8b 40 08             	mov    0x8(%rax),%eax
  8004202a42:	89 c0                	mov    %eax,%eax
  8004202a44:	48 c1 e0 20          	shl    $0x20,%rax
  8004202a48:	48 89 c2             	mov    %rax,%rdx
  8004202a4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202a4f:	8b 40 04             	mov    0x4(%rax),%eax
  8004202a52:	89 c0                	mov    %eax,%eax
  8004202a54:	48 01 d0             	add    %rdx,%rax
  8004202a57:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004202a5b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202a5f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004202a63:	76 45                	jbe    8004202aaa <multiboot_read+0x215>
				int last = i+1;
  8004202a65:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202a68:	83 c0 01             	add    $0x1,%eax
  8004202a6b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004202a6e:	eb 30                	jmp    8004202aa0 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004202a70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a74:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004202a77:	48 63 d2             	movslq %edx,%rdx
  8004202a7a:	48 c1 e2 03          	shl    $0x3,%rdx
  8004202a7e:	48 01 c2             	add    %rax,%rdx
  8004202a81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a85:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004202a88:	48 63 c9             	movslq %ecx,%rcx
  8004202a8b:	48 c1 e1 03          	shl    $0x3,%rcx
  8004202a8f:	48 83 e9 08          	sub    $0x8,%rcx
  8004202a93:	48 01 c8             	add    %rcx,%rax
  8004202a96:	48 8b 00             	mov    (%rax),%rax
  8004202a99:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004202a9c:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004202aa0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004202aa3:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004202aa6:	75 c8                	jne    8004202a70 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004202aa8:	eb 10                	jmp    8004202aba <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;

		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004202aaa:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004202aae:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004202ab1:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004202ab4:	0f 8c 6f ff ff ff    	jl     8004202a29 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004202aba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202abe:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202ac1:	48 63 d2             	movslq %edx,%rdx
  8004202ac4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202ac8:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;

	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202acc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202ad0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202ad3:	48 63 c8             	movslq %eax,%rcx
  8004202ad6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202add:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202ae0:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202ae5:	f7 e2                	mul    %edx
  8004202ae7:	89 d0                	mov    %edx,%eax
  8004202ae9:	c1 e8 04             	shr    $0x4,%eax
  8004202aec:	89 c0                	mov    %eax,%eax
  8004202aee:	48 39 c1             	cmp    %rax,%rcx
  8004202af1:	0f 82 6d fe ff ff    	jb     8004202964 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004202af7:	48 bf 37 79 21 04 80 	movabs $0x8004217937,%rdi
  8004202afe:	00 00 00 
  8004202b01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b06:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202b0d:	00 00 00 
  8004202b10:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202b12:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004202b19:	e9 93 01 00 00       	jmpq   8004202cb1 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  8004202b1e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202b21:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202b24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202b28:	48 63 d2             	movslq %edx,%rdx
  8004202b2b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202b2f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202b33:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202b37:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202b3a:	48 63 d2             	movslq %edx,%rdx
  8004202b3d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202b41:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202b45:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202b49:	8b 40 08             	mov    0x8(%rax),%eax
  8004202b4c:	89 c0                	mov    %eax,%eax
  8004202b4e:	48 c1 e0 20          	shl    $0x20,%rax
  8004202b52:	48 89 c2             	mov    %rax,%rdx
  8004202b55:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202b59:	8b 40 04             	mov    0x4(%rax),%eax
  8004202b5c:	89 c0                	mov    %eax,%eax
  8004202b5e:	48 01 d0             	add    %rdx,%rax
  8004202b61:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004202b65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202b69:	8b 40 08             	mov    0x8(%rax),%eax
  8004202b6c:	89 c0                	mov    %eax,%eax
  8004202b6e:	48 c1 e0 20          	shl    $0x20,%rax
  8004202b72:	48 89 c2             	mov    %rax,%rdx
  8004202b75:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202b79:	8b 40 04             	mov    0x4(%rax),%eax
  8004202b7c:	89 c0                	mov    %eax,%eax
  8004202b7e:	48 01 d0             	add    %rdx,%rax
  8004202b81:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004202b85:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202b89:	8b 40 10             	mov    0x10(%rax),%eax
  8004202b8c:	89 c0                	mov    %eax,%eax
  8004202b8e:	48 c1 e0 20          	shl    $0x20,%rax
  8004202b92:	48 89 c2             	mov    %rax,%rdx
  8004202b95:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202b99:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202b9c:	89 c0                	mov    %eax,%eax
  8004202b9e:	48 01 d0             	add    %rdx,%rax
  8004202ba1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004202ba8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202bac:	8b 40 10             	mov    0x10(%rax),%eax
  8004202baf:	89 c0                	mov    %eax,%eax
  8004202bb1:	48 c1 e0 20          	shl    $0x20,%rax
  8004202bb5:	48 89 c2             	mov    %rax,%rdx
  8004202bb8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202bbc:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202bbf:	89 c0                	mov    %eax,%eax
  8004202bc1:	48 01 d0             	add    %rdx,%rax
  8004202bc4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004202bcb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202bd2:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202bd6:	48 01 d0             	add    %rdx,%rax
  8004202bd9:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202bdd:	75 7c                	jne    8004202c5b <multiboot_read+0x3c6>
  8004202bdf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202be3:	8b 50 14             	mov    0x14(%rax),%edx
  8004202be6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202bea:	8b 40 14             	mov    0x14(%rax),%eax
  8004202bed:	39 c2                	cmp    %eax,%edx
  8004202bef:	75 6a                	jne    8004202c5b <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202bf1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202bf8:	89 c2                	mov    %eax,%edx
  8004202bfa:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202c01:	01 c2                	add    %eax,%edx
  8004202c03:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202c07:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004202c0a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202c11:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202c18:	48 01 d0             	add    %rdx,%rax
  8004202c1b:	48 c1 e8 20          	shr    $0x20,%rax
  8004202c1f:	89 c2                	mov    %eax,%edx
  8004202c21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202c25:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004202c28:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202c2c:	8b 50 04             	mov    0x4(%rax),%edx
  8004202c2f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202c33:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202c36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202c3a:	8b 50 08             	mov    0x8(%rax),%edx
  8004202c3d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202c41:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202c44:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202c47:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202c4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202c4e:	48 63 d2             	movslq %edx,%rdx
  8004202c51:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004202c58:	00 
  8004202c59:	eb 52                	jmp    8004202cad <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  8004202c5b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202c62:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202c66:	48 01 d0             	add    %rdx,%rax
  8004202c69:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202c6d:	76 3e                	jbe    8004202cad <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004202c6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202c73:	8b 50 14             	mov    0x14(%rax),%edx
  8004202c76:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202c7a:	8b 40 14             	mov    0x14(%rax),%eax
  8004202c7d:	89 d6                	mov    %edx,%esi
  8004202c7f:	89 c7                	mov    %eax,%edi
  8004202c81:	48 b8 f5 27 20 04 80 	movabs $0x80042027f5,%rax
  8004202c88:	00 00 00 
  8004202c8b:	ff d0                	callq  *%rax
  8004202c8d:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004202c93:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202c97:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202c9d:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004202ca0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202ca4:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202caa:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202cad:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202cb1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202cb4:	48 63 c8             	movslq %eax,%rcx
  8004202cb7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202cbe:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202cc1:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202cc6:	f7 e2                	mul    %edx
  8004202cc8:	89 d0                	mov    %edx,%eax
  8004202cca:	c1 e8 04             	shr    $0x4,%eax
  8004202ccd:	89 c0                	mov    %eax,%eax
  8004202ccf:	48 39 c1             	cmp    %rax,%rcx
  8004202cd2:	0f 82 46 fe ff ff    	jb     8004202b1e <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202cd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202cdf:	e9 dc 00 00 00       	jmpq   8004202dc0 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202ce4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202ce8:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202ceb:	48 63 d2             	movslq %edx,%rdx
  8004202cee:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202cf2:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004202cf9:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202d00:	00 
  8004202d01:	0f 84 b5 00 00 00    	je     8004202dbc <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202d07:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d0e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202d11:	83 f8 01             	cmp    $0x1,%eax
  8004202d14:	74 13                	je     8004202d29 <multiboot_read+0x494>
  8004202d16:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d1d:	8b 40 14             	mov    0x14(%rax),%eax
  8004202d20:	83 f8 03             	cmp    $0x3,%eax
  8004202d23:	0f 85 93 00 00 00    	jne    8004202dbc <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004202d29:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d30:	8b 40 04             	mov    0x4(%rax),%eax
  8004202d33:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004202d38:	77 49                	ja     8004202d83 <multiboot_read+0x4ee>
  8004202d3a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d41:	8b 40 08             	mov    0x8(%rax),%eax
  8004202d44:	85 c0                	test   %eax,%eax
  8004202d46:	75 3b                	jne    8004202d83 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202d48:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202d4f:	48 8b 10             	mov    (%rax),%rdx
  8004202d52:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d59:	8b 40 10             	mov    0x10(%rax),%eax
  8004202d5c:	89 c0                	mov    %eax,%eax
  8004202d5e:	48 c1 e0 20          	shl    $0x20,%rax
  8004202d62:	48 89 c1             	mov    %rax,%rcx
  8004202d65:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d6c:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202d6f:	89 c0                	mov    %eax,%eax
  8004202d71:	48 01 c8             	add    %rcx,%rax
  8004202d74:	48 01 c2             	add    %rax,%rdx
  8004202d77:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202d7e:	48 89 10             	mov    %rdx,(%rax)
  8004202d81:	eb 39                	jmp    8004202dbc <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202d83:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202d8a:	48 8b 10             	mov    (%rax),%rdx
  8004202d8d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202d94:	8b 40 10             	mov    0x10(%rax),%eax
  8004202d97:	89 c0                	mov    %eax,%eax
  8004202d99:	48 c1 e0 20          	shl    $0x20,%rax
  8004202d9d:	48 89 c1             	mov    %rax,%rcx
  8004202da0:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202da7:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202daa:	89 c0                	mov    %eax,%eax
  8004202dac:	48 01 c8             	add    %rcx,%rax
  8004202daf:	48 01 c2             	add    %rax,%rdx
  8004202db2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004202db9:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202dbc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202dc0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202dc3:	48 63 c8             	movslq %eax,%rcx
  8004202dc6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202dcd:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202dd0:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202dd5:	f7 e2                	mul    %edx
  8004202dd7:	89 d0                	mov    %edx,%eax
  8004202dd9:	c1 e8 04             	shr    $0x4,%eax
  8004202ddc:	89 c0                	mov    %eax,%eax
  8004202dde:	48 39 c1             	cmp    %rax,%rcx
  8004202de1:	0f 82 fd fe ff ff    	jb     8004202ce4 <multiboot_read+0x44f>
  8004202de7:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202dea:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004202dee:	5b                   	pop    %rbx
  8004202def:	41 5c                	pop    %r12
  8004202df1:	5d                   	pop    %rbp
  8004202df2:	c3                   	retq   

0000008004202df3 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202df3:	55                   	push   %rbp
  8004202df4:	48 89 e5             	mov    %rsp,%rbp
  8004202df7:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202dfb:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202e02:	00 
	size_t extmem = 0;
  8004202e03:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202e0a:	00 

	extern uintptr_t end_debug;
	cprintf("enddebug = %x\n ",end_debug);
  8004202e0b:	48 b8 48 57 37 04 80 	movabs $0x8004375748,%rax
  8004202e12:	00 00 00 
  8004202e15:	48 8b 00             	mov    (%rax),%rax
  8004202e18:	48 89 c6             	mov    %rax,%rsi
  8004202e1b:	48 bf 39 79 21 04 80 	movabs $0x8004217939,%rdi
  8004202e22:	00 00 00 
  8004202e25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e2a:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004202e31:	00 00 00 
  8004202e34:	ff d2                	callq  *%rdx

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202e36:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202e3d:	00 00 00 
  8004202e40:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202e44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202e48:	48 8b 00             	mov    (%rax),%rax
  8004202e4b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202e4f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202e54:	74 2d                	je     8004202e83 <i386_detect_memory+0x90>
  8004202e56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e5a:	8b 00                	mov    (%rax),%eax
  8004202e5c:	83 e0 40             	and    $0x40,%eax
  8004202e5f:	85 c0                	test   %eax,%eax
  8004202e61:	74 20                	je     8004202e83 <i386_detect_memory+0x90>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202e63:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  8004202e67:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  8004202e6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202e6f:	48 89 ce             	mov    %rcx,%rsi
  8004202e72:	48 89 c7             	mov    %rax,%rdi
  8004202e75:	48 b8 95 28 20 04 80 	movabs $0x8004202895,%rax
  8004202e7c:	00 00 00 
  8004202e7f:	ff d0                	callq  *%rax
  8004202e81:	eb 34                	jmp    8004202eb7 <i386_detect_memory+0xc4>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202e83:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202e88:	48 b8 56 28 20 04 80 	movabs $0x8004202856,%rax
  8004202e8f:	00 00 00 
  8004202e92:	ff d0                	callq  *%rax
  8004202e94:	c1 e0 0a             	shl    $0xa,%eax
  8004202e97:	48 98                	cltq   
  8004202e99:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  8004202e9d:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202ea2:	48 b8 56 28 20 04 80 	movabs $0x8004202856,%rax
  8004202ea9:	00 00 00 
  8004202eac:	ff d0                	callq  *%rax
  8004202eae:	c1 e0 0a             	shl    $0xa,%eax
  8004202eb1:	48 98                	cltq   
  8004202eb3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  8004202eb7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202ebb:	48 85 c0             	test   %rax,%rax
  8004202ebe:	75 35                	jne    8004202ef5 <i386_detect_memory+0x102>
  8004202ec0:	48 b9 49 79 21 04 80 	movabs $0x8004217949,%rcx
  8004202ec7:	00 00 00 
  8004202eca:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004202ed1:	00 00 00 
  8004202ed4:	be 8c 00 00 00       	mov    $0x8c,%esi
  8004202ed9:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004202ee0:	00 00 00 
  8004202ee3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ee8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004202eef:	00 00 00 
  8004202ef2:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202ef5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202ef9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202efd:	48 89 c2             	mov    %rax,%rdx
  8004202f00:	48 b8 30 42 37 04 80 	movabs $0x8004374230,%rax
  8004202f07:	00 00 00 
  8004202f0a:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202f0d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202f11:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f15:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202f19:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202f1e:	48 b8 56 28 20 04 80 	movabs $0x8004202856,%rax
  8004202f25:	00 00 00 
  8004202f28:	ff d0                	callq  *%rax
  8004202f2a:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202f2f:	75 2c                	jne    8004202f5d <i386_detect_memory+0x16a>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202f31:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202f36:	48 b8 56 28 20 04 80 	movabs $0x8004202856,%rax
  8004202f3d:	00 00 00 
  8004202f40:	ff d0                	callq  *%rax
  8004202f42:	c1 e0 10             	shl    $0x10,%eax
  8004202f45:	48 98                	cltq   
  8004202f47:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202f4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202f4f:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202f55:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202f5d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202f62:	74 1a                	je     8004202f7e <i386_detect_memory+0x18b>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202f64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202f68:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202f6f:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004202f76:	00 00 00 
  8004202f79:	48 89 10             	mov    %rdx,(%rax)
  8004202f7c:	eb 1a                	jmp    8004202f98 <i386_detect_memory+0x1a5>
	else
		npages = npages_basemem;
  8004202f7e:	48 b8 30 42 37 04 80 	movabs $0x8004374230,%rax
  8004202f85:	00 00 00 
  8004202f88:	48 8b 10             	mov    (%rax),%rdx
  8004202f8b:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004202f92:	00 00 00 
  8004202f95:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202f98:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004202f9f:	00 00 00 
  8004202fa2:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202fa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fa9:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202fad:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202fb1:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  8004202fb4:	48 b8 30 42 37 04 80 	movabs $0x8004374230,%rax
  8004202fbb:	00 00 00 
  8004202fbe:	48 8b 00             	mov    (%rax),%rax
  8004202fc1:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202fc5:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202fc9:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202fcc:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004202fd3:	00 00 00 
  8004202fd6:	48 8b 00             	mov    (%rax),%rax
  8004202fd9:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202fdd:	48 c1 e8 14          	shr    $0x14,%rax
  8004202fe1:	49 89 f0             	mov    %rsi,%r8
  8004202fe4:	48 89 c6             	mov    %rax,%rsi
  8004202fe7:	48 bf 78 79 21 04 80 	movabs $0x8004217978,%rdi
  8004202fee:	00 00 00 
  8004202ff1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ff6:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  8004202ffd:	00 00 00 
  8004203000:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004203003:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420300a:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420300b:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004203012:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004203013:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203017:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420301b:	48 c1 e8 14          	shr    $0x14,%rax
  800420301f:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004203022:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203026:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420302a:	48 c1 e8 14          	shr    $0x14,%rax
  800420302e:	48 89 c6             	mov    %rax,%rsi
  8004203031:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203035:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203039:	49 89 c8             	mov    %rcx,%r8
  800420303c:	48 89 d1             	mov    %rdx,%rcx
  800420303f:	48 89 f2             	mov    %rsi,%rdx
  8004203042:	48 89 c6             	mov    %rax,%rsi
  8004203045:	48 bf c8 79 21 04 80 	movabs $0x80042179c8,%rdi
  800420304c:	00 00 00 
  800420304f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203054:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  800420305b:	00 00 00 
  800420305e:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004203061:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203065:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004203069:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  800420306e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004203072:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203079:	00 00 00 
  800420307c:	48 8b 00             	mov    (%rax),%rax
  800420307f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004203083:	76 3a                	jbe    80042030bf <i386_detect_memory+0x2cc>
		npages = max_npages - 1024;
  8004203085:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203089:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  8004203090:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203097:	00 00 00 
  800420309a:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  800420309d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042030a1:	48 89 c6             	mov    %rax,%rsi
  80042030a4:	48 bf 30 7a 21 04 80 	movabs $0x8004217a30,%rdi
  80042030ab:	00 00 00 
  80042030ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030b3:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042030ba:	00 00 00 
  80042030bd:	ff d2                	callq  *%rdx
	}
}
  80042030bf:	c9                   	leaveq 
  80042030c0:	c3                   	retq   

00000080042030c1 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042030c1:	55                   	push   %rbp
  80042030c2:	48 89 e5             	mov    %rsp,%rbp
  80042030c5:	48 83 ec 34          	sub    $0x34,%rsp
  80042030c9:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042030cc:	48 b8 48 42 37 04 80 	movabs $0x8004374248,%rax
  80042030d3:	00 00 00 
  80042030d6:	48 8b 00             	mov    (%rax),%rax
  80042030d9:	48 85 c0             	test   %rax,%rax
  80042030dc:	75 4b                	jne    8004203129 <boot_alloc+0x68>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  80042030de:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042030e5:	00 
  80042030e6:	48 b8 10 80 3b 04 80 	movabs $0x80043b8010,%rax
  80042030ed:	00 00 00 
  80042030f0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042030f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030f8:	48 01 d0             	add    %rdx,%rax
  80042030fb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042030ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203103:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203108:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420310c:	48 89 d0             	mov    %rdx,%rax
  800420310f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203113:	48 29 c2             	sub    %rax,%rdx
  8004203116:	48 89 d0             	mov    %rdx,%rax
  8004203119:	48 89 c2             	mov    %rax,%rdx
  800420311c:	48 b8 48 42 37 04 80 	movabs $0x8004374248,%rax
  8004203123:	00 00 00 
  8004203126:	48 89 10             	mov    %rdx,(%rax)
		// cprintf("nextfree = %x\n ",nextfree);   
	}	
	
	//result is the nextfree from last time we implement boot_alloc method
	//because of static, nextfree pointer can keep value
	result = nextfree;
  8004203129:	48 b8 48 42 37 04 80 	movabs $0x8004374248,%rax
  8004203130:	00 00 00 
  8004203133:	48 8b 00             	mov    (%rax),%rax
  8004203136:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (n>0) {
  800420313a:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420313e:	74 57                	je     8004203197 <boot_alloc+0xd6>
		nextfree = ROUNDUP(nextfree+n,PGSIZE); 
  8004203140:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004203147:	00 
  8004203148:	48 b8 48 42 37 04 80 	movabs $0x8004374248,%rax
  800420314f:	00 00 00 
  8004203152:	48 8b 10             	mov    (%rax),%rdx
  8004203155:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004203158:	48 01 d0             	add    %rdx,%rax
  800420315b:	48 89 c2             	mov    %rax,%rdx
  800420315e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203162:	48 01 d0             	add    %rdx,%rax
  8004203165:	48 83 e8 01          	sub    $0x1,%rax
  8004203169:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420316d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203171:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203176:	48 f7 75 e0          	divq   -0x20(%rbp)
  800420317a:	48 89 d0             	mov    %rdx,%rax
  800420317d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203181:	48 29 c2             	sub    %rax,%rdx
  8004203184:	48 89 d0             	mov    %rdx,%rax
  8004203187:	48 89 c2             	mov    %rax,%rdx
  800420318a:	48 b8 48 42 37 04 80 	movabs $0x8004374248,%rax
  8004203191:	00 00 00 
  8004203194:	48 89 10             	mov    %rdx,(%rax)

	}
	//Therefore, whatever what case it is, result is the nextfree from last time
	//If this is the frist time, just return the start address
	return result;
  8004203197:	48 8b 45 e8          	mov    -0x18(%rbp),%rax


}
  800420319b:	c9                   	leaveq 
  800420319c:	c3                   	retq   

000000800420319d <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420319d:	55                   	push   %rbp
  800420319e:	48 89 e5             	mov    %rsp,%rbp
  80042031a1:	48 83 ec 70          	sub    $0x70,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  80042031a5:	48 b8 f3 2d 20 04 80 	movabs $0x8004202df3,%rax
  80042031ac:	00 00 00 
  80042031af:	ff d0                	callq  *%rax

	pml4e = boot_alloc(PGSIZE);
  80042031b1:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042031b6:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  80042031bd:	00 00 00 
  80042031c0:	ff d0                	callq  *%rax
  80042031c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  80042031c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031ca:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042031cf:	be 00 00 00 00       	mov    $0x0,%esi
  80042031d4:	48 89 c7             	mov    %rax,%rdi
  80042031d7:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042031de:	00 00 00 
  80042031e1:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042031e3:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042031ea:	00 00 00 
  80042031ed:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042031f1:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042031f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042031fc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203203:	00 00 00 
  8004203206:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420320a:	77 32                	ja     800420323e <x64_vm_init+0xa1>
  800420320c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203210:	48 89 c1             	mov    %rax,%rcx
  8004203213:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  800420321a:	00 00 00 
  800420321d:	be 0e 01 00 00       	mov    $0x10e,%esi
  8004203222:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203229:	00 00 00 
  800420322c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203231:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203238:	00 00 00 
  800420323b:	41 ff d0             	callq  *%r8
  800420323e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203245:	ff ff ff 
  8004203248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420324c:	48 01 c2             	add    %rax,%rdx
  800420324f:	48 b8 68 57 37 04 80 	movabs $0x8004375768,%rax
  8004203256:	00 00 00 
  8004203259:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

	pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);
  800420325c:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203263:	00 00 00 
  8004203266:	48 8b 00             	mov    (%rax),%rax
  8004203269:	c1 e0 04             	shl    $0x4,%eax
  800420326c:	89 c7                	mov    %eax,%edi
  800420326e:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  8004203275:	00 00 00 
  8004203278:	ff d0                	callq  *%rax
  800420327a:	48 ba 80 57 37 04 80 	movabs $0x8004375780,%rdx
  8004203281:	00 00 00 
  8004203284:	48 89 02             	mov    %rax,(%rdx)

	cprintf("npages: %d\n", npages);
  8004203287:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420328e:	00 00 00 
  8004203291:	48 8b 00             	mov    (%rax),%rax
  8004203294:	48 89 c6             	mov    %rax,%rsi
  8004203297:	48 bf 84 7a 21 04 80 	movabs $0x8004217a84,%rdi
  800420329e:	00 00 00 
  80042032a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032a6:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042032ad:	00 00 00 
  80042032b0:	ff d2                	callq  *%rdx
	cprintf("npages_basemem: %d\n", npages_basemem);
  80042032b2:	48 b8 30 42 37 04 80 	movabs $0x8004374230,%rax
  80042032b9:	00 00 00 
  80042032bc:	48 8b 00             	mov    (%rax),%rax
  80042032bf:	48 89 c6             	mov    %rax,%rsi
  80042032c2:	48 bf 90 7a 21 04 80 	movabs $0x8004217a90,%rdi
  80042032c9:	00 00 00 
  80042032cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032d1:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042032d8:	00 00 00 
  80042032db:	ff d2                	callq  *%rdx
	cprintf("pages: %x\n", pages);
  80042032dd:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042032e4:	00 00 00 
  80042032e7:	48 8b 00             	mov    (%rax),%rax
  80042032ea:	48 89 c6             	mov    %rax,%rsi
  80042032ed:	48 bf a4 7a 21 04 80 	movabs $0x8004217aa4,%rdi
  80042032f4:	00 00 00 
  80042032f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032fc:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004203303:	00 00 00 
  8004203306:	ff d2                	callq  *%rdx

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.

	envs=(struct Env *) boot_alloc(sizeof(struct Env)*NENV);
  8004203308:	bf 00 c0 05 00       	mov    $0x5c000,%edi
  800420330d:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  8004203314:	00 00 00 
  8004203317:	ff d0                	callq  *%rax
  8004203319:	48 ba 58 42 37 04 80 	movabs $0x8004374258,%rdx
  8004203320:	00 00 00 
  8004203323:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004203326:	48 b8 7a 38 20 04 80 	movabs $0x800420387a,%rax
  800420332d:	00 00 00 
  8004203330:	ff d0                	callq  *%rax

	// 	PTE_P controls whether the PTE is valid: if it is not set,a reference to the page causes a fault (i.e. is not allowed). PTE_W controls whether instructions are allowed to issue writes to the page; if not set, only reads and instruction
	// fetches are allowed. PTE_U controls whether user programs are allowed to use the page; if clear, only the kernel is allowed to use the page.

	// Your code goes here:
	cprintf("PTSIZE: %x\n",PTSIZE);
  8004203332:	be 00 00 20 00       	mov    $0x200000,%esi
  8004203337:	48 bf af 7a 21 04 80 	movabs $0x8004217aaf,%rdi
  800420333e:	00 00 00 
  8004203341:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203346:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420334d:	00 00 00 
  8004203350:	ff d2                	callq  *%rdx
	cprintf("(sizeof(struct PageInfo) * npages): %x\n",(sizeof(struct PageInfo) * npages));
  8004203352:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203359:	00 00 00 
  800420335c:	48 8b 00             	mov    (%rax),%rax
  800420335f:	48 c1 e0 04          	shl    $0x4,%rax
  8004203363:	48 89 c6             	mov    %rax,%rsi
  8004203366:	48 bf c0 7a 21 04 80 	movabs $0x8004217ac0,%rdi
  800420336d:	00 00 00 
  8004203370:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203375:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420337c:	00 00 00 
  800420337f:	ff d2                	callq  *%rdx
	boot_map_region(pml4e,UPAGES,(sizeof(struct PageInfo) * npages),PADDR(pages),PTE_U | PTE_P);
  8004203381:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004203388:	00 00 00 
  800420338b:	48 8b 00             	mov    (%rax),%rax
  800420338e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203392:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203399:	00 00 00 
  800420339c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042033a0:	77 32                	ja     80042033d4 <x64_vm_init+0x237>
  80042033a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033a6:	48 89 c1             	mov    %rax,%rcx
  80042033a9:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  80042033b0:	00 00 00 
  80042033b3:	be 3c 01 00 00       	mov    $0x13c,%esi
  80042033b8:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042033bf:	00 00 00 
  80042033c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033c7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042033ce:	00 00 00 
  80042033d1:	41 ff d0             	callq  *%r8
  80042033d4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042033db:	ff ff ff 
  80042033de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042033e2:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042033e6:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042033ed:	00 00 00 
  80042033f0:	48 8b 00             	mov    (%rax),%rax
  80042033f3:	48 c1 e0 04          	shl    $0x4,%rax
  80042033f7:	48 89 c2             	mov    %rax,%rdx
  80042033fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042033fe:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004203404:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  800420340b:	00 00 00 
  800420340e:	48 89 c7             	mov    %rax,%rdi
  8004203411:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  8004203418:	00 00 00 
  800420341b:	ff d0                	callq  *%rax
	cprintf("PADDR(pages) %x\n", PADDR(pages));
  800420341d:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004203424:	00 00 00 
  8004203427:	48 8b 00             	mov    (%rax),%rax
  800420342a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420342e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203435:	00 00 00 
  8004203438:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800420343c:	77 32                	ja     8004203470 <x64_vm_init+0x2d3>
  800420343e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203442:	48 89 c1             	mov    %rax,%rcx
  8004203445:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  800420344c:	00 00 00 
  800420344f:	be 3d 01 00 00       	mov    $0x13d,%esi
  8004203454:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420345b:	00 00 00 
  800420345e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203463:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420346a:	00 00 00 
  800420346d:	41 ff d0             	callq  *%r8
  8004203470:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203477:	ff ff ff 
  800420347a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420347e:	48 01 d0             	add    %rdx,%rax
  8004203481:	48 89 c6             	mov    %rax,%rsi
  8004203484:	48 bf e8 7a 21 04 80 	movabs $0x8004217ae8,%rdi
  800420348b:	00 00 00 
  800420348e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203493:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420349a:	00 00 00 
  800420349d:	ff d2                	callq  *%rdx
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.

	boot_map_region(pml4e,UENVS,(sizeof(struct Env)*NENV),PADDR(envs),PTE_U | PTE_P);
  800420349f:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  80042034a6:	00 00 00 
  80042034a9:	48 8b 00             	mov    (%rax),%rax
  80042034ac:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042034b0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042034b7:	00 00 00 
  80042034ba:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042034be:	77 32                	ja     80042034f2 <x64_vm_init+0x355>
  80042034c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034c4:	48 89 c1             	mov    %rax,%rcx
  80042034c7:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  80042034ce:	00 00 00 
  80042034d1:	be 47 01 00 00       	mov    $0x147,%esi
  80042034d6:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042034dd:	00 00 00 
  80042034e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034e5:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042034ec:	00 00 00 
  80042034ef:	41 ff d0             	callq  *%r8
  80042034f2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042034f9:	ff ff ff 
  80042034fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203500:	48 01 c2             	add    %rax,%rdx
  8004203503:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203507:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420350d:	48 89 d1             	mov    %rdx,%rcx
  8004203510:	ba 00 c0 05 00       	mov    $0x5c000,%edx
  8004203515:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  800420351c:	00 00 00 
  800420351f:	48 89 c7             	mov    %rax,%rdi
  8004203522:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  8004203529:	00 00 00 
  800420352c:	ff d0                	callq  *%rax
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(pml4e,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W | PTE_P);
  800420352e:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  8004203535:	00 00 00 
  8004203538:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420353c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203543:	00 00 00 
  8004203546:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420354a:	77 32                	ja     800420357e <x64_vm_init+0x3e1>
  800420354c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203550:	48 89 c1             	mov    %rax,%rcx
  8004203553:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  800420355a:	00 00 00 
  800420355d:	be 56 01 00 00       	mov    $0x156,%esi
  8004203562:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203569:	00 00 00 
  800420356c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203571:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203578:	00 00 00 
  800420357b:	41 ff d0             	callq  *%r8
  800420357e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203585:	ff ff ff 
  8004203588:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420358c:	48 01 c2             	add    %rax,%rdx
  800420358f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203593:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004203599:	48 89 d1             	mov    %rdx,%rcx
  800420359c:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042035a1:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042035a8:	00 00 00 
  80042035ab:	48 89 c7             	mov    %rax,%rdi
  80042035ae:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  80042035b5:	00 00 00 
  80042035b8:	ff d0                	callq  *%rax

	cprintf("PADDR(bootstack) %x\n", PADDR(bootstack));
  80042035ba:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  80042035c1:	00 00 00 
  80042035c4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042035c8:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042035cf:	00 00 00 
  80042035d2:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
  80042035d6:	77 32                	ja     800420360a <x64_vm_init+0x46d>
  80042035d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042035dc:	48 89 c1             	mov    %rax,%rcx
  80042035df:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  80042035e6:	00 00 00 
  80042035e9:	be 58 01 00 00       	mov    $0x158,%esi
  80042035ee:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042035f5:	00 00 00 
  80042035f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035fd:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203604:	00 00 00 
  8004203607:	41 ff d0             	callq  *%r8
  800420360a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203611:	ff ff ff 
  8004203614:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203618:	48 01 d0             	add    %rdx,%rax
  800420361b:	48 89 c6             	mov    %rax,%rsi
  800420361e:	48 bf f9 7a 21 04 80 	movabs $0x8004217af9,%rdi
  8004203625:	00 00 00 
  8004203628:	b8 00 00 00 00       	mov    $0x0,%eax
  800420362d:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004203634:	00 00 00 
  8004203637:	ff d2                	callq  *%rdx
	// Initialize the SMP-related parts of the memory map



	
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W|PTE_P);
  8004203639:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203640:	00 00 00 
  8004203643:	48 8b 00             	mov    (%rax),%rax
  8004203646:	48 c1 e0 0c          	shl    $0xc,%rax
  800420364a:	48 89 c2             	mov    %rax,%rdx
  800420364d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203651:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004203657:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420365c:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004203663:	00 00 00 
  8004203666:	48 89 c7             	mov    %rax,%rdi
  8004203669:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  8004203670:	00 00 00 
  8004203673:	ff d0                	callq  *%rax
	
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004203675:	48 b8 8f 37 20 04 80 	movabs $0x800420378f,%rax
  800420367c:	00 00 00 
  800420367f:	ff d0                	callq  *%rax

	/* check_boot_pml4e(boot_pml4e); */

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004203681:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203685:	48 83 c0 08          	add    $0x8,%rax
  8004203689:	48 8b 00             	mov    (%rax),%rax
  800420368c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203692:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203696:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420369a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420369e:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042036a1:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042036a4:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042036ab:	00 00 00 
  80042036ae:	48 8b 00             	mov    (%rax),%rax
  80042036b1:	48 39 c2             	cmp    %rax,%rdx
  80042036b4:	72 32                	jb     80042036e8 <x64_vm_init+0x54b>
  80042036b6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036ba:	48 89 c1             	mov    %rax,%rcx
  80042036bd:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  80042036c4:	00 00 00 
  80042036c7:	be 71 01 00 00       	mov    $0x171,%esi
  80042036cc:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042036d3:	00 00 00 
  80042036d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036db:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042036e2:	00 00 00 
  80042036e5:	41 ff d0             	callq  *%r8
  80042036e8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036ef:	00 00 00 
  80042036f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036f6:	48 01 d0             	add    %rdx,%rax
  80042036f9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042036fd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203701:	48 8b 00             	mov    (%rax),%rax
  8004203704:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420370a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800420370e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203712:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203716:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004203719:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420371c:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203723:	00 00 00 
  8004203726:	48 8b 00             	mov    (%rax),%rax
  8004203729:	48 39 c2             	cmp    %rax,%rdx
  800420372c:	72 32                	jb     8004203760 <x64_vm_init+0x5c3>
  800420372e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203732:	48 89 c1             	mov    %rax,%rcx
  8004203735:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  800420373c:	00 00 00 
  800420373f:	be 72 01 00 00       	mov    $0x172,%esi
  8004203744:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420374b:	00 00 00 
  800420374e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203753:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420375a:	00 00 00 
  800420375d:	41 ff d0             	callq  *%r8
  8004203760:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203767:	00 00 00 
  800420376a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420376e:	48 01 d0             	add    %rdx,%rax
  8004203771:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	lcr3(boot_cr3);
  8004203775:	48 b8 68 57 37 04 80 	movabs $0x8004375768,%rax
  800420377c:	00 00 00 
  800420377f:	48 8b 00             	mov    (%rax),%rax
  8004203782:	48 89 45 90          	mov    %rax,-0x70(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004203786:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420378a:	0f 22 d8             	mov    %rax,%cr3

	/* check_page_free_list(1); */
	/* check_page_alloc(); */
	/* page_check(); */
	/* check_page_free_list(0); */
}
  800420378d:	c9                   	leaveq 
  800420378e:	c3                   	retq   

000000800420378f <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420378f:	55                   	push   %rbp
  8004203790:	48 89 e5             	mov    %rsp,%rbp
  8004203793:	48 83 ec 20          	sub    $0x20,%rsp
	//
	// LAB 4: Your code here:


	int i;
	for (i=0;i<NCPU;i++)
  8004203797:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420379e:	e9 cb 00 00 00       	jmpq   800420386e <mem_init_mp+0xdf>
	{
		uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
  80042037a3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042037a6:	89 d0                	mov    %edx,%eax
  80042037a8:	01 c0                	add    %eax,%eax
  80042037aa:	01 d0                	add    %edx,%eax
  80042037ac:	c1 e0 0f             	shl    $0xf,%eax
  80042037af:	48 98                	cltq   
  80042037b1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042037b8:	00 00 00 
  80042037bb:	48 29 c2             	sub    %rax,%rdx
  80042037be:	48 89 d0             	mov    %rdx,%rax
  80042037c1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e,kstacktop_i- KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W|PTE_P);
  80042037c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042037c8:	48 98                	cltq   
  80042037ca:	48 c1 e0 10          	shl    $0x10,%rax
  80042037ce:	48 89 c2             	mov    %rax,%rdx
  80042037d1:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  80042037d8:	00 00 00 
  80042037db:	48 01 d0             	add    %rdx,%rax
  80042037de:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042037e2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042037e9:	00 00 00 
  80042037ec:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042037f0:	77 32                	ja     8004203824 <mem_init_mp+0x95>
  80042037f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037f6:	48 89 c1             	mov    %rax,%rcx
  80042037f9:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  8004203800:	00 00 00 
  8004203803:	be 98 01 00 00       	mov    $0x198,%esi
  8004203808:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420380f:	00 00 00 
  8004203812:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203817:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420381e:	00 00 00 
  8004203821:	41 ff d0             	callq  *%r8
  8004203824:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420382b:	ff ff ff 
  800420382e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203832:	48 01 c2             	add    %rax,%rdx
  8004203835:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203839:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004203840:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004203847:	00 00 00 
  800420384a:	48 8b 00             	mov    (%rax),%rax
  800420384d:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004203853:	48 89 d1             	mov    %rdx,%rcx
  8004203856:	ba 00 00 01 00       	mov    $0x10000,%edx
  800420385b:	48 89 c7             	mov    %rax,%rdi
  800420385e:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  8004203865:	00 00 00 
  8004203868:	ff d0                	callq  *%rax
	//
	// LAB 4: Your code here:


	int i;
	for (i=0;i<NCPU;i++)
  800420386a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420386e:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004203872:	0f 8e 2b ff ff ff    	jle    80042037a3 <mem_init_mp+0x14>
	{
		uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP);
		boot_map_region(boot_pml4e,kstacktop_i- KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W|PTE_P);
	}

}
  8004203878:	c9                   	leaveq 
  8004203879:	c3                   	retq   

000000800420387a <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  800420387a:	55                   	push   %rbp
  800420387b:	48 89 e5             	mov    %rsp,%rbp
  800420387e:	41 54                	push   %r12
  8004203880:	53                   	push   %rbx
  8004203881:	48 83 ec 20          	sub    $0x20,%rsp
    // NB: Make sure you preserve the direction in which your page_free_list 
    // is constructed

	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;
  8004203885:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420388c:	00 
	for (i = 0; i < npages; i++) {
  800420388d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203894:	00 
  8004203895:	e9 d2 00 00 00       	jmpq   800420396c <page_init+0xf2>
		pages[i].pp_ref = 0;
  800420389a:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042038a1:	00 00 00 
  80042038a4:	48 8b 00             	mov    (%rax),%rax
  80042038a7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042038ab:	48 c1 e2 04          	shl    $0x4,%rdx
  80042038af:	48 01 d0             	add    %rdx,%rax
  80042038b2:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  80042038b8:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042038bf:	00 00 00 
  80042038c2:	48 8b 00             	mov    (%rax),%rax
  80042038c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042038c9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042038cd:	48 01 d0             	add    %rdx,%rax
  80042038d0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

		if (i == MPENTRY_PADDR / PGSIZE)
  80042038d7:	48 83 7d e8 07       	cmpq   $0x7,-0x18(%rbp)
  80042038dc:	75 20                	jne    80042038fe <page_init+0x84>
		{
			pages[i].pp_ref = 1;
  80042038de:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042038e5:	00 00 00 
  80042038e8:	48 8b 00             	mov    (%rax),%rax
  80042038eb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042038ef:	48 c1 e2 04          	shl    $0x4,%rdx
  80042038f3:	48 01 d0             	add    %rdx,%rax
  80042038f6:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
			continue;
  80042038fc:	eb 69                	jmp    8004203967 <page_init+0xed>
		}

		if(last)
  80042038fe:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203903:	74 21                	je     8004203926 <page_init+0xac>
			last->pp_link = &pages[i];
  8004203905:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  800420390c:	00 00 00 
  800420390f:	48 8b 00             	mov    (%rax),%rax
  8004203912:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203916:	48 c1 e2 04          	shl    $0x4,%rdx
  800420391a:	48 01 c2             	add    %rax,%rdx
  800420391d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203921:	48 89 10             	mov    %rdx,(%rax)
  8004203924:	eb 25                	jmp    800420394b <page_init+0xd1>
		else
			page_free_list = &pages[i];
  8004203926:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  800420392d:	00 00 00 
  8004203930:	48 8b 00             	mov    (%rax),%rax
  8004203933:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203937:	48 c1 e2 04          	shl    $0x4,%rdx
  800420393b:	48 01 c2             	add    %rax,%rdx
  800420393e:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203945:	00 00 00 
  8004203948:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  800420394b:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004203952:	00 00 00 
  8004203955:	48 8b 00             	mov    (%rax),%rax
  8004203958:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420395c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203960:	48 01 d0             	add    %rdx,%rax
  8004203963:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    // is constructed

	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004203967:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420396c:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203973:	00 00 00 
  8004203976:	48 8b 00             	mov    (%rax),%rax
  8004203979:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420397d:	0f 82 17 ff ff ff    	jb     800420389a <page_init+0x20>
		last = &pages[i];
	}

	//modified

	page_free_list= page_free_list->pp_link;
  8004203983:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  800420398a:	00 00 00 
  800420398d:	48 8b 00             	mov    (%rax),%rax
  8004203990:	48 8b 10             	mov    (%rax),%rdx
  8004203993:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  800420399a:	00 00 00 
  800420399d:	48 89 10             	mov    %rdx,(%rax)
	pages[IOPHYSMEM/PGSIZE-1].pp_link=&pages[PADDR(boot_alloc(0))/PGSIZE];
  80042039a0:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042039a7:	00 00 00 
  80042039aa:	48 8b 00             	mov    (%rax),%rax
  80042039ad:	48 8d 98 f0 09 00 00 	lea    0x9f0(%rax),%rbx
  80042039b4:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  80042039bb:	00 00 00 
  80042039be:	4c 8b 20             	mov    (%rax),%r12
  80042039c1:	bf 00 00 00 00       	mov    $0x0,%edi
  80042039c6:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  80042039cd:	00 00 00 
  80042039d0:	ff d0                	callq  *%rax
  80042039d2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042039d6:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042039dd:	00 00 00 
  80042039e0:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042039e4:	77 32                	ja     8004203a18 <page_init+0x19e>
  80042039e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039ea:	48 89 c1             	mov    %rax,%rcx
  80042039ed:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  80042039f4:	00 00 00 
  80042039f7:	be dc 01 00 00       	mov    $0x1dc,%esi
  80042039fc:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203a03:	00 00 00 
  8004203a06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a0b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203a12:	00 00 00 
  8004203a15:	41 ff d0             	callq  *%r8
  8004203a18:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203a1f:	ff ff ff 
  8004203a22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203a26:	48 01 d0             	add    %rdx,%rax
  8004203a29:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203a2d:	48 c1 e0 04          	shl    $0x4,%rax
  8004203a31:	4c 01 e0             	add    %r12,%rax
  8004203a34:	48 89 03             	mov    %rax,(%rbx)

	for (i=IOPHYSMEM/PGSIZE;i<PADDR(boot_alloc(0))/PGSIZE;i++)
  8004203a37:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004203a3e:	00 
  8004203a3f:	eb 24                	jmp    8004203a65 <page_init+0x1eb>
		pages[i].pp_link=NULL;
  8004203a41:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004203a48:	00 00 00 
  8004203a4b:	48 8b 00             	mov    (%rax),%rax
  8004203a4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203a52:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203a56:	48 01 d0             	add    %rdx,%rax
  8004203a59:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	//modified

	page_free_list= page_free_list->pp_link;
	pages[IOPHYSMEM/PGSIZE-1].pp_link=&pages[PADDR(boot_alloc(0))/PGSIZE];

	for (i=IOPHYSMEM/PGSIZE;i<PADDR(boot_alloc(0))/PGSIZE;i++)
  8004203a60:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004203a65:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203a6a:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  8004203a71:	00 00 00 
  8004203a74:	ff d0                	callq  *%rax
  8004203a76:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004203a7a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203a81:	00 00 00 
  8004203a84:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004203a88:	77 32                	ja     8004203abc <page_init+0x242>
  8004203a8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203a8e:	48 89 c1             	mov    %rax,%rcx
  8004203a91:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  8004203a98:	00 00 00 
  8004203a9b:	be de 01 00 00       	mov    $0x1de,%esi
  8004203aa0:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203aa7:	00 00 00 
  8004203aaa:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aaf:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203ab6:	00 00 00 
  8004203ab9:	41 ff d0             	callq  *%r8
  8004203abc:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203ac3:	ff ff ff 
  8004203ac6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203aca:	48 01 d0             	add    %rdx,%rax
  8004203acd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203ad1:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203ad5:	0f 87 66 ff ff ff    	ja     8004203a41 <page_init+0x1c7>
		pages[i].pp_link=NULL;
	cprintf("finished page init\n");     
  8004203adb:	48 bf 0e 7b 21 04 80 	movabs $0x8004217b0e,%rdi
  8004203ae2:	00 00 00 
  8004203ae5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aea:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004203af1:	00 00 00 
  8004203af4:	ff d2                	callq  *%rdx

}
  8004203af6:	48 83 c4 20          	add    $0x20,%rsp
  8004203afa:	5b                   	pop    %rbx
  8004203afb:	41 5c                	pop    %r12
  8004203afd:	5d                   	pop    %rbp
  8004203afe:	c3                   	retq   

0000008004203aff <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004203aff:	55                   	push   %rbp
  8004203b00:	48 89 e5             	mov    %rsp,%rbp
  8004203b03:	48 83 ec 20          	sub    $0x20,%rsp
  8004203b07:	89 7d ec             	mov    %edi,-0x14(%rbp)

  // Fill this function in
	if (page_free_list == NULL) {
  8004203b0a:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203b11:	00 00 00 
  8004203b14:	48 8b 00             	mov    (%rax),%rax
  8004203b17:	48 85 c0             	test   %rax,%rax
  8004203b1a:	75 07                	jne    8004203b23 <page_alloc+0x24>
		return NULL;
  8004203b1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b21:	eb 73                	jmp    8004203b96 <page_alloc+0x97>
	}
	struct PageInfo* tmp = page_free_list;
  8004203b23:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203b2a:	00 00 00 
  8004203b2d:	48 8b 00             	mov    (%rax),%rax
  8004203b30:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (alloc_flags & ALLOC_ZERO){
  8004203b34:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004203b37:	83 e0 01             	and    $0x1,%eax
  8004203b3a:	85 c0                	test   %eax,%eax
  8004203b3c:	74 2c                	je     8004203b6a <page_alloc+0x6b>
		memset(page2kva(tmp), '\0', PGSIZE);
  8004203b3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b42:	48 89 c7             	mov    %rax,%rdi
  8004203b45:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  8004203b4c:	00 00 00 
  8004203b4f:	ff d0                	callq  *%rax
  8004203b51:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203b56:	be 00 00 00 00       	mov    $0x0,%esi
  8004203b5b:	48 89 c7             	mov    %rax,%rdi
  8004203b5e:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004203b65:	00 00 00 
  8004203b68:	ff d0                	callq  *%rax
	}
	page_free_list = page_free_list->pp_link;
  8004203b6a:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203b71:	00 00 00 
  8004203b74:	48 8b 00             	mov    (%rax),%rax
  8004203b77:	48 8b 10             	mov    (%rax),%rdx
  8004203b7a:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203b81:	00 00 00 
  8004203b84:	48 89 10             	mov    %rdx,(%rax)
	tmp->pp_link = NULL;
  8004203b87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b8b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return tmp;
  8004203b92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004203b96:	c9                   	leaveq 
  8004203b97:	c3                   	retq   

0000008004203b98 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!

static void
page_initpp(struct PageInfo *pp)
{
  8004203b98:	55                   	push   %rbp
  8004203b99:	48 89 e5             	mov    %rsp,%rbp
  8004203b9c:	48 83 ec 10          	sub    $0x10,%rsp
  8004203ba0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004203ba4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ba8:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203bad:	be 00 00 00 00       	mov    $0x0,%esi
  8004203bb2:	48 89 c7             	mov    %rax,%rdi
  8004203bb5:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004203bbc:	00 00 00 
  8004203bbf:	ff d0                	callq  *%rax
}
  8004203bc1:	c9                   	leaveq 
  8004203bc2:	c3                   	retq   

0000008004203bc3 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004203bc3:	55                   	push   %rbp
  8004203bc4:	48 89 e5             	mov    %rsp,%rbp
  8004203bc7:	48 83 ec 10          	sub    $0x10,%rsp
  8004203bcb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.

         //if(pp->pp_link != NULL || pp->pp_ref != 0)
           //panic("page_free: Page is still in use");
	if (pp->pp_ref != 0 || pp->pp_link != NULL){
  8004203bcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203bd3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203bd7:	66 85 c0             	test   %ax,%ax
  8004203bda:	75 0c                	jne    8004203be8 <page_free+0x25>
  8004203bdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203be0:	48 8b 00             	mov    (%rax),%rax
  8004203be3:	48 85 c0             	test   %rax,%rax
  8004203be6:	74 52                	je     8004203c3a <page_free+0x77>
		cprintf("pp_ref %d\n",pp->pp_ref);//test
  8004203be8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203bec:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203bf0:	0f b7 c0             	movzwl %ax,%eax
  8004203bf3:	89 c6                	mov    %eax,%esi
  8004203bf5:	48 bf 22 7b 21 04 80 	movabs $0x8004217b22,%rdi
  8004203bfc:	00 00 00 
  8004203bff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c04:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004203c0b:	00 00 00 
  8004203c0e:	ff d2                	callq  *%rdx
		panic("pp_ref is nonzero or pp_link is not NULL\n");
  8004203c10:	48 ba 30 7b 21 04 80 	movabs $0x8004217b30,%rdx
  8004203c17:	00 00 00 
  8004203c1a:	be 1a 02 00 00       	mov    $0x21a,%esi
  8004203c1f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203c26:	00 00 00 
  8004203c29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203c2e:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004203c35:	00 00 00 
  8004203c38:	ff d1                	callq  *%rcx
		return;
	}
	pp->pp_link = page_free_list;
  8004203c3a:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203c41:	00 00 00 
  8004203c44:	48 8b 10             	mov    (%rax),%rdx
  8004203c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c4b:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;
  8004203c4e:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004203c55:	00 00 00 
  8004203c58:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c5c:	48 89 10             	mov    %rdx,(%rax)
}         
  8004203c5f:	c9                   	leaveq 
  8004203c60:	c3                   	retq   

0000008004203c61 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203c61:	55                   	push   %rbp
  8004203c62:	48 89 e5             	mov    %rsp,%rbp
  8004203c65:	48 83 ec 10          	sub    $0x10,%rsp
  8004203c69:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

	if (--pp->pp_ref == 0){
  8004203c6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c71:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203c75:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203c78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c7c:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203c80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c84:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203c88:	66 85 c0             	test   %ax,%ax
  8004203c8b:	75 13                	jne    8004203ca0 <page_decref+0x3f>
		page_free(pp);
  8004203c8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c91:	48 89 c7             	mov    %rax,%rdi
  8004203c94:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004203c9b:	00 00 00 
  8004203c9e:	ff d0                	callq  *%rax
	}

}
  8004203ca0:	c9                   	leaveq 
  8004203ca1:	c3                   	retq   

0000008004203ca2 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *

pml4e_walk(pml4e_t *pml4e, const void *va, int create){
  8004203ca2:	55                   	push   %rbp
  8004203ca3:	48 89 e5             	mov    %rsp,%rbp
  8004203ca6:	48 83 ec 60          	sub    $0x60,%rsp
  8004203caa:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203cae:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203cb2:	89 55 ac             	mov    %edx,-0x54(%rbp)
	pte_t *pte;
	pml4e_t *pdpe;
	struct PageInfo *newPage;
	pdpe = &pml4e[PML4(va)];
  8004203cb5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203cb9:	48 c1 e8 27          	shr    $0x27,%rax
  8004203cbd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203cc2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203cc9:	00 
  8004203cca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203cce:	48 01 d0             	add    %rdx,%rax
  8004203cd1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!(*pdpe & PTE_P)){
  8004203cd5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203cd9:	48 8b 00             	mov    (%rax),%rax
  8004203cdc:	83 e0 01             	and    $0x1,%eax
  8004203cdf:	48 85 c0             	test   %rax,%rax
  8004203ce2:	0f 85 33 01 00 00    	jne    8004203e1b <pml4e_walk+0x179>
		if (!create) {
  8004203ce8:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004203cec:	75 0a                	jne    8004203cf8 <pml4e_walk+0x56>
			return NULL;
  8004203cee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cf3:	e9 b8 01 00 00       	jmpq   8004203eb0 <pml4e_walk+0x20e>
		}
		if (!(newPage = page_alloc(ALLOC_ZERO))) {
  8004203cf8:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203cfd:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004203d04:	00 00 00 
  8004203d07:	ff d0                	callq  *%rax
  8004203d09:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203d0d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203d12:	75 0a                	jne    8004203d1e <pml4e_walk+0x7c>
			return NULL;
  8004203d14:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d19:	e9 92 01 00 00       	jmpq   8004203eb0 <pml4e_walk+0x20e>
		}
		newPage->pp_ref++;
  8004203d1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d22:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203d26:	8d 50 01             	lea    0x1(%rax),%edx
  8004203d29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d2d:	66 89 50 08          	mov    %dx,0x8(%rax)
		*pdpe = page2pa(newPage) | PTE_P | PTE_W | PTE_U;
  8004203d31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d35:	48 89 c7             	mov    %rax,%rdi
  8004203d38:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004203d3f:	00 00 00 
  8004203d42:	ff d0                	callq  *%rax
  8004203d44:	48 83 c8 07          	or     $0x7,%rax
  8004203d48:	48 89 c2             	mov    %rax,%rdx
  8004203d4b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203d4f:	48 89 10             	mov    %rdx,(%rax)
		pte = pdpe_walk(KADDR(PTE_ADDR(*pdpe)), va, create);
  8004203d52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203d56:	48 8b 00             	mov    (%rax),%rax
  8004203d59:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203d5f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203d63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203d67:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203d6b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203d6e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203d71:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203d78:	00 00 00 
  8004203d7b:	48 8b 00             	mov    (%rax),%rax
  8004203d7e:	48 39 c2             	cmp    %rax,%rdx
  8004203d81:	72 32                	jb     8004203db5 <pml4e_walk+0x113>
  8004203d83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203d87:	48 89 c1             	mov    %rax,%rcx
  8004203d8a:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004203d91:	00 00 00 
  8004203d94:	be 58 02 00 00       	mov    $0x258,%esi
  8004203d99:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203da0:	00 00 00 
  8004203da3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203da8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203daf:	00 00 00 
  8004203db2:	41 ff d0             	callq  *%r8
  8004203db5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203dbc:	00 00 00 
  8004203dbf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203dc3:	48 01 d0             	add    %rdx,%rax
  8004203dc6:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004203dc9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004203dcd:	48 89 ce             	mov    %rcx,%rsi
  8004203dd0:	48 89 c7             	mov    %rax,%rdi
  8004203dd3:	48 b8 b2 3e 20 04 80 	movabs $0x8004203eb2,%rax
  8004203dda:	00 00 00 
  8004203ddd:	ff d0                	callq  *%rax
  8004203ddf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

		if (!pte){
  8004203de3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203de8:	0f 85 be 00 00 00    	jne    8004203eac <pml4e_walk+0x20a>
			newPage->pp_ref = 0;
  8004203dee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203df2:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
			page_free(newPage);
  8004203df8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203dfc:	48 89 c7             	mov    %rax,%rdi
  8004203dff:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004203e06:	00 00 00 
  8004203e09:	ff d0                	callq  *%rax
			*pdpe = 0;
  8004203e0b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203e0f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004203e16:	e9 91 00 00 00       	jmpq   8004203eac <pml4e_walk+0x20a>
		}
	}
	else{
		pte = pdpe_walk(KADDR(PTE_ADDR(*pdpe)), va, create);
  8004203e1b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203e1f:	48 8b 00             	mov    (%rax),%rax
  8004203e22:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203e28:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004203e2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203e30:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203e34:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004203e37:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004203e3a:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203e41:	00 00 00 
  8004203e44:	48 8b 00             	mov    (%rax),%rax
  8004203e47:	48 39 c2             	cmp    %rax,%rdx
  8004203e4a:	72 32                	jb     8004203e7e <pml4e_walk+0x1dc>
  8004203e4c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203e50:	48 89 c1             	mov    %rax,%rcx
  8004203e53:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004203e5a:	00 00 00 
  8004203e5d:	be 61 02 00 00       	mov    $0x261,%esi
  8004203e62:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203e69:	00 00 00 
  8004203e6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e71:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203e78:	00 00 00 
  8004203e7b:	41 ff d0             	callq  *%r8
  8004203e7e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203e85:	00 00 00 
  8004203e88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203e8c:	48 01 d0             	add    %rdx,%rax
  8004203e8f:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004203e92:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004203e96:	48 89 ce             	mov    %rcx,%rsi
  8004203e99:	48 89 c7             	mov    %rax,%rdi
  8004203e9c:	48 b8 b2 3e 20 04 80 	movabs $0x8004203eb2,%rax
  8004203ea3:	00 00 00 
  8004203ea6:	ff d0                	callq  *%rax
  8004203ea8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	return pte;
  8004203eac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004203eb0:	c9                   	leaveq 
  8004203eb1:	c3                   	retq   

0000008004203eb2 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  8004203eb2:	55                   	push   %rbp
  8004203eb3:	48 89 e5             	mov    %rsp,%rbp
  8004203eb6:	48 83 ec 60          	sub    $0x60,%rsp
  8004203eba:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203ebe:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004203ec2:	89 55 ac             	mov    %edx,-0x54(%rbp)

	pte_t *pte;
	pdpe_t *pde;
	struct PageInfo *newPage;
	pde = &pdpe[PDPE(va)];
  8004203ec5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ec9:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203ecd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ed2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203ed9:	00 
  8004203eda:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203ede:	48 01 d0             	add    %rdx,%rax
  8004203ee1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!(*pde & PTE_P)){
  8004203ee5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203ee9:	48 8b 00             	mov    (%rax),%rax
  8004203eec:	83 e0 01             	and    $0x1,%eax
  8004203eef:	48 85 c0             	test   %rax,%rax
  8004203ef2:	0f 85 33 01 00 00    	jne    800420402b <pdpe_walk+0x179>
		if (!create) {
  8004203ef8:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004203efc:	75 0a                	jne    8004203f08 <pdpe_walk+0x56>
			return NULL;
  8004203efe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f03:	e9 b8 01 00 00       	jmpq   80042040c0 <pdpe_walk+0x20e>
		}
		if (!(newPage=page_alloc(ALLOC_ZERO))) {
  8004203f08:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203f0d:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004203f14:	00 00 00 
  8004203f17:	ff d0                	callq  *%rax
  8004203f19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203f1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203f22:	75 0a                	jne    8004203f2e <pdpe_walk+0x7c>
			return NULL;
  8004203f24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f29:	e9 92 01 00 00       	jmpq   80042040c0 <pdpe_walk+0x20e>
		}
		newPage->pp_ref++;
  8004203f2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f32:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203f36:	8d 50 01             	lea    0x1(%rax),%edx
  8004203f39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f3d:	66 89 50 08          	mov    %dx,0x8(%rax)
		*pde = page2pa(newPage) | PTE_P | PTE_W | PTE_U;
  8004203f41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203f45:	48 89 c7             	mov    %rax,%rdi
  8004203f48:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004203f4f:	00 00 00 
  8004203f52:	ff d0                	callq  *%rax
  8004203f54:	48 83 c8 07          	or     $0x7,%rax
  8004203f58:	48 89 c2             	mov    %rax,%rdx
  8004203f5b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203f5f:	48 89 10             	mov    %rdx,(%rax)
		pte = pgdir_walk(KADDR(PTE_ADDR(*pde)), va, create);
  8004203f62:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203f66:	48 8b 00             	mov    (%rax),%rax
  8004203f69:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203f6f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203f73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203f77:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203f7b:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004203f7e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004203f81:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004203f88:	00 00 00 
  8004203f8b:	48 8b 00             	mov    (%rax),%rax
  8004203f8e:	48 39 c2             	cmp    %rax,%rdx
  8004203f91:	72 32                	jb     8004203fc5 <pdpe_walk+0x113>
  8004203f93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203f97:	48 89 c1             	mov    %rax,%rcx
  8004203f9a:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004203fa1:	00 00 00 
  8004203fa4:	be 7b 02 00 00       	mov    $0x27b,%esi
  8004203fa9:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004203fb0:	00 00 00 
  8004203fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fb8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004203fbf:	00 00 00 
  8004203fc2:	41 ff d0             	callq  *%r8
  8004203fc5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203fcc:	00 00 00 
  8004203fcf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203fd3:	48 01 d0             	add    %rdx,%rax
  8004203fd6:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004203fd9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004203fdd:	48 89 ce             	mov    %rcx,%rsi
  8004203fe0:	48 89 c7             	mov    %rax,%rdi
  8004203fe3:	48 b8 c2 40 20 04 80 	movabs $0x80042040c2,%rax
  8004203fea:	00 00 00 
  8004203fed:	ff d0                	callq  *%rax
  8004203fef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (!pte){
  8004203ff3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ff8:	0f 85 be 00 00 00    	jne    80042040bc <pdpe_walk+0x20a>
			newPage->pp_ref=0;
  8004203ffe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204002:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
			page_free(newPage);
  8004204008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420400c:	48 89 c7             	mov    %rax,%rdi
  800420400f:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004204016:	00 00 00 
  8004204019:	ff d0                	callq  *%rax
			*pde=0;
  800420401b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420401f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004204026:	e9 91 00 00 00       	jmpq   80042040bc <pdpe_walk+0x20a>
		}
	}
	else{
		pte = pgdir_walk(KADDR(PTE_ADDR(*pde)), va, create);
  800420402b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420402f:	48 8b 00             	mov    (%rax),%rax
  8004204032:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204038:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420403c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204040:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204044:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004204047:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420404a:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004204051:	00 00 00 
  8004204054:	48 8b 00             	mov    (%rax),%rax
  8004204057:	48 39 c2             	cmp    %rax,%rdx
  800420405a:	72 32                	jb     800420408e <pdpe_walk+0x1dc>
  800420405c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204060:	48 89 c1             	mov    %rax,%rcx
  8004204063:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  800420406a:	00 00 00 
  800420406d:	be 83 02 00 00       	mov    $0x283,%esi
  8004204072:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204079:	00 00 00 
  800420407c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204081:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204088:	00 00 00 
  800420408b:	41 ff d0             	callq  *%r8
  800420408e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204095:	00 00 00 
  8004204098:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420409c:	48 01 d0             	add    %rdx,%rax
  800420409f:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042040a2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042040a6:	48 89 ce             	mov    %rcx,%rsi
  80042040a9:	48 89 c7             	mov    %rax,%rdi
  80042040ac:	48 b8 c2 40 20 04 80 	movabs $0x80042040c2,%rax
  80042040b3:	00 00 00 
  80042040b6:	ff d0                	callq  *%rax
  80042040b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	return pte;
  80042040bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

}
  80042040c0:	c9                   	leaveq 
  80042040c1:	c3                   	retq   

00000080042040c2 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  80042040c2:	55                   	push   %rbp
  80042040c3:	48 89 e5             	mov    %rsp,%rbp
  80042040c6:	48 83 ec 40          	sub    $0x40,%rsp
  80042040ca:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042040ce:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042040d2:	89 55 cc             	mov    %edx,-0x34(%rbp)


	pte_t *pte;
	struct PageInfo *newPage;
	pte = &pgdir[PDX(va)];
  80042040d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042040d9:	48 c1 e8 15          	shr    $0x15,%rax
  80042040dd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042040e2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042040e9:	00 
  80042040ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042040ee:	48 01 d0             	add    %rdx,%rax
  80042040f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(!(*pte & PTE_P)){
  80042040f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040f9:	48 8b 00             	mov    (%rax),%rax
  80042040fc:	83 e0 01             	and    $0x1,%eax
  80042040ff:	48 85 c0             	test   %rax,%rax
  8004204102:	75 6a                	jne    800420416e <pgdir_walk+0xac>
		if (!create) {
  8004204104:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004204108:	75 0a                	jne    8004204114 <pgdir_walk+0x52>
			return NULL;
  800420410a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420410f:	e9 ee 00 00 00       	jmpq   8004204202 <pgdir_walk+0x140>
		}
		if (!(newPage=page_alloc(ALLOC_ZERO))) {
  8004204114:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204119:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004204120:	00 00 00 
  8004204123:	ff d0                	callq  *%rax
  8004204125:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004204129:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420412e:	75 0a                	jne    800420413a <pgdir_walk+0x78>
			return NULL;
  8004204130:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204135:	e9 c8 00 00 00       	jmpq   8004204202 <pgdir_walk+0x140>
		}
		newPage->pp_ref++;
  800420413a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420413e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004204142:	8d 50 01             	lea    0x1(%rax),%edx
  8004204145:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204149:	66 89 50 08          	mov    %dx,0x8(%rax)
		*pte = page2pa(newPage) | PTE_P | PTE_U | PTE_W;
  800420414d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204151:	48 89 c7             	mov    %rax,%rdi
  8004204154:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420415b:	00 00 00 
  800420415e:	ff d0                	callq  *%rax
  8004204160:	48 83 c8 07          	or     $0x7,%rax
  8004204164:	48 89 c2             	mov    %rax,%rdx
  8004204167:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420416b:	48 89 10             	mov    %rdx,(%rax)
	}
	pte = KADDR(PTE_ADDR(*pte));
  800420416e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204172:	48 8b 00             	mov    (%rax),%rax
  8004204175:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420417b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420417f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204183:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204187:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800420418a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420418d:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004204194:	00 00 00 
  8004204197:	48 8b 00             	mov    (%rax),%rax
  800420419a:	48 39 c2             	cmp    %rax,%rdx
  800420419d:	72 32                	jb     80042041d1 <pgdir_walk+0x10f>
  800420419f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042041a3:	48 89 c1             	mov    %rax,%rcx
  80042041a6:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  80042041ad:	00 00 00 
  80042041b0:	be 9f 02 00 00       	mov    $0x29f,%esi
  80042041b5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042041bc:	00 00 00 
  80042041bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041c4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042041cb:	00 00 00 
  80042041ce:	41 ff d0             	callq  *%r8
  80042041d1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042041d8:	00 00 00 
  80042041db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042041df:	48 01 d0             	add    %rdx,%rax
  80042041e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return &pte[PTX(va)];
  80042041e6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042041ea:	48 c1 e8 0c          	shr    $0xc,%rax
  80042041ee:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042041f3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042041fa:	00 
  80042041fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041ff:	48 01 d0             	add    %rdx,%rax
}
  8004204202:	c9                   	leaveq 
  8004204203:	c3                   	retq   

0000008004204204 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004204204:	55                   	push   %rbp
  8004204205:	48 89 e5             	mov    %rsp,%rbp
  8004204208:	48 83 ec 40          	sub    $0x40,%rsp
  800420420c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004204210:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004204214:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004204218:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420421c:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
	// Fill this function in

	int i = 0;
  8004204220:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	pte_t *pte;
	while (i < size){
  8004204227:	eb 52                	jmp    800420427b <boot_map_region+0x77>
		pte = pml4e_walk(pml4e, (void *)(la + i), 1);
  8004204229:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420422c:	48 63 d0             	movslq %eax,%rdx
  800420422f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204233:	48 01 d0             	add    %rdx,%rax
  8004204236:	48 89 c1             	mov    %rax,%rcx
  8004204239:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420423d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004204242:	48 89 ce             	mov    %rcx,%rsi
  8004204245:	48 89 c7             	mov    %rax,%rdi
  8004204248:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  800420424f:	00 00 00 
  8004204252:	ff d0                	callq  *%rax
  8004204254:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		*pte = (pa + i) | perm;
  8004204258:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420425b:	48 63 d0             	movslq %eax,%rdx
  800420425e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204262:	48 01 c2             	add    %rax,%rdx
  8004204265:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004204268:	48 98                	cltq   
  800420426a:	48 09 c2             	or     %rax,%rdx
  800420426d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204271:	48 89 10             	mov    %rdx,(%rax)
		i += PGSIZE;
  8004204274:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
{
	// Fill this function in

	int i = 0;
	pte_t *pte;
	while (i < size){
  800420427b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420427e:	48 98                	cltq   
  8004204280:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204284:	72 a3                	jb     8004204229 <boot_map_region+0x25>
		pte = pml4e_walk(pml4e, (void *)(la + i), 1);
		*pte = (pa + i) | perm;
		i += PGSIZE;
	}

}
  8004204286:	c9                   	leaveq 
  8004204287:	c3                   	retq   

0000008004204288 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004204288:	55                   	push   %rbp
  8004204289:	48 89 e5             	mov    %rsp,%rbp
  800420428c:	48 83 ec 30          	sub    $0x30,%rsp
  8004204290:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004204294:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004204298:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420429c:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in

	pte_t *ad = pml4e_walk(pml4e, va, 1);
  800420429f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042042a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042042a7:	ba 01 00 00 00       	mov    $0x1,%edx
  80042042ac:	48 89 ce             	mov    %rcx,%rsi
  80042042af:	48 89 c7             	mov    %rax,%rdi
  80042042b2:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  80042042b9:	00 00 00 
  80042042bc:	ff d0                	callq  *%rax
  80042042be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(ad == NULL){//page table could not be allocated
  80042042c2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042c7:	75 0a                	jne    80042042d3 <page_insert+0x4b>
		return -E_NO_MEM;
  80042042c9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042042ce:	e9 e0 00 00 00       	jmpq   80042043b3 <page_insert+0x12b>
	}
	if (*ad & PTE_P){
  80042042d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042d7:	48 8b 00             	mov    (%rax),%rax
  80042042da:	83 e0 01             	and    $0x1,%eax
  80042042dd:	48 85 c0             	test   %rax,%rax
  80042042e0:	0f 84 8b 00 00 00    	je     8004204371 <page_insert+0xe9>
		if (page2pa(pp)==PTE_ADDR(*ad))
  80042042e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042042ea:	48 89 c7             	mov    %rax,%rdi
  80042042ed:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042042f4:	00 00 00 
  80042042f7:	ff d0                	callq  *%rax
  80042042f9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042042fd:	48 8b 12             	mov    (%rdx),%rdx
  8004204300:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  8004204307:	48 39 d0             	cmp    %rdx,%rax
  800420430a:	75 4b                	jne    8004204357 <page_insert+0xcf>
		{
			*ad = page2pa(pp) | perm | PTE_P;
  800420430c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204310:	48 89 c7             	mov    %rax,%rdi
  8004204313:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420431a:	00 00 00 
  800420431d:	ff d0                	callq  *%rax
  800420431f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004204322:	48 63 d2             	movslq %edx,%rdx
  8004204325:	48 09 d0             	or     %rdx,%rax
  8004204328:	48 83 c8 01          	or     $0x1,%rax
  800420432c:	48 89 c2             	mov    %rax,%rdx
  800420432f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204333:	48 89 10             	mov    %rdx,(%rax)
			 tlb_invalidate(pml4e, va);
  8004204336:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420433a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420433e:	48 89 d6             	mov    %rdx,%rsi
  8004204341:	48 89 c7             	mov    %rax,%rdi
  8004204344:	48 b8 a8 44 20 04 80 	movabs $0x80042044a8,%rax
  800420434b:	00 00 00 
  800420434e:	ff d0                	callq  *%rax
			 return 0;
  8004204350:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204355:	eb 5c                	jmp    80042043b3 <page_insert+0x12b>
		}

		page_remove(pml4e, va);
  8004204357:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420435b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420435f:	48 89 d6             	mov    %rdx,%rsi
  8004204362:	48 89 c7             	mov    %rax,%rdi
  8004204365:	48 b8 24 44 20 04 80 	movabs $0x8004204424,%rax
  800420436c:	00 00 00 
  800420436f:	ff d0                	callq  *%rax
	}
	*ad = page2pa(pp) | perm | PTE_P;
  8004204371:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204375:	48 89 c7             	mov    %rax,%rdi
  8004204378:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420437f:	00 00 00 
  8004204382:	ff d0                	callq  *%rax
  8004204384:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004204387:	48 63 d2             	movslq %edx,%rdx
  800420438a:	48 09 d0             	or     %rdx,%rax
  800420438d:	48 83 c8 01          	or     $0x1,%rax
  8004204391:	48 89 c2             	mov    %rax,%rdx
  8004204394:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204398:	48 89 10             	mov    %rdx,(%rax)
	pp->pp_ref++;
  800420439b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420439f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042043a3:	8d 50 01             	lea    0x1(%rax),%edx
  80042043a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042043aa:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  80042043ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042043b3:	c9                   	leaveq 
  80042043b4:	c3                   	retq   

00000080042043b5 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  80042043b5:	55                   	push   %rbp
  80042043b6:	48 89 e5             	mov    %rsp,%rbp
  80042043b9:	48 83 ec 30          	sub    $0x30,%rsp
  80042043bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042043c1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042043c5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in

	pte_t *ad = pml4e_walk(pml4e, va, 1);
  80042043c9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042043cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042043d1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042043d6:	48 89 ce             	mov    %rcx,%rsi
  80042043d9:	48 89 c7             	mov    %rax,%rdi
  80042043dc:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  80042043e3:	00 00 00 
  80042043e6:	ff d0                	callq  *%rax
  80042043e8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(ad == NULL){
  80042043ec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042043f1:	75 07                	jne    80042043fa <page_lookup+0x45>
		return NULL;
  80042043f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043f8:	eb 28                	jmp    8004204422 <page_lookup+0x6d>
	}
	if(pte_store != 0){
  80042043fa:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042043ff:	74 0b                	je     800420440c <page_lookup+0x57>
		*pte_store = ad;
  8004204401:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204405:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204409:	48 89 10             	mov    %rdx,(%rax)
	}
	return pa2page(*ad);
  800420440c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204410:	48 8b 00             	mov    (%rax),%rax
  8004204413:	48 89 c7             	mov    %rax,%rdi
  8004204416:	48 b8 fc 26 20 04 80 	movabs $0x80042026fc,%rax
  800420441d:	00 00 00 
  8004204420:	ff d0                	callq  *%rax

}
  8004204422:	c9                   	leaveq 
  8004204423:	c3                   	retq   

0000008004204424 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004204424:	55                   	push   %rbp
  8004204425:	48 89 e5             	mov    %rsp,%rbp
  8004204428:	48 83 ec 20          	sub    $0x20,%rsp
  800420442c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004204430:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	//Fill this function in
	pte_t *ad = NULL;
  8004204434:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420443b:	00 
	struct PageInfo *phy_pageInfo = page_lookup(pml4e, va, &ad);
  800420443c:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004204440:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004204444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204448:	48 89 ce             	mov    %rcx,%rsi
  800420444b:	48 89 c7             	mov    %rax,%rdi
  800420444e:	48 b8 b5 43 20 04 80 	movabs $0x80042043b5,%rax
  8004204455:	00 00 00 
  8004204458:	ff d0                	callq  *%rax
  800420445a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(phy_pageInfo == NULL){//1
  800420445e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204463:	74 41                	je     80042044a6 <page_remove+0x82>
		return;
	}
	page_decref(phy_pageInfo);//2,3
  8004204465:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204469:	48 89 c7             	mov    %rax,%rdi
  800420446c:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004204473:	00 00 00 
  8004204476:	ff d0                	callq  *%rax

	if(ad != NULL){//4-(if such a PTE exists)
  8004204478:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420447c:	48 85 c0             	test   %rax,%rax
  800420447f:	74 25                	je     80042044a6 <page_remove+0x82>
		*ad = 0;//4-set to 0
  8004204481:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204485:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		tlb_invalidate(pml4e,va);//5
  800420448c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004204490:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204494:	48 89 d6             	mov    %rdx,%rsi
  8004204497:	48 89 c7             	mov    %rax,%rdi
  800420449a:	48 b8 a8 44 20 04 80 	movabs $0x80042044a8,%rax
  80042044a1:	00 00 00 
  80042044a4:	ff d0                	callq  *%rax
	}

}
  80042044a6:	c9                   	leaveq 
  80042044a7:	c3                   	retq   

00000080042044a8 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  80042044a8:	55                   	push   %rbp
  80042044a9:	48 89 e5             	mov    %rsp,%rbp
  80042044ac:	48 83 ec 20          	sub    $0x20,%rsp
  80042044b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042044b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  80042044b8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042044bd:	75 35                	jne    80042044f4 <tlb_invalidate+0x4c>
  80042044bf:	48 b9 5a 7b 21 04 80 	movabs $0x8004217b5a,%rcx
  80042044c6:	00 00 00 
  80042044c9:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042044d0:	00 00 00 
  80042044d3:	be 35 03 00 00       	mov    $0x335,%esi
  80042044d8:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042044df:	00 00 00 
  80042044e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044e7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042044ee:	00 00 00 
  80042044f1:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  80042044f4:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042044fb:	00 00 00 
  80042044fe:	ff d0                	callq  *%rax
  8004204500:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004204507:	00 00 00 
  800420450a:	48 98                	cltq   
  800420450c:	48 c1 e0 03          	shl    $0x3,%rax
  8004204510:	48 89 c1             	mov    %rax,%rcx
  8004204513:	48 c1 e1 04          	shl    $0x4,%rcx
  8004204517:	48 01 c8             	add    %rcx,%rax
  800420451a:	48 01 d0             	add    %rdx,%rax
  800420451d:	48 83 c0 08          	add    $0x8,%rax
  8004204521:	48 8b 00             	mov    (%rax),%rax
  8004204524:	48 85 c0             	test   %rax,%rax
  8004204527:	74 3d                	je     8004204566 <tlb_invalidate+0xbe>
  8004204529:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004204530:	00 00 00 
  8004204533:	ff d0                	callq  *%rax
  8004204535:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420453c:	00 00 00 
  800420453f:	48 98                	cltq   
  8004204541:	48 c1 e0 03          	shl    $0x3,%rax
  8004204545:	48 89 c1             	mov    %rax,%rcx
  8004204548:	48 c1 e1 04          	shl    $0x4,%rcx
  800420454c:	48 01 c8             	add    %rcx,%rax
  800420454f:	48 01 d0             	add    %rdx,%rax
  8004204552:	48 83 c0 08          	add    $0x8,%rax
  8004204556:	48 8b 00             	mov    (%rax),%rax
  8004204559:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004204560:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204564:	75 0f                	jne    8004204575 <tlb_invalidate+0xcd>
  8004204566:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420456a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void 
invlpg(void *addr)
{ 
    __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  800420456e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204572:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004204575:	c9                   	leaveq 
  8004204576:	c3                   	retq   

0000008004204577 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004204577:	55                   	push   %rbp
  8004204578:	48 89 e5             	mov    %rsp,%rbp
  800420457b:	48 83 ec 60          	sub    $0x60,%rsp
  800420457f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004204583:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:

	void *ret = (void*) base; 
  8004204587:	48 b8 40 b6 22 04 80 	movabs $0x800422b640,%rax
  800420458e:	00 00 00 
  8004204591:	48 8b 00             	mov    (%rax),%rax
  8004204594:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (base+ROUNDUP(size, PGSIZE)>MMIOLIM || ROUNDUP(size, PGSIZE)<0)
  8004204598:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  800420459f:	00 
  80042045a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042045a4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042045a8:	48 01 d0             	add    %rdx,%rax
  80042045ab:	48 83 e8 01          	sub    $0x1,%rax
  80042045af:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042045b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042045b7:	ba 00 00 00 00       	mov    $0x0,%edx
  80042045bc:	48 f7 75 f0          	divq   -0x10(%rbp)
  80042045c0:	48 89 d0             	mov    %rdx,%rax
  80042045c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042045c7:	48 29 c2             	sub    %rax,%rdx
  80042045ca:	48 b8 40 b6 22 04 80 	movabs $0x800422b640,%rax
  80042045d1:	00 00 00 
  80042045d4:	48 8b 00             	mov    (%rax),%rax
  80042045d7:	48 01 c2             	add    %rax,%rdx
  80042045da:	48 b8 00 00 e0 03 80 	movabs $0x8003e00000,%rax
  80042045e1:	00 00 00 
  80042045e4:	48 39 c2             	cmp    %rax,%rdx
  80042045e7:	77 1d                	ja     8004204606 <mmio_map_region+0x8f>
  80042045e9:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042045f0:	00 
  80042045f1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042045f5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042045f9:	48 01 d0             	add    %rdx,%rax
  80042045fc:	48 83 e8 01          	sub    $0x1,%rax
  8004204600:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204604:	eb 2a                	jmp    8004204630 <mmio_map_region+0xb9>
	{
		panic("mmio_map_region: out of memory!");
  8004204606:	48 ba 68 7b 21 04 80 	movabs $0x8004217b68,%rdx
  800420460d:	00 00 00 
  8004204610:	be 5e 03 00 00       	mov    $0x35e,%esi
  8004204615:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420461c:	00 00 00 
  800420461f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204624:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420462b:	00 00 00 
  800420462e:	ff d1                	callq  *%rcx
	}
	boot_map_region(boot_pml4e, base, ROUNDUP(size, PGSIZE), pa, PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004204630:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  8004204637:	00 
  8004204638:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420463c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004204640:	48 01 d0             	add    %rdx,%rax
  8004204643:	48 83 e8 01          	sub    $0x1,%rax
  8004204647:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420464b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420464f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204654:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004204658:	48 89 d0             	mov    %rdx,%rax
  800420465b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420465f:	48 89 d7             	mov    %rdx,%rdi
  8004204662:	48 29 c7             	sub    %rax,%rdi
  8004204665:	48 b8 40 b6 22 04 80 	movabs $0x800422b640,%rax
  800420466c:	00 00 00 
  800420466f:	48 8b 30             	mov    (%rax),%rsi
  8004204672:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004204679:	00 00 00 
  800420467c:	48 8b 00             	mov    (%rax),%rax
  800420467f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004204683:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004204689:	48 89 d1             	mov    %rdx,%rcx
  800420468c:	48 89 fa             	mov    %rdi,%rdx
  800420468f:	48 89 c7             	mov    %rax,%rdi
  8004204692:	48 b8 04 42 20 04 80 	movabs $0x8004204204,%rax
  8004204699:	00 00 00 
  800420469c:	ff d0                	callq  *%rax
	base+=ROUNDUP(size, PGSIZE);
  800420469e:	48 c7 45 c0 00 10 00 	movq   $0x1000,-0x40(%rbp)
  80042046a5:	00 
  80042046a6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042046aa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042046ae:	48 01 d0             	add    %rdx,%rax
  80042046b1:	48 83 e8 01          	sub    $0x1,%rax
  80042046b5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042046b9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042046bd:	ba 00 00 00 00       	mov    $0x0,%edx
  80042046c2:	48 f7 75 c0          	divq   -0x40(%rbp)
  80042046c6:	48 89 d0             	mov    %rdx,%rax
  80042046c9:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042046cd:	48 29 c2             	sub    %rax,%rdx
  80042046d0:	48 b8 40 b6 22 04 80 	movabs $0x800422b640,%rax
  80042046d7:	00 00 00 
  80042046da:	48 8b 00             	mov    (%rax),%rax
  80042046dd:	48 01 c2             	add    %rax,%rdx
  80042046e0:	48 b8 40 b6 22 04 80 	movabs $0x800422b640,%rax
  80042046e7:	00 00 00 
  80042046ea:	48 89 10             	mov    %rdx,(%rax)
	return ret;
  80042046ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

	panic("mmio_map_region not implemented");



}
  80042046f1:	c9                   	leaveq 
  80042046f2:	c3                   	retq   

00000080042046f3 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  80042046f3:	55                   	push   %rbp
  80042046f4:	48 89 e5             	mov    %rsp,%rbp
  80042046f7:	48 83 ec 40          	sub    $0x40,%rsp
  80042046fb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042046ff:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004204703:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004204707:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	// LAB 3: Your code here.

	pde_t*  pte;
	perm |= PTE_P;
  800420470a:	83 4d c4 01          	orl    $0x1,-0x3c(%rbp)
	size_t i = (size_t)va;
  800420470e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204712:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while (i<(size_t)va+len)
  8004204716:	e9 8e 00 00 00       	jmpq   80042047a9 <user_mem_check+0xb6>
	{
		if (i >= ULIM || !(pte = pml4e_walk(env->env_pml4e, (void*)i, 0)) || (*pte & perm) != perm) 
  800420471b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004204722:	00 00 00 
  8004204725:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204729:	77 4a                	ja     8004204775 <user_mem_check+0x82>
  800420472b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420472f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204733:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420473a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420473f:	48 89 ce             	mov    %rcx,%rsi
  8004204742:	48 89 c7             	mov    %rax,%rdi
  8004204745:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  800420474c:	00 00 00 
  800420474f:	ff d0                	callq  *%rax
  8004204751:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004204755:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420475a:	74 19                	je     8004204775 <user_mem_check+0x82>
  800420475c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204760:	48 8b 10             	mov    (%rax),%rdx
  8004204763:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004204766:	48 98                	cltq   
  8004204768:	48 21 c2             	and    %rax,%rdx
  800420476b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420476e:	48 98                	cltq   
  8004204770:	48 39 c2             	cmp    %rax,%rdx
  8004204773:	74 18                	je     800420478d <user_mem_check+0x9a>
		{
			user_mem_check_addr = i;
  8004204775:	48 b8 40 42 37 04 80 	movabs $0x8004374240,%rax
  800420477c:	00 00 00 
  800420477f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204783:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;
  8004204786:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420478b:	eb 36                	jmp    80042047c3 <user_mem_check+0xd0>
		}

		i=ROUNDDOWN (i, PGSIZE)+PGSIZE;
  800420478d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204791:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204799:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420479f:	48 05 00 10 00 00    	add    $0x1000,%rax
  80042047a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// LAB 3: Your code here.

	pde_t*  pte;
	perm |= PTE_P;
	size_t i = (size_t)va;
	while (i<(size_t)va+len)
  80042047a9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042047ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042047b1:	48 01 d0             	add    %rdx,%rax
  80042047b4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042047b8:	0f 87 5d ff ff ff    	ja     800420471b <user_mem_check+0x28>

		i=ROUNDDOWN (i, PGSIZE)+PGSIZE;
	}


	return 0;
  80042047be:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042047c3:	c9                   	leaveq 
  80042047c4:	c3                   	retq   

00000080042047c5 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  80042047c5:	55                   	push   %rbp
  80042047c6:	48 89 e5             	mov    %rsp,%rbp
  80042047c9:	48 83 ec 20          	sub    $0x20,%rsp
  80042047cd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042047d1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80042047d5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042047d9:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  80042047dc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042047df:	83 c8 04             	or     $0x4,%eax
  80042047e2:	89 c1                	mov    %eax,%ecx
  80042047e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042047e8:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042047ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042047f0:	48 89 c7             	mov    %rax,%rdi
  80042047f3:	48 b8 f3 46 20 04 80 	movabs $0x80042046f3,%rax
  80042047fa:	00 00 00 
  80042047fd:	ff d0                	callq  *%rax
  80042047ff:	85 c0                	test   %eax,%eax
  8004204801:	79 47                	jns    800420484a <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004204803:	48 b8 40 42 37 04 80 	movabs $0x8004374240,%rax
  800420480a:	00 00 00 
  800420480d:	48 8b 10             	mov    (%rax),%rdx
  8004204810:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204814:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420481a:	89 c6                	mov    %eax,%esi
  800420481c:	48 bf 88 7b 21 04 80 	movabs $0x8004217b88,%rdi
  8004204823:	00 00 00 
  8004204826:	b8 00 00 00 00       	mov    $0x0,%eax
  800420482b:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004204832:	00 00 00 
  8004204835:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004204837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420483b:	48 89 c7             	mov    %rax,%rdi
  800420483e:	48 b8 48 90 20 04 80 	movabs $0x8004209048,%rax
  8004204845:	00 00 00 
  8004204848:	ff d0                	callq  *%rax
	}
}
  800420484a:	c9                   	leaveq 
  800420484b:	c3                   	retq   

000000800420484c <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  800420484c:	55                   	push   %rbp
  800420484d:	48 89 e5             	mov    %rsp,%rbp
  8004204850:	48 83 ec 60          	sub    $0x60,%rsp
  8004204854:	89 f8                	mov    %edi,%eax
  8004204856:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004204859:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  800420485d:	74 07                	je     8004204866 <check_page_free_list+0x1a>
  800420485f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004204864:	eb 05                	jmp    800420486b <check_page_free_list+0x1f>
  8004204866:	b8 00 02 00 00       	mov    $0x200,%eax
  800420486b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  800420486e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204875:	00 
  8004204876:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420487d:	00 
	char *first_free_page;

	if (!page_free_list)
  800420487e:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204885:	00 00 00 
  8004204888:	48 8b 00             	mov    (%rax),%rax
  800420488b:	48 85 c0             	test   %rax,%rax
  800420488e:	75 2a                	jne    80042048ba <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004204890:	48 ba c0 7b 21 04 80 	movabs $0x8004217bc0,%rdx
  8004204897:	00 00 00 
  800420489a:	be b9 03 00 00       	mov    $0x3b9,%esi
  800420489f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042048a6:	00 00 00 
  80042048a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048ae:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  80042048b5:	00 00 00 
  80042048b8:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  80042048ba:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  80042048be:	0f 84 a9 00 00 00    	je     800420496d <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  80042048c4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  80042048c8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042048cc:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  80042048d0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042048d4:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  80042048db:	00 00 00 
  80042048de:	48 8b 00             	mov    (%rax),%rax
  80042048e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042048e5:	eb 58                	jmp    800420493f <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  80042048e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048eb:	48 89 c7             	mov    %rax,%rdi
  80042048ee:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042048f5:	00 00 00 
  80042048f8:	ff d0                	callq  *%rax
  80042048fa:	48 c1 e8 15          	shr    $0x15,%rax
  80042048fe:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004204903:	48 89 c2             	mov    %rax,%rdx
  8004204906:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204909:	48 39 c2             	cmp    %rax,%rdx
  800420490c:	0f 93 c0             	setae  %al
  800420490f:	0f b6 c0             	movzbl %al,%eax
  8004204912:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004204915:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004204918:	48 98                	cltq   
  800420491a:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  800420491f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204923:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004204926:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420492a:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420492d:	48 98                	cltq   
  800420492f:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204938:	48 8b 00             	mov    (%rax),%rax
  800420493b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420493f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204944:	75 a1                	jne    80042048e7 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004204946:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420494a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204951:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204955:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004204959:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  800420495c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204960:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204967:	00 00 00 
  800420496a:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  800420496d:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204974:	00 00 00 
  8004204977:	48 8b 00             	mov    (%rax),%rax
  800420497a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420497e:	eb 5e                	jmp    80042049de <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204980:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204984:	48 89 c7             	mov    %rax,%rdi
  8004204987:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420498e:	00 00 00 
  8004204991:	ff d0                	callq  *%rax
  8004204993:	48 c1 e8 15          	shr    $0x15,%rax
  8004204997:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420499c:	48 89 c2             	mov    %rax,%rdx
  800420499f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042049a2:	48 39 c2             	cmp    %rax,%rdx
  80042049a5:	73 2c                	jae    80042049d3 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  80042049a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049ab:	48 89 c7             	mov    %rax,%rdi
  80042049ae:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  80042049b5:	00 00 00 
  80042049b8:	ff d0                	callq  *%rax
  80042049ba:	ba 80 00 00 00       	mov    $0x80,%edx
  80042049bf:	be 97 00 00 00       	mov    $0x97,%esi
  80042049c4:	48 89 c7             	mov    %rax,%rdi
  80042049c7:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042049ce:	00 00 00 
  80042049d1:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042049d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049d7:	48 8b 00             	mov    (%rax),%rax
  80042049da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042049de:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042049e3:	75 9b                	jne    8004204980 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);


		first_free_page = (char *) boot_alloc(0);
  80042049e5:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049ea:	48 b8 c1 30 20 04 80 	movabs $0x80042030c1,%rax
  80042049f1:	00 00 00 
  80042049f4:	ff d0                	callq  *%rax
  80042049f6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042049fa:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204a01:	00 00 00 
  8004204a04:	48 8b 00             	mov    (%rax),%rax
  8004204a07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204a0b:	e9 20 03 00 00       	jmpq   8004204d30 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
			assert(pp >= pages);
  8004204a10:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004204a17:	00 00 00 
  8004204a1a:	48 8b 00             	mov    (%rax),%rax
  8004204a1d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204a21:	73 35                	jae    8004204a58 <check_page_free_list+0x20c>
  8004204a23:	48 b9 e4 7b 21 04 80 	movabs $0x8004217be4,%rcx
  8004204a2a:	00 00 00 
  8004204a2d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204a34:	00 00 00 
  8004204a37:	be d4 03 00 00       	mov    $0x3d4,%esi
  8004204a3c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204a43:	00 00 00 
  8004204a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a4b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204a52:	00 00 00 
  8004204a55:	41 ff d0             	callq  *%r8
			assert(pp < pages + npages);
  8004204a58:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004204a5f:	00 00 00 
  8004204a62:	48 8b 10             	mov    (%rax),%rdx
  8004204a65:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004204a6c:	00 00 00 
  8004204a6f:	48 8b 00             	mov    (%rax),%rax
  8004204a72:	48 c1 e0 04          	shl    $0x4,%rax
  8004204a76:	48 01 d0             	add    %rdx,%rax
  8004204a79:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a7d:	77 35                	ja     8004204ab4 <check_page_free_list+0x268>
  8004204a7f:	48 b9 f0 7b 21 04 80 	movabs $0x8004217bf0,%rcx
  8004204a86:	00 00 00 
  8004204a89:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204a90:	00 00 00 
  8004204a93:	be d5 03 00 00       	mov    $0x3d5,%esi
  8004204a98:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204a9f:	00 00 00 
  8004204aa2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204aa7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204aae:	00 00 00 
  8004204ab1:	41 ff d0             	callq  *%r8
			assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204ab4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204ab8:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004204abf:	00 00 00 
  8004204ac2:	48 8b 00             	mov    (%rax),%rax
  8004204ac5:	48 29 c2             	sub    %rax,%rdx
  8004204ac8:	48 89 d0             	mov    %rdx,%rax
  8004204acb:	83 e0 0f             	and    $0xf,%eax
  8004204ace:	48 85 c0             	test   %rax,%rax
  8004204ad1:	74 35                	je     8004204b08 <check_page_free_list+0x2bc>
  8004204ad3:	48 b9 08 7c 21 04 80 	movabs $0x8004217c08,%rcx
  8004204ada:	00 00 00 
  8004204add:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204ae4:	00 00 00 
  8004204ae7:	be d6 03 00 00       	mov    $0x3d6,%esi
  8004204aec:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204af3:	00 00 00 
  8004204af6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204afb:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204b02:	00 00 00 
  8004204b05:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
			assert(page2pa(pp) != 0);
  8004204b08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b0c:	48 89 c7             	mov    %rax,%rdi
  8004204b0f:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204b16:	00 00 00 
  8004204b19:	ff d0                	callq  *%rax
  8004204b1b:	48 85 c0             	test   %rax,%rax
  8004204b1e:	75 35                	jne    8004204b55 <check_page_free_list+0x309>
  8004204b20:	48 b9 3a 7c 21 04 80 	movabs $0x8004217c3a,%rcx
  8004204b27:	00 00 00 
  8004204b2a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204b31:	00 00 00 
  8004204b34:	be d9 03 00 00       	mov    $0x3d9,%esi
  8004204b39:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204b40:	00 00 00 
  8004204b43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b48:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204b4f:	00 00 00 
  8004204b52:	41 ff d0             	callq  *%r8
			assert(page2pa(pp) != IOPHYSMEM);
  8004204b55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b59:	48 89 c7             	mov    %rax,%rdi
  8004204b5c:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204b63:	00 00 00 
  8004204b66:	ff d0                	callq  *%rax
  8004204b68:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204b6e:	75 35                	jne    8004204ba5 <check_page_free_list+0x359>
  8004204b70:	48 b9 4b 7c 21 04 80 	movabs $0x8004217c4b,%rcx
  8004204b77:	00 00 00 
  8004204b7a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204b81:	00 00 00 
  8004204b84:	be da 03 00 00       	mov    $0x3da,%esi
  8004204b89:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204b90:	00 00 00 
  8004204b93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b98:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204b9f:	00 00 00 
  8004204ba2:	41 ff d0             	callq  *%r8
			assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204ba5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ba9:	48 89 c7             	mov    %rax,%rdi
  8004204bac:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204bb3:	00 00 00 
  8004204bb6:	ff d0                	callq  *%rax
  8004204bb8:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204bbe:	75 35                	jne    8004204bf5 <check_page_free_list+0x3a9>
  8004204bc0:	48 b9 68 7c 21 04 80 	movabs $0x8004217c68,%rcx
  8004204bc7:	00 00 00 
  8004204bca:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204bd1:	00 00 00 
  8004204bd4:	be db 03 00 00       	mov    $0x3db,%esi
  8004204bd9:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204be0:	00 00 00 
  8004204be3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204be8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204bef:	00 00 00 
  8004204bf2:	41 ff d0             	callq  *%r8
			assert(page2pa(pp) != EXTPHYSMEM);
  8004204bf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bf9:	48 89 c7             	mov    %rax,%rdi
  8004204bfc:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204c03:	00 00 00 
  8004204c06:	ff d0                	callq  *%rax
  8004204c08:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204c0e:	75 35                	jne    8004204c45 <check_page_free_list+0x3f9>
  8004204c10:	48 b9 8b 7c 21 04 80 	movabs $0x8004217c8b,%rcx
  8004204c17:	00 00 00 
  8004204c1a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204c21:	00 00 00 
  8004204c24:	be dc 03 00 00       	mov    $0x3dc,%esi
  8004204c29:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204c30:	00 00 00 
  8004204c33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c38:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204c3f:	00 00 00 
  8004204c42:	41 ff d0             	callq  *%r8
			assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004204c45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c49:	48 89 c7             	mov    %rax,%rdi
  8004204c4c:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204c53:	00 00 00 
  8004204c56:	ff d0                	callq  *%rax
  8004204c58:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204c5e:	76 4e                	jbe    8004204cae <check_page_free_list+0x462>
  8004204c60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c64:	48 89 c7             	mov    %rax,%rdi
  8004204c67:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  8004204c6e:	00 00 00 
  8004204c71:	ff d0                	callq  *%rax
  8004204c73:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204c77:	73 35                	jae    8004204cae <check_page_free_list+0x462>
  8004204c79:	48 b9 a8 7c 21 04 80 	movabs $0x8004217ca8,%rcx
  8004204c80:	00 00 00 
  8004204c83:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204c8a:	00 00 00 
  8004204c8d:	be dd 03 00 00       	mov    $0x3dd,%esi
  8004204c92:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204c99:	00 00 00 
  8004204c9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ca1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204ca8:	00 00 00 
  8004204cab:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
			assert(page2pa(pp) != MPENTRY_PADDR);
  8004204cae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204cb2:	48 89 c7             	mov    %rax,%rdi
  8004204cb5:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204cbc:	00 00 00 
  8004204cbf:	ff d0                	callq  *%rax
  8004204cc1:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004204cc7:	75 35                	jne    8004204cfe <check_page_free_list+0x4b2>
  8004204cc9:	48 b9 ed 7c 21 04 80 	movabs $0x8004217ced,%rcx
  8004204cd0:	00 00 00 
  8004204cd3:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204cda:	00 00 00 
  8004204cdd:	be df 03 00 00       	mov    $0x3df,%esi
  8004204ce2:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204ce9:	00 00 00 
  8004204cec:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cf1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204cf8:	00 00 00 
  8004204cfb:	41 ff d0             	callq  *%r8

			if (page2pa(pp) < EXTPHYSMEM)
  8004204cfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d02:	48 89 c7             	mov    %rax,%rdi
  8004204d05:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204d0c:	00 00 00 
  8004204d0f:	ff d0                	callq  *%rax
  8004204d11:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204d17:	77 07                	ja     8004204d20 <check_page_free_list+0x4d4>
				++nfree_basemem;
  8004204d19:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204d1e:	eb 05                	jmp    8004204d25 <check_page_free_list+0x4d9>
			else
				++nfree_extmem;
  8004204d20:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);


		first_free_page = (char *) boot_alloc(0);
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204d25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d29:	48 8b 00             	mov    (%rax),%rax
  8004204d2c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204d30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204d35:	0f 85 d5 fc ff ff    	jne    8004204a10 <check_page_free_list+0x1c4>
			else
				++nfree_extmem;
		}
		

		assert(nfree_extmem > 0);
  8004204d3b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204d40:	75 35                	jne    8004204d77 <check_page_free_list+0x52b>
  8004204d42:	48 b9 0a 7d 21 04 80 	movabs $0x8004217d0a,%rcx
  8004204d49:	00 00 00 
  8004204d4c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204d53:	00 00 00 
  8004204d56:	be e8 03 00 00       	mov    $0x3e8,%esi
  8004204d5b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204d62:	00 00 00 
  8004204d65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d6a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204d71:	00 00 00 
  8004204d74:	41 ff d0             	callq  *%r8
	}
  8004204d77:	c9                   	leaveq 
  8004204d78:	c3                   	retq   

0000008004204d79 <check_page_alloc>:
// and page_init()).
//

	static void
	check_page_alloc(void)
	{
  8004204d79:	55                   	push   %rbp
  8004204d7a:	48 89 e5             	mov    %rsp,%rbp
  8004204d7d:	48 83 ec 40          	sub    $0x40,%rsp

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.

		for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204d81:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204d88:	00 00 00 
  8004204d8b:	48 8b 00             	mov    (%rax),%rax
  8004204d8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204d92:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204d99:	eb 37                	jmp    8004204dd2 <check_page_alloc+0x59>
			memset(page2kva(pp0), 0x97, PGSIZE);
  8004204d9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d9f:	48 89 c7             	mov    %rax,%rdi
  8004204da2:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  8004204da9:	00 00 00 
  8004204dac:	ff d0                	callq  *%rax
  8004204dae:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204db3:	be 97 00 00 00       	mov    $0x97,%esi
  8004204db8:	48 89 c7             	mov    %rax,%rdi
  8004204dbb:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004204dc2:	00 00 00 
  8004204dc5:	ff d0                	callq  *%rax

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.

		for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204dc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204dcb:	48 8b 00             	mov    (%rax),%rax
  8004204dce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204dd2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204dd7:	75 c2                	jne    8004204d9b <check_page_alloc+0x22>
			memset(page2kva(pp0), 0x97, PGSIZE);
		}

		for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204dd9:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004204de0:	00 00 00 
  8004204de3:	48 8b 00             	mov    (%rax),%rax
  8004204de6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204dea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204df1:	e9 ec 01 00 00       	jmpq   8004204fe2 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
			assert(pp0 >= pages);
  8004204df6:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004204dfd:	00 00 00 
  8004204e00:	48 8b 00             	mov    (%rax),%rax
  8004204e03:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204e07:	73 35                	jae    8004204e3e <check_page_alloc+0xc5>
  8004204e09:	48 b9 1b 7d 21 04 80 	movabs $0x8004217d1b,%rcx
  8004204e10:	00 00 00 
  8004204e13:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204e1a:	00 00 00 
  8004204e1d:	be 05 04 00 00       	mov    $0x405,%esi
  8004204e22:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204e29:	00 00 00 
  8004204e2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e31:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204e38:	00 00 00 
  8004204e3b:	41 ff d0             	callq  *%r8
			assert(pp0 < pages + npages);
  8004204e3e:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  8004204e45:	00 00 00 
  8004204e48:	48 8b 10             	mov    (%rax),%rdx
  8004204e4b:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004204e52:	00 00 00 
  8004204e55:	48 8b 00             	mov    (%rax),%rax
  8004204e58:	48 c1 e0 04          	shl    $0x4,%rax
  8004204e5c:	48 01 d0             	add    %rdx,%rax
  8004204e5f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204e63:	77 35                	ja     8004204e9a <check_page_alloc+0x121>
  8004204e65:	48 b9 28 7d 21 04 80 	movabs $0x8004217d28,%rcx
  8004204e6c:	00 00 00 
  8004204e6f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204e76:	00 00 00 
  8004204e79:	be 06 04 00 00       	mov    $0x406,%esi
  8004204e7e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204e85:	00 00 00 
  8004204e88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e8d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204e94:	00 00 00 
  8004204e97:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
			assert(page2pa(pp0) != 0);
  8004204e9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e9e:	48 89 c7             	mov    %rax,%rdi
  8004204ea1:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204ea8:	00 00 00 
  8004204eab:	ff d0                	callq  *%rax
  8004204ead:	48 85 c0             	test   %rax,%rax
  8004204eb0:	75 35                	jne    8004204ee7 <check_page_alloc+0x16e>
  8004204eb2:	48 b9 3d 7d 21 04 80 	movabs $0x8004217d3d,%rcx
  8004204eb9:	00 00 00 
  8004204ebc:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204ec3:	00 00 00 
  8004204ec6:	be 09 04 00 00       	mov    $0x409,%esi
  8004204ecb:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204ed2:	00 00 00 
  8004204ed5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eda:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204ee1:	00 00 00 
  8004204ee4:	41 ff d0             	callq  *%r8
			assert(page2pa(pp0) != IOPHYSMEM);
  8004204ee7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204eeb:	48 89 c7             	mov    %rax,%rdi
  8004204eee:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204ef5:	00 00 00 
  8004204ef8:	ff d0                	callq  *%rax
  8004204efa:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204f00:	75 35                	jne    8004204f37 <check_page_alloc+0x1be>
  8004204f02:	48 b9 4f 7d 21 04 80 	movabs $0x8004217d4f,%rcx
  8004204f09:	00 00 00 
  8004204f0c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204f13:	00 00 00 
  8004204f16:	be 0a 04 00 00       	mov    $0x40a,%esi
  8004204f1b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204f22:	00 00 00 
  8004204f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f2a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204f31:	00 00 00 
  8004204f34:	41 ff d0             	callq  *%r8
			assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  8004204f37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f3b:	48 89 c7             	mov    %rax,%rdi
  8004204f3e:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204f45:	00 00 00 
  8004204f48:	ff d0                	callq  *%rax
  8004204f4a:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204f50:	75 35                	jne    8004204f87 <check_page_alloc+0x20e>
  8004204f52:	48 b9 70 7d 21 04 80 	movabs $0x8004217d70,%rcx
  8004204f59:	00 00 00 
  8004204f5c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204f63:	00 00 00 
  8004204f66:	be 0b 04 00 00       	mov    $0x40b,%esi
  8004204f6b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204f72:	00 00 00 
  8004204f75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f7a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204f81:	00 00 00 
  8004204f84:	41 ff d0             	callq  *%r8
			assert(page2pa(pp0) != EXTPHYSMEM);
  8004204f87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f8b:	48 89 c7             	mov    %rax,%rdi
  8004204f8e:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004204f95:	00 00 00 
  8004204f98:	ff d0                	callq  *%rax
  8004204f9a:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204fa0:	75 35                	jne    8004204fd7 <check_page_alloc+0x25e>
  8004204fa2:	48 b9 94 7d 21 04 80 	movabs $0x8004217d94,%rcx
  8004204fa9:	00 00 00 
  8004204fac:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004204fb3:	00 00 00 
  8004204fb6:	be 0c 04 00 00       	mov    $0x40c,%esi
  8004204fbb:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004204fc2:	00 00 00 
  8004204fc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fca:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004204fd1:	00 00 00 
  8004204fd4:	41 ff d0             	callq  *%r8

		for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
			memset(page2kva(pp0), 0x97, PGSIZE);
		}

		for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204fd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fdb:	48 8b 00             	mov    (%rax),%rax
  8004204fde:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204fe2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204fe7:	0f 85 09 fe ff ff    	jne    8004204df6 <check_page_alloc+0x7d>
			assert(page2pa(pp0) != IOPHYSMEM);
			assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
			assert(page2pa(pp0) != EXTPHYSMEM);
		}
	// should be able to allocate three pages
		pp0 = pp1 = pp2 = 0;
  8004204fed:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204ff4:	00 
  8004204ff5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ff9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204ffd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205001:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		assert((pp0 = page_alloc(0)));
  8004205005:	bf 00 00 00 00       	mov    $0x0,%edi
  800420500a:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004205011:	00 00 00 
  8004205014:	ff d0                	callq  *%rax
  8004205016:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420501a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420501f:	75 35                	jne    8004205056 <check_page_alloc+0x2dd>
  8004205021:	48 b9 af 7d 21 04 80 	movabs $0x8004217daf,%rcx
  8004205028:	00 00 00 
  800420502b:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205032:	00 00 00 
  8004205035:	be 10 04 00 00       	mov    $0x410,%esi
  800420503a:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205041:	00 00 00 
  8004205044:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205049:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205050:	00 00 00 
  8004205053:	41 ff d0             	callq  *%r8
		assert((pp1 = page_alloc(0)));
  8004205056:	bf 00 00 00 00       	mov    $0x0,%edi
  800420505b:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004205062:	00 00 00 
  8004205065:	ff d0                	callq  *%rax
  8004205067:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420506b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205070:	75 35                	jne    80042050a7 <check_page_alloc+0x32e>
  8004205072:	48 b9 c5 7d 21 04 80 	movabs $0x8004217dc5,%rcx
  8004205079:	00 00 00 
  800420507c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205083:	00 00 00 
  8004205086:	be 11 04 00 00       	mov    $0x411,%esi
  800420508b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205092:	00 00 00 
  8004205095:	b8 00 00 00 00       	mov    $0x0,%eax
  800420509a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042050a1:	00 00 00 
  80042050a4:	41 ff d0             	callq  *%r8
		assert((pp2 = page_alloc(0)));
  80042050a7:	bf 00 00 00 00       	mov    $0x0,%edi
  80042050ac:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042050b3:	00 00 00 
  80042050b6:	ff d0                	callq  *%rax
  80042050b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042050bc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042050c1:	75 35                	jne    80042050f8 <check_page_alloc+0x37f>
  80042050c3:	48 b9 db 7d 21 04 80 	movabs $0x8004217ddb,%rcx
  80042050ca:	00 00 00 
  80042050cd:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042050d4:	00 00 00 
  80042050d7:	be 12 04 00 00       	mov    $0x412,%esi
  80042050dc:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042050e3:	00 00 00 
  80042050e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050eb:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042050f2:	00 00 00 
  80042050f5:	41 ff d0             	callq  *%r8
		assert(pp0);
  80042050f8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042050fd:	75 35                	jne    8004205134 <check_page_alloc+0x3bb>
  80042050ff:	48 b9 f1 7d 21 04 80 	movabs $0x8004217df1,%rcx
  8004205106:	00 00 00 
  8004205109:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205110:	00 00 00 
  8004205113:	be 13 04 00 00       	mov    $0x413,%esi
  8004205118:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420511f:	00 00 00 
  8004205122:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205127:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420512e:	00 00 00 
  8004205131:	41 ff d0             	callq  *%r8
		assert(pp1 && pp1 != pp0);
  8004205134:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205139:	74 0a                	je     8004205145 <check_page_alloc+0x3cc>
  800420513b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420513f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205143:	75 35                	jne    800420517a <check_page_alloc+0x401>
  8004205145:	48 b9 f5 7d 21 04 80 	movabs $0x8004217df5,%rcx
  800420514c:	00 00 00 
  800420514f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205156:	00 00 00 
  8004205159:	be 14 04 00 00       	mov    $0x414,%esi
  800420515e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205165:	00 00 00 
  8004205168:	b8 00 00 00 00       	mov    $0x0,%eax
  800420516d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205174:	00 00 00 
  8004205177:	41 ff d0             	callq  *%r8
		assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420517a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420517f:	74 14                	je     8004205195 <check_page_alloc+0x41c>
  8004205181:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205185:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004205189:	74 0a                	je     8004205195 <check_page_alloc+0x41c>
  800420518b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420518f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205193:	75 35                	jne    80042051ca <check_page_alloc+0x451>
  8004205195:	48 b9 08 7e 21 04 80 	movabs $0x8004217e08,%rcx
  800420519c:	00 00 00 
  800420519f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042051a6:	00 00 00 
  80042051a9:	be 15 04 00 00       	mov    $0x415,%esi
  80042051ae:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042051b5:	00 00 00 
  80042051b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051bd:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042051c4:	00 00 00 
  80042051c7:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) < npages*PGSIZE);
  80042051ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051ce:	48 89 c7             	mov    %rax,%rdi
  80042051d1:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042051d8:	00 00 00 
  80042051db:	ff d0                	callq  *%rax
  80042051dd:	48 ba 78 57 37 04 80 	movabs $0x8004375778,%rdx
  80042051e4:	00 00 00 
  80042051e7:	48 8b 12             	mov    (%rdx),%rdx
  80042051ea:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042051ee:	48 39 d0             	cmp    %rdx,%rax
  80042051f1:	72 35                	jb     8004205228 <check_page_alloc+0x4af>
  80042051f3:	48 b9 28 7e 21 04 80 	movabs $0x8004217e28,%rcx
  80042051fa:	00 00 00 
  80042051fd:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205204:	00 00 00 
  8004205207:	be 16 04 00 00       	mov    $0x416,%esi
  800420520c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205213:	00 00 00 
  8004205216:	b8 00 00 00 00       	mov    $0x0,%eax
  800420521b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205222:	00 00 00 
  8004205225:	41 ff d0             	callq  *%r8
		assert(page2pa(pp1) < npages*PGSIZE);
  8004205228:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420522c:	48 89 c7             	mov    %rax,%rdi
  800420522f:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004205236:	00 00 00 
  8004205239:	ff d0                	callq  *%rax
  800420523b:	48 ba 78 57 37 04 80 	movabs $0x8004375778,%rdx
  8004205242:	00 00 00 
  8004205245:	48 8b 12             	mov    (%rdx),%rdx
  8004205248:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420524c:	48 39 d0             	cmp    %rdx,%rax
  800420524f:	72 35                	jb     8004205286 <check_page_alloc+0x50d>
  8004205251:	48 b9 45 7e 21 04 80 	movabs $0x8004217e45,%rcx
  8004205258:	00 00 00 
  800420525b:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205262:	00 00 00 
  8004205265:	be 17 04 00 00       	mov    $0x417,%esi
  800420526a:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205271:	00 00 00 
  8004205274:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205279:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205280:	00 00 00 
  8004205283:	41 ff d0             	callq  *%r8
		assert(page2pa(pp2) < npages*PGSIZE);
  8004205286:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420528a:	48 89 c7             	mov    %rax,%rdi
  800420528d:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004205294:	00 00 00 
  8004205297:	ff d0                	callq  *%rax
  8004205299:	48 ba 78 57 37 04 80 	movabs $0x8004375778,%rdx
  80042052a0:	00 00 00 
  80042052a3:	48 8b 12             	mov    (%rdx),%rdx
  80042052a6:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042052aa:	48 39 d0             	cmp    %rdx,%rax
  80042052ad:	72 35                	jb     80042052e4 <check_page_alloc+0x56b>
  80042052af:	48 b9 62 7e 21 04 80 	movabs $0x8004217e62,%rcx
  80042052b6:	00 00 00 
  80042052b9:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042052c0:	00 00 00 
  80042052c3:	be 18 04 00 00       	mov    $0x418,%esi
  80042052c8:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042052cf:	00 00 00 
  80042052d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052d7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042052de:	00 00 00 
  80042052e1:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
		fl = page_free_list;
  80042052e4:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  80042052eb:	00 00 00 
  80042052ee:	48 8b 00             	mov    (%rax),%rax
  80042052f1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		page_free_list = 0;
  80042052f5:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  80042052fc:	00 00 00 
  80042052ff:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
		assert(!page_alloc(0));
  8004205306:	bf 00 00 00 00       	mov    $0x0,%edi
  800420530b:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004205312:	00 00 00 
  8004205315:	ff d0                	callq  *%rax
  8004205317:	48 85 c0             	test   %rax,%rax
  800420531a:	74 35                	je     8004205351 <check_page_alloc+0x5d8>
  800420531c:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  8004205323:	00 00 00 
  8004205326:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420532d:	00 00 00 
  8004205330:	be 1f 04 00 00       	mov    $0x41f,%esi
  8004205335:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420533c:	00 00 00 
  800420533f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205344:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420534b:	00 00 00 
  800420534e:	41 ff d0             	callq  *%r8

	// free and re-allocate?
		page_free(pp0);
  8004205351:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205355:	48 89 c7             	mov    %rax,%rdi
  8004205358:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  800420535f:	00 00 00 
  8004205362:	ff d0                	callq  *%rax
		page_free(pp1);
  8004205364:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205368:	48 89 c7             	mov    %rax,%rdi
  800420536b:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004205372:	00 00 00 
  8004205375:	ff d0                	callq  *%rax
		page_free(pp2);
  8004205377:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420537b:	48 89 c7             	mov    %rax,%rdi
  800420537e:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004205385:	00 00 00 
  8004205388:	ff d0                	callq  *%rax
		pp0 = pp1 = pp2 = 0;
  800420538a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004205391:	00 
  8004205392:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205396:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420539a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420539e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		assert((pp0 = page_alloc(0)));
  80042053a2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042053a7:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042053ae:	00 00 00 
  80042053b1:	ff d0                	callq  *%rax
  80042053b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042053b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042053bc:	75 35                	jne    80042053f3 <check_page_alloc+0x67a>
  80042053be:	48 b9 af 7d 21 04 80 	movabs $0x8004217daf,%rcx
  80042053c5:	00 00 00 
  80042053c8:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042053cf:	00 00 00 
  80042053d2:	be 26 04 00 00       	mov    $0x426,%esi
  80042053d7:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042053de:	00 00 00 
  80042053e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053e6:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042053ed:	00 00 00 
  80042053f0:	41 ff d0             	callq  *%r8
		assert((pp1 = page_alloc(0)));
  80042053f3:	bf 00 00 00 00       	mov    $0x0,%edi
  80042053f8:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042053ff:	00 00 00 
  8004205402:	ff d0                	callq  *%rax
  8004205404:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205408:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420540d:	75 35                	jne    8004205444 <check_page_alloc+0x6cb>
  800420540f:	48 b9 c5 7d 21 04 80 	movabs $0x8004217dc5,%rcx
  8004205416:	00 00 00 
  8004205419:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205420:	00 00 00 
  8004205423:	be 27 04 00 00       	mov    $0x427,%esi
  8004205428:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420542f:	00 00 00 
  8004205432:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205437:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420543e:	00 00 00 
  8004205441:	41 ff d0             	callq  *%r8
		assert((pp2 = page_alloc(0)));
  8004205444:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205449:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004205450:	00 00 00 
  8004205453:	ff d0                	callq  *%rax
  8004205455:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004205459:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420545e:	75 35                	jne    8004205495 <check_page_alloc+0x71c>
  8004205460:	48 b9 db 7d 21 04 80 	movabs $0x8004217ddb,%rcx
  8004205467:	00 00 00 
  800420546a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205471:	00 00 00 
  8004205474:	be 28 04 00 00       	mov    $0x428,%esi
  8004205479:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205480:	00 00 00 
  8004205483:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205488:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420548f:	00 00 00 
  8004205492:	41 ff d0             	callq  *%r8
		assert(pp0);
  8004205495:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420549a:	75 35                	jne    80042054d1 <check_page_alloc+0x758>
  800420549c:	48 b9 f1 7d 21 04 80 	movabs $0x8004217df1,%rcx
  80042054a3:	00 00 00 
  80042054a6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042054ad:	00 00 00 
  80042054b0:	be 29 04 00 00       	mov    $0x429,%esi
  80042054b5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042054bc:	00 00 00 
  80042054bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054c4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042054cb:	00 00 00 
  80042054ce:	41 ff d0             	callq  *%r8
		assert(pp1 && pp1 != pp0);
  80042054d1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042054d6:	74 0a                	je     80042054e2 <check_page_alloc+0x769>
  80042054d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042054dc:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042054e0:	75 35                	jne    8004205517 <check_page_alloc+0x79e>
  80042054e2:	48 b9 f5 7d 21 04 80 	movabs $0x8004217df5,%rcx
  80042054e9:	00 00 00 
  80042054ec:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042054f3:	00 00 00 
  80042054f6:	be 2a 04 00 00       	mov    $0x42a,%esi
  80042054fb:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205502:	00 00 00 
  8004205505:	b8 00 00 00 00       	mov    $0x0,%eax
  800420550a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205511:	00 00 00 
  8004205514:	41 ff d0             	callq  *%r8
		assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205517:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420551c:	74 14                	je     8004205532 <check_page_alloc+0x7b9>
  800420551e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205522:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004205526:	74 0a                	je     8004205532 <check_page_alloc+0x7b9>
  8004205528:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420552c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205530:	75 35                	jne    8004205567 <check_page_alloc+0x7ee>
  8004205532:	48 b9 08 7e 21 04 80 	movabs $0x8004217e08,%rcx
  8004205539:	00 00 00 
  800420553c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205543:	00 00 00 
  8004205546:	be 2b 04 00 00       	mov    $0x42b,%esi
  800420554b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205552:	00 00 00 
  8004205555:	b8 00 00 00 00       	mov    $0x0,%eax
  800420555a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205561:	00 00 00 
  8004205564:	41 ff d0             	callq  *%r8
		assert(!page_alloc(0));
  8004205567:	bf 00 00 00 00       	mov    $0x0,%edi
  800420556c:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004205573:	00 00 00 
  8004205576:	ff d0                	callq  *%rax
  8004205578:	48 85 c0             	test   %rax,%rax
  800420557b:	74 35                	je     80042055b2 <check_page_alloc+0x839>
  800420557d:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  8004205584:	00 00 00 
  8004205587:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420558e:	00 00 00 
  8004205591:	be 2c 04 00 00       	mov    $0x42c,%esi
  8004205596:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420559d:	00 00 00 
  80042055a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055a5:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042055ac:	00 00 00 
  80042055af:	41 ff d0             	callq  *%r8

	// test flags
		memset(page2kva(pp0), 1, PGSIZE);
  80042055b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055b6:	48 89 c7             	mov    %rax,%rdi
  80042055b9:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  80042055c0:	00 00 00 
  80042055c3:	ff d0                	callq  *%rax
  80042055c5:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042055ca:	be 01 00 00 00       	mov    $0x1,%esi
  80042055cf:	48 89 c7             	mov    %rax,%rdi
  80042055d2:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042055d9:	00 00 00 
  80042055dc:	ff d0                	callq  *%rax
		page_free(pp0);
  80042055de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055e2:	48 89 c7             	mov    %rax,%rdi
  80042055e5:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  80042055ec:	00 00 00 
  80042055ef:	ff d0                	callq  *%rax
		assert((pp = page_alloc(ALLOC_ZERO)));
  80042055f1:	bf 01 00 00 00       	mov    $0x1,%edi
  80042055f6:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042055fd:	00 00 00 
  8004205600:	ff d0                	callq  *%rax
  8004205602:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205606:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420560b:	75 35                	jne    8004205642 <check_page_alloc+0x8c9>
  800420560d:	48 b9 8e 7e 21 04 80 	movabs $0x8004217e8e,%rcx
  8004205614:	00 00 00 
  8004205617:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420561e:	00 00 00 
  8004205621:	be 31 04 00 00       	mov    $0x431,%esi
  8004205626:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420562d:	00 00 00 
  8004205630:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205635:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420563c:	00 00 00 
  800420563f:	41 ff d0             	callq  *%r8
		assert(pp && pp0 == pp);
  8004205642:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205647:	74 0a                	je     8004205653 <check_page_alloc+0x8da>
  8004205649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420564d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205651:	74 35                	je     8004205688 <check_page_alloc+0x90f>
  8004205653:	48 b9 ac 7e 21 04 80 	movabs $0x8004217eac,%rcx
  800420565a:	00 00 00 
  800420565d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205664:	00 00 00 
  8004205667:	be 32 04 00 00       	mov    $0x432,%esi
  800420566c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205673:	00 00 00 
  8004205676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420567b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205682:	00 00 00 
  8004205685:	41 ff d0             	callq  *%r8
		c = page2kva(pp);
  8004205688:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420568c:	48 89 c7             	mov    %rax,%rdi
  800420568f:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  8004205696:	00 00 00 
  8004205699:	ff d0                	callq  *%rax
  800420569b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		for (i = 0; i < PGSIZE; i++)
  800420569f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042056a6:	eb 4d                	jmp    80042056f5 <check_page_alloc+0x97c>
			assert(c[i] == 0);
  80042056a8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042056ab:	48 63 d0             	movslq %eax,%rdx
  80042056ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056b2:	48 01 d0             	add    %rdx,%rax
  80042056b5:	0f b6 00             	movzbl (%rax),%eax
  80042056b8:	84 c0                	test   %al,%al
  80042056ba:	74 35                	je     80042056f1 <check_page_alloc+0x978>
  80042056bc:	48 b9 bc 7e 21 04 80 	movabs $0x8004217ebc,%rcx
  80042056c3:	00 00 00 
  80042056c6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042056cd:	00 00 00 
  80042056d0:	be 35 04 00 00       	mov    $0x435,%esi
  80042056d5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042056dc:	00 00 00 
  80042056df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056e4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042056eb:	00 00 00 
  80042056ee:	41 ff d0             	callq  *%r8
		memset(page2kva(pp0), 1, PGSIZE);
		page_free(pp0);
		assert((pp = page_alloc(ALLOC_ZERO)));
		assert(pp && pp0 == pp);
		c = page2kva(pp);
		for (i = 0; i < PGSIZE; i++)
  80042056f1:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042056f5:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042056fc:	7e aa                	jle    80042056a8 <check_page_alloc+0x92f>
			assert(c[i] == 0);

	// give free list back
		page_free_list = fl;
  80042056fe:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004205705:	00 00 00 
  8004205708:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420570c:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
		page_free(pp0);
  800420570f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205713:	48 89 c7             	mov    %rax,%rdi
  8004205716:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  800420571d:	00 00 00 
  8004205720:	ff d0                	callq  *%rax
		page_free(pp1);
  8004205722:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205726:	48 89 c7             	mov    %rax,%rdi
  8004205729:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004205730:	00 00 00 
  8004205733:	ff d0                	callq  *%rax
		page_free(pp2);
  8004205735:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205739:	48 89 c7             	mov    %rax,%rdi
  800420573c:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004205743:	00 00 00 
  8004205746:	ff d0                	callq  *%rax

		cprintf("check_page_alloc() succeeded!\n");
  8004205748:	48 bf c8 7e 21 04 80 	movabs $0x8004217ec8,%rdi
  800420574f:	00 00 00 
  8004205752:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205757:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420575e:	00 00 00 
  8004205761:	ff d2                	callq  *%rdx
	}
  8004205763:	c9                   	leaveq 
  8004205764:	c3                   	retq   

0000008004205765 <check_boot_pml4e>:
//


	static void
	check_boot_pml4e(pml4e_t *pml4e)
	{
  8004205765:	55                   	push   %rbp
  8004205766:	48 89 e5             	mov    %rsp,%rbp
  8004205769:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004205770:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
		uint64_t i, n;

		pml4e = boot_pml4e;
  8004205777:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420577e:	00 00 00 
  8004205781:	48 8b 00             	mov    (%rax),%rax
  8004205784:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// check pages array
		n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004205788:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420578f:	00 
  8004205790:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205797:	00 00 00 
  800420579a:	48 8b 00             	mov    (%rax),%rax
  800420579d:	48 c1 e0 04          	shl    $0x4,%rax
  80042057a1:	48 89 c2             	mov    %rax,%rdx
  80042057a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042057a8:	48 01 d0             	add    %rdx,%rax
  80042057ab:	48 83 e8 01          	sub    $0x1,%rax
  80042057af:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042057b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042057b7:	ba 00 00 00 00       	mov    $0x0,%edx
  80042057bc:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042057c0:	48 89 d0             	mov    %rdx,%rax
  80042057c3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042057c7:	48 29 c2             	sub    %rax,%rdx
  80042057ca:	48 89 d0             	mov    %rdx,%rax
  80042057cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		for (i = 0; i < n; i += PGSIZE) {
  80042057d1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042057d8:	00 
  80042057d9:	e9 d4 00 00 00       	jmpq   80042058b2 <check_boot_pml4e+0x14d>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
			assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  80042057de:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  80042057e5:	00 00 00 
  80042057e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042057ec:	48 01 c2             	add    %rax,%rdx
  80042057ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042057f3:	48 89 d6             	mov    %rdx,%rsi
  80042057f6:	48 89 c7             	mov    %rax,%rdi
  80042057f9:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004205800:	00 00 00 
  8004205803:	ff d0                	callq  *%rax
  8004205805:	48 ba 80 57 37 04 80 	movabs $0x8004375780,%rdx
  800420580c:	00 00 00 
  800420580f:	48 8b 12             	mov    (%rdx),%rdx
  8004205812:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004205816:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800420581d:	00 00 00 
  8004205820:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004205824:	77 32                	ja     8004205858 <check_boot_pml4e+0xf3>
  8004205826:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420582a:	48 89 c1             	mov    %rax,%rcx
  800420582d:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  8004205834:	00 00 00 
  8004205837:	be 57 04 00 00       	mov    $0x457,%esi
  800420583c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205843:	00 00 00 
  8004205846:	b8 00 00 00 00       	mov    $0x0,%eax
  800420584b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205852:	00 00 00 
  8004205855:	41 ff d0             	callq  *%r8
  8004205858:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800420585f:	ff ff ff 
  8004205862:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004205866:	48 01 d1             	add    %rdx,%rcx
  8004205869:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420586d:	48 01 ca             	add    %rcx,%rdx
  8004205870:	48 39 d0             	cmp    %rdx,%rax
  8004205873:	74 35                	je     80042058aa <check_boot_pml4e+0x145>
  8004205875:	48 b9 e8 7e 21 04 80 	movabs $0x8004217ee8,%rcx
  800420587c:	00 00 00 
  800420587f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205886:	00 00 00 
  8004205889:	be 57 04 00 00       	mov    $0x457,%esi
  800420588e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205895:	00 00 00 
  8004205898:	b8 00 00 00 00       	mov    $0x0,%eax
  800420589d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042058a4:	00 00 00 
  80042058a7:	41 ff d0             	callq  *%r8

		pml4e = boot_pml4e;

	// check pages array
		n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
		for (i = 0; i < n; i += PGSIZE) {
  80042058aa:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042058b1:	00 
  80042058b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042058b6:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042058ba:	0f 82 1e ff ff ff    	jb     80042057de <check_boot_pml4e+0x79>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
			assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
		}

	// check envs array (new test for lab 3)
		n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  80042058c0:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  80042058c7:	00 
  80042058c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042058cc:	48 05 ff bf 05 00    	add    $0x5bfff,%rax
  80042058d2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042058d6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042058da:	ba 00 00 00 00       	mov    $0x0,%edx
  80042058df:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042058e3:	48 89 d0             	mov    %rdx,%rax
  80042058e6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042058ea:	48 29 c2             	sub    %rax,%rdx
  80042058ed:	48 89 d0             	mov    %rdx,%rax
  80042058f0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		for (i = 0; i < n; i += PGSIZE)
  80042058f4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042058fb:	00 
  80042058fc:	e9 d4 00 00 00       	jmpq   80042059d5 <check_boot_pml4e+0x270>
			assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004205901:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004205908:	00 00 00 
  800420590b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420590f:	48 01 c2             	add    %rax,%rdx
  8004205912:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205916:	48 89 d6             	mov    %rdx,%rsi
  8004205919:	48 89 c7             	mov    %rax,%rdi
  800420591c:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004205923:	00 00 00 
  8004205926:	ff d0                	callq  *%rax
  8004205928:	48 ba 58 42 37 04 80 	movabs $0x8004374258,%rdx
  800420592f:	00 00 00 
  8004205932:	48 8b 12             	mov    (%rdx),%rdx
  8004205935:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004205939:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205940:	00 00 00 
  8004205943:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004205947:	77 32                	ja     800420597b <check_boot_pml4e+0x216>
  8004205949:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420594d:	48 89 c1             	mov    %rax,%rcx
  8004205950:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  8004205957:	00 00 00 
  800420595a:	be 5d 04 00 00       	mov    $0x45d,%esi
  800420595f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205966:	00 00 00 
  8004205969:	b8 00 00 00 00       	mov    $0x0,%eax
  800420596e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205975:	00 00 00 
  8004205978:	41 ff d0             	callq  *%r8
  800420597b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205982:	ff ff ff 
  8004205985:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004205989:	48 01 d1             	add    %rdx,%rcx
  800420598c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205990:	48 01 ca             	add    %rcx,%rdx
  8004205993:	48 39 d0             	cmp    %rdx,%rax
  8004205996:	74 35                	je     80042059cd <check_boot_pml4e+0x268>
  8004205998:	48 b9 20 7f 21 04 80 	movabs $0x8004217f20,%rcx
  800420599f:	00 00 00 
  80042059a2:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042059a9:	00 00 00 
  80042059ac:	be 5d 04 00 00       	mov    $0x45d,%esi
  80042059b1:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042059b8:	00 00 00 
  80042059bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059c0:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042059c7:	00 00 00 
  80042059ca:	41 ff d0             	callq  *%r8
			assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
		}

	// check envs array (new test for lab 3)
		n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
		for (i = 0; i < n; i += PGSIZE)
  80042059cd:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042059d4:	00 
  80042059d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059d9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042059dd:	0f 82 1e ff ff ff    	jb     8004205901 <check_boot_pml4e+0x19c>
			assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
		for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042059e3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042059ea:	00 
  80042059eb:	eb 6a                	jmp    8004205a57 <check_boot_pml4e+0x2f2>
			assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042059ed:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042059f4:	00 00 00 
  80042059f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042059fb:	48 01 c2             	add    %rax,%rdx
  80042059fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205a02:	48 89 d6             	mov    %rdx,%rsi
  8004205a05:	48 89 c7             	mov    %rax,%rdi
  8004205a08:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004205a0f:	00 00 00 
  8004205a12:	ff d0                	callq  *%rax
  8004205a14:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205a18:	74 35                	je     8004205a4f <check_boot_pml4e+0x2ea>
  8004205a1a:	48 b9 58 7f 21 04 80 	movabs $0x8004217f58,%rcx
  8004205a21:	00 00 00 
  8004205a24:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205a2b:	00 00 00 
  8004205a2e:	be 61 04 00 00       	mov    $0x461,%esi
  8004205a33:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205a3a:	00 00 00 
  8004205a3d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a42:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205a49:	00 00 00 
  8004205a4c:	41 ff d0             	callq  *%r8
		n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
		for (i = 0; i < n; i += PGSIZE)
			assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
		for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205a4f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205a56:	00 
  8004205a57:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205a5e:	00 00 00 
  8004205a61:	48 8b 00             	mov    (%rax),%rax
  8004205a64:	48 c1 e0 0c          	shl    $0xc,%rax
  8004205a68:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004205a6c:	0f 87 7b ff ff ff    	ja     80042059ed <check_boot_pml4e+0x288>
			assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
		
	// (updated in lab 4 to check per-CPU kernel stacks)
		for (n = 0; n < NCPU; n++) {
  8004205a72:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004205a79:	00 
  8004205a7a:	e9 a1 01 00 00       	jmpq   8004205c20 <check_boot_pml4e+0x4bb>
			uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205a7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205a83:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205a87:	48 89 d0             	mov    %rdx,%rax
  8004205a8a:	48 01 c0             	add    %rax,%rax
  8004205a8d:	48 01 d0             	add    %rdx,%rax
  8004205a90:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205a94:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205a9b:	00 00 00 
  8004205a9e:	48 29 c2             	sub    %rax,%rdx
  8004205aa1:	48 89 d0             	mov    %rdx,%rax
  8004205aa4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
			for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205aa8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205aaf:	00 
  8004205ab0:	e9 e0 00 00 00       	jmpq   8004205b95 <check_boot_pml4e+0x430>
				assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205ab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205ab9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205abd:	48 01 d0             	add    %rdx,%rax
  8004205ac0:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004205ac7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205acb:	48 89 d6             	mov    %rdx,%rsi
  8004205ace:	48 89 c7             	mov    %rax,%rdi
  8004205ad1:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004205ad8:	00 00 00 
  8004205adb:	ff d0                	callq  *%rax
  8004205add:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004205ae1:	48 89 d1             	mov    %rdx,%rcx
  8004205ae4:	48 c1 e1 10          	shl    $0x10,%rcx
  8004205ae8:	48 ba 00 80 37 04 80 	movabs $0x8004378000,%rdx
  8004205aef:	00 00 00 
  8004205af2:	48 01 ca             	add    %rcx,%rdx
  8004205af5:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004205af9:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205b00:	00 00 00 
  8004205b03:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004205b07:	77 32                	ja     8004205b3b <check_boot_pml4e+0x3d6>
  8004205b09:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205b0d:	48 89 c1             	mov    %rax,%rcx
  8004205b10:	48 ba 60 7a 21 04 80 	movabs $0x8004217a60,%rdx
  8004205b17:	00 00 00 
  8004205b1a:	be 6a 04 00 00       	mov    $0x46a,%esi
  8004205b1f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205b26:	00 00 00 
  8004205b29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b2e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205b35:	00 00 00 
  8004205b38:	41 ff d0             	callq  *%r8
  8004205b3b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205b42:	ff ff ff 
  8004205b45:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004205b49:	48 01 d1             	add    %rdx,%rcx
  8004205b4c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205b50:	48 01 ca             	add    %rcx,%rdx
  8004205b53:	48 39 d0             	cmp    %rdx,%rax
  8004205b56:	74 35                	je     8004205b8d <check_boot_pml4e+0x428>
  8004205b58:	48 b9 80 7f 21 04 80 	movabs $0x8004217f80,%rcx
  8004205b5f:	00 00 00 
  8004205b62:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205b69:	00 00 00 
  8004205b6c:	be 6a 04 00 00       	mov    $0x46a,%esi
  8004205b71:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205b78:	00 00 00 
  8004205b7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b80:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205b87:	00 00 00 
  8004205b8a:	41 ff d0             	callq  *%r8
	// check kernel stack
		
	// (updated in lab 4 to check per-CPU kernel stacks)
		for (n = 0; n < NCPU; n++) {
			uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
			for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205b8d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205b94:	00 
  8004205b95:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004205b9c:	00 
  8004205b9d:	0f 86 12 ff ff ff    	jbe    8004205ab5 <check_boot_pml4e+0x350>
				assert(check_va2pa(pml4e, base + KSTKGAP + i)
					== PADDR(percpu_kstacks[n]) + i);
			for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205ba3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205baa:	00 
  8004205bab:	eb 64                	jmp    8004205c11 <check_boot_pml4e+0x4ac>
				assert(check_va2pa(pml4e, base + i) == ~0);
  8004205bad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205bb1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205bb5:	48 01 c2             	add    %rax,%rdx
  8004205bb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205bbc:	48 89 d6             	mov    %rdx,%rsi
  8004205bbf:	48 89 c7             	mov    %rax,%rdi
  8004205bc2:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004205bc9:	00 00 00 
  8004205bcc:	ff d0                	callq  *%rax
  8004205bce:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205bd2:	74 35                	je     8004205c09 <check_boot_pml4e+0x4a4>
  8004205bd4:	48 b9 c8 7f 21 04 80 	movabs $0x8004217fc8,%rcx
  8004205bdb:	00 00 00 
  8004205bde:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205be5:	00 00 00 
  8004205be8:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004205bed:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205bf4:	00 00 00 
  8004205bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bfc:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205c03:	00 00 00 
  8004205c06:	41 ff d0             	callq  *%r8
		for (n = 0; n < NCPU; n++) {
			uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
			for (i = 0; i < KSTKSIZE; i += PGSIZE)
				assert(check_va2pa(pml4e, base + KSTKGAP + i)
					== PADDR(percpu_kstacks[n]) + i);
			for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205c09:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205c10:	00 
  8004205c11:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004205c18:	00 
  8004205c19:	76 92                	jbe    8004205bad <check_boot_pml4e+0x448>
			assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
		
	// (updated in lab 4 to check per-CPU kernel stacks)
		for (n = 0; n < NCPU; n++) {
  8004205c1b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004205c20:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  8004205c25:	0f 86 54 fe ff ff    	jbe    8004205a7f <check_boot_pml4e+0x31a>
	// 	assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
	// }
	// assert(check_va2pa(pml4e, KSTACKTOP - KSTKSIZE - 1 )  == ~0);
		

		pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004205c2b:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004205c32:	00 00 00 
  8004205c35:	48 8b 00             	mov    (%rax),%rax
  8004205c38:	48 83 c0 08          	add    $0x8,%rax
  8004205c3c:	48 8b 00             	mov    (%rax),%rax
  8004205c3f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205c45:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004205c49:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205c4d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205c51:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004205c54:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004205c57:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205c5e:	00 00 00 
  8004205c61:	48 8b 00             	mov    (%rax),%rax
  8004205c64:	48 39 c2             	cmp    %rax,%rdx
  8004205c67:	72 32                	jb     8004205c9b <check_boot_pml4e+0x536>
  8004205c69:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205c6d:	48 89 c1             	mov    %rax,%rcx
  8004205c70:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004205c77:	00 00 00 
  8004205c7a:	be 75 04 00 00       	mov    $0x475,%esi
  8004205c7f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205c86:	00 00 00 
  8004205c89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c8e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205c95:	00 00 00 
  8004205c98:	41 ff d0             	callq  *%r8
  8004205c9b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205ca2:	00 00 00 
  8004205ca5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205ca9:	48 01 d0             	add    %rdx,%rax
  8004205cac:	48 89 45 90          	mov    %rax,-0x70(%rbp)
		pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205cb0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205cb4:	48 8b 00             	mov    (%rax),%rax
  8004205cb7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205cbd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004205cc1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205cc5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205cc9:	89 45 84             	mov    %eax,-0x7c(%rbp)
  8004205ccc:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004205ccf:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205cd6:	00 00 00 
  8004205cd9:	48 8b 00             	mov    (%rax),%rax
  8004205cdc:	48 39 c2             	cmp    %rax,%rdx
  8004205cdf:	72 32                	jb     8004205d13 <check_boot_pml4e+0x5ae>
  8004205ce1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205ce5:	48 89 c1             	mov    %rax,%rcx
  8004205ce8:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004205cef:	00 00 00 
  8004205cf2:	be 76 04 00 00       	mov    $0x476,%esi
  8004205cf7:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205cfe:	00 00 00 
  8004205d01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d06:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205d0d:	00 00 00 
  8004205d10:	41 ff d0             	callq  *%r8
  8004205d13:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205d1a:	00 00 00 
  8004205d1d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205d21:	48 01 d0             	add    %rdx,%rax
  8004205d24:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
		for (i = 0; i < NPDENTRIES; i++) {
  8004205d2b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205d32:	00 
  8004205d33:	e9 50 01 00 00       	jmpq   8004205e88 <check_boot_pml4e+0x723>
			switch (i) {
  8004205d38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205d3c:	48 83 f8 04          	cmp    $0x4,%rax
  8004205d40:	72 67                	jb     8004205da9 <check_boot_pml4e+0x644>
  8004205d42:	48 83 f8 05          	cmp    $0x5,%rax
  8004205d46:	76 06                	jbe    8004205d4e <check_boot_pml4e+0x5e9>
  8004205d48:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004205d4c:	75 5b                	jne    8004205da9 <check_boot_pml4e+0x644>
			//case PDX(UVPT):
				case PDX(KSTACKTOP - 1):
				case PDX(UPAGES):
				case PDX(UENVS):
				assert(pgdir[i] & PTE_P);
  8004205d4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205d52:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205d59:	00 
  8004205d5a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205d61:	48 01 d0             	add    %rdx,%rax
  8004205d64:	48 8b 00             	mov    (%rax),%rax
  8004205d67:	83 e0 01             	and    $0x1,%eax
  8004205d6a:	48 85 c0             	test   %rax,%rax
  8004205d6d:	75 35                	jne    8004205da4 <check_boot_pml4e+0x63f>
  8004205d6f:	48 b9 eb 7f 21 04 80 	movabs $0x8004217feb,%rcx
  8004205d76:	00 00 00 
  8004205d79:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205d80:	00 00 00 
  8004205d83:	be 7e 04 00 00       	mov    $0x47e,%esi
  8004205d88:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205d8f:	00 00 00 
  8004205d92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d97:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205d9e:	00 00 00 
  8004205da1:	41 ff d0             	callq  *%r8
				break;
  8004205da4:	e9 da 00 00 00       	jmpq   8004205e83 <check_boot_pml4e+0x71e>
				default:
				if (i >= PDX(KERNBASE)) {
  8004205da9:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205dae:	0f 86 ce 00 00 00    	jbe    8004205e82 <check_boot_pml4e+0x71d>
					if (pgdir[i] & PTE_P)
  8004205db4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205db8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205dbf:	00 
  8004205dc0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205dc7:	48 01 d0             	add    %rdx,%rax
  8004205dca:	48 8b 00             	mov    (%rax),%rax
  8004205dcd:	83 e0 01             	and    $0x1,%eax
  8004205dd0:	48 85 c0             	test   %rax,%rax
  8004205dd3:	74 5a                	je     8004205e2f <check_boot_pml4e+0x6ca>
						assert(pgdir[i] & PTE_W);
  8004205dd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205dd9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205de0:	00 
  8004205de1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205de8:	48 01 d0             	add    %rdx,%rax
  8004205deb:	48 8b 00             	mov    (%rax),%rax
  8004205dee:	83 e0 02             	and    $0x2,%eax
  8004205df1:	48 85 c0             	test   %rax,%rax
  8004205df4:	0f 85 88 00 00 00    	jne    8004205e82 <check_boot_pml4e+0x71d>
  8004205dfa:	48 b9 fc 7f 21 04 80 	movabs $0x8004217ffc,%rcx
  8004205e01:	00 00 00 
  8004205e04:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205e0b:	00 00 00 
  8004205e0e:	be 83 04 00 00       	mov    $0x483,%esi
  8004205e13:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205e1a:	00 00 00 
  8004205e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e22:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205e29:	00 00 00 
  8004205e2c:	41 ff d0             	callq  *%r8
					else
						assert(pgdir[i] == 0);
  8004205e2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205e33:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205e3a:	00 
  8004205e3b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205e42:	48 01 d0             	add    %rdx,%rax
  8004205e45:	48 8b 00             	mov    (%rax),%rax
  8004205e48:	48 85 c0             	test   %rax,%rax
  8004205e4b:	74 35                	je     8004205e82 <check_boot_pml4e+0x71d>
  8004205e4d:	48 b9 0d 80 21 04 80 	movabs $0x800421800d,%rcx
  8004205e54:	00 00 00 
  8004205e57:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004205e5e:	00 00 00 
  8004205e61:	be 85 04 00 00       	mov    $0x485,%esi
  8004205e66:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205e6d:	00 00 00 
  8004205e70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e75:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205e7c:	00 00 00 
  8004205e7f:	41 ff d0             	callq  *%r8
				} 
				break;
  8004205e82:	90                   	nop
		

		pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
		pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
		for (i = 0; i < NPDENTRIES; i++) {
  8004205e83:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205e88:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205e8f:	00 
  8004205e90:	0f 86 a2 fe ff ff    	jbe    8004205d38 <check_boot_pml4e+0x5d3>
						assert(pgdir[i] == 0);
				} 
				break;
			}
		}
		cprintf("check_boot_pml4e() succeeded!\n");
  8004205e96:	48 bf 20 80 21 04 80 	movabs $0x8004218020,%rdi
  8004205e9d:	00 00 00 
  8004205ea0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ea5:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004205eac:	00 00 00 
  8004205eaf:	ff d2                	callq  *%rdx
	}
  8004205eb1:	c9                   	leaveq 
  8004205eb2:	c3                   	retq   

0000008004205eb3 <check_va2pa>:
// the check_boot_pml4e() function; it shouldn't be used elsewhere.


	static physaddr_t
	check_va2pa(pml4e_t *pml4e, uintptr_t va)
	{
  8004205eb3:	55                   	push   %rbp
  8004205eb4:	48 89 e5             	mov    %rsp,%rbp
  8004205eb7:	48 83 ec 60          	sub    $0x60,%rsp
  8004205ebb:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205ebf:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
		pte_t *pte;
		pdpe_t *pdpe;
		pde_t *pde;
	// cprintf("%x", va);
		pml4e = &pml4e[PML4(va)];
  8004205ec3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205ec7:	48 c1 e8 27          	shr    $0x27,%rax
  8004205ecb:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205ed0:	48 c1 e0 03          	shl    $0x3,%rax
  8004205ed4:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
		if(!(*pml4e & PTE_P))
  8004205ed8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205edc:	48 8b 00             	mov    (%rax),%rax
  8004205edf:	83 e0 01             	and    $0x1,%eax
  8004205ee2:	48 85 c0             	test   %rax,%rax
  8004205ee5:	75 0c                	jne    8004205ef3 <check_va2pa+0x40>
			return ~0;
  8004205ee7:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205eee:	e9 38 02 00 00       	jmpq   800420612b <check_va2pa+0x278>
		pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205ef3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205ef7:	48 8b 00             	mov    (%rax),%rax
  8004205efa:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205f00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205f04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205f08:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205f0c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004205f0f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004205f12:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205f19:	00 00 00 
  8004205f1c:	48 8b 00             	mov    (%rax),%rax
  8004205f1f:	48 39 c2             	cmp    %rax,%rdx
  8004205f22:	72 32                	jb     8004205f56 <check_va2pa+0xa3>
  8004205f24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205f28:	48 89 c1             	mov    %rax,%rcx
  8004205f2b:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004205f32:	00 00 00 
  8004205f35:	be 9f 04 00 00       	mov    $0x49f,%esi
  8004205f3a:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004205f41:	00 00 00 
  8004205f44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f49:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004205f50:	00 00 00 
  8004205f53:	41 ff d0             	callq  *%r8
  8004205f56:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205f5d:	00 00 00 
  8004205f60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205f64:	48 01 d0             	add    %rdx,%rax
  8004205f67:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
		if (!(pdpe[PDPE(va)] & PTE_P))
  8004205f6b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205f6f:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205f73:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205f78:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205f7f:	00 
  8004205f80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205f84:	48 01 d0             	add    %rdx,%rax
  8004205f87:	48 8b 00             	mov    (%rax),%rax
  8004205f8a:	83 e0 01             	and    $0x1,%eax
  8004205f8d:	48 85 c0             	test   %rax,%rax
  8004205f90:	75 0c                	jne    8004205f9e <check_va2pa+0xeb>
			return ~0;
  8004205f92:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205f99:	e9 8d 01 00 00       	jmpq   800420612b <check_va2pa+0x278>
		pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205f9e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205fa2:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205fa6:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205fab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205fb2:	00 
  8004205fb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205fb7:	48 01 d0             	add    %rdx,%rax
  8004205fba:	48 8b 00             	mov    (%rax),%rax
  8004205fbd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205fc3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205fc7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205fcb:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205fcf:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205fd2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205fd5:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004205fdc:	00 00 00 
  8004205fdf:	48 8b 00             	mov    (%rax),%rax
  8004205fe2:	48 39 c2             	cmp    %rax,%rdx
  8004205fe5:	72 32                	jb     8004206019 <check_va2pa+0x166>
  8004205fe7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205feb:	48 89 c1             	mov    %rax,%rcx
  8004205fee:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004205ff5:	00 00 00 
  8004205ff8:	be a3 04 00 00       	mov    $0x4a3,%esi
  8004205ffd:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206004:	00 00 00 
  8004206007:	b8 00 00 00 00       	mov    $0x0,%eax
  800420600c:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206013:	00 00 00 
  8004206016:	41 ff d0             	callq  *%r8
  8004206019:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206020:	00 00 00 
  8004206023:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206027:	48 01 d0             	add    %rdx,%rax
  800420602a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
		pde = &pde[PDX(va)];
  800420602e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004206032:	48 c1 e8 15          	shr    $0x15,%rax
  8004206036:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420603b:	48 c1 e0 03          	shl    $0x3,%rax
  800420603f:	48 01 45 d0          	add    %rax,-0x30(%rbp)
		if (!(*pde & PTE_P))
  8004206043:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206047:	48 8b 00             	mov    (%rax),%rax
  800420604a:	83 e0 01             	and    $0x1,%eax
  800420604d:	48 85 c0             	test   %rax,%rax
  8004206050:	75 0c                	jne    800420605e <check_va2pa+0x1ab>
			return ~0;
  8004206052:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004206059:	e9 cd 00 00 00       	jmpq   800420612b <check_va2pa+0x278>
		pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  800420605e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206062:	48 8b 00             	mov    (%rax),%rax
  8004206065:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420606b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420606f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206073:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206077:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420607a:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420607d:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004206084:	00 00 00 
  8004206087:	48 8b 00             	mov    (%rax),%rax
  800420608a:	48 39 c2             	cmp    %rax,%rdx
  800420608d:	72 32                	jb     80042060c1 <check_va2pa+0x20e>
  800420608f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206093:	48 89 c1             	mov    %rax,%rcx
  8004206096:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  800420609d:	00 00 00 
  80042060a0:	be a8 04 00 00       	mov    $0x4a8,%esi
  80042060a5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042060ac:	00 00 00 
  80042060af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060b4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042060bb:	00 00 00 
  80042060be:	41 ff d0             	callq  *%r8
  80042060c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042060c8:	00 00 00 
  80042060cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042060cf:	48 01 d0             	add    %rdx,%rax
  80042060d2:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
		if (!(pte[PTX(va)] & PTE_P))
  80042060d6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042060da:	48 c1 e8 0c          	shr    $0xc,%rax
  80042060de:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042060e3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042060ea:	00 
  80042060eb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042060ef:	48 01 d0             	add    %rdx,%rax
  80042060f2:	48 8b 00             	mov    (%rax),%rax
  80042060f5:	83 e0 01             	and    $0x1,%eax
  80042060f8:	48 85 c0             	test   %rax,%rax
  80042060fb:	75 09                	jne    8004206106 <check_va2pa+0x253>
			return ~0;
  80042060fd:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004206104:	eb 25                	jmp    800420612b <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
		return PTE_ADDR(pte[PTX(va)]);
  8004206106:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420610a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420610e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206113:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420611a:	00 
  800420611b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420611f:	48 01 d0             	add    %rdx,%rax
  8004206122:	48 8b 00             	mov    (%rax),%rax
  8004206125:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
	}
  800420612b:	c9                   	leaveq 
  800420612c:	c3                   	retq   

000000800420612d <page_check>:

// check page_insert, page_remove, &c

	static void
	page_check(void)
	{
  800420612d:	55                   	push   %rbp
  800420612e:	48 89 e5             	mov    %rsp,%rbp
  8004206131:	53                   	push   %rbx
  8004206132:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
		pdpe_t *pdpe;
		pde_t *pde;
		void *va;
		int i;
		uintptr_t mm1, mm2;
		pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004206139:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004206140:	00 
  8004206141:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206145:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004206149:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420614d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004206151:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206155:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004206159:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420615d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004206161:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206165:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		assert(pp0 = page_alloc(0));
  8004206169:	bf 00 00 00 00       	mov    $0x0,%edi
  800420616e:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004206175:	00 00 00 
  8004206178:	ff d0                	callq  *%rax
  800420617a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420617e:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004206183:	75 35                	jne    80042061ba <page_check+0x8d>
  8004206185:	48 b9 3f 80 21 04 80 	movabs $0x800421803f,%rcx
  800420618c:	00 00 00 
  800420618f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206196:	00 00 00 
  8004206199:	be bf 04 00 00       	mov    $0x4bf,%esi
  800420619e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042061a5:	00 00 00 
  80042061a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061ad:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042061b4:	00 00 00 
  80042061b7:	41 ff d0             	callq  *%r8
		assert(pp1 = page_alloc(0));
  80042061ba:	bf 00 00 00 00       	mov    $0x0,%edi
  80042061bf:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042061c6:	00 00 00 
  80042061c9:	ff d0                	callq  *%rax
  80042061cb:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042061cf:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042061d4:	75 35                	jne    800420620b <page_check+0xde>
  80042061d6:	48 b9 53 80 21 04 80 	movabs $0x8004218053,%rcx
  80042061dd:	00 00 00 
  80042061e0:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042061e7:	00 00 00 
  80042061ea:	be c0 04 00 00       	mov    $0x4c0,%esi
  80042061ef:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042061f6:	00 00 00 
  80042061f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061fe:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206205:	00 00 00 
  8004206208:	41 ff d0             	callq  *%r8
		assert(pp2 = page_alloc(0));
  800420620b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206210:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004206217:	00 00 00 
  800420621a:	ff d0                	callq  *%rax
  800420621c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004206220:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004206225:	75 35                	jne    800420625c <page_check+0x12f>
  8004206227:	48 b9 67 80 21 04 80 	movabs $0x8004218067,%rcx
  800420622e:	00 00 00 
  8004206231:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206238:	00 00 00 
  800420623b:	be c1 04 00 00       	mov    $0x4c1,%esi
  8004206240:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206247:	00 00 00 
  800420624a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420624f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206256:	00 00 00 
  8004206259:	41 ff d0             	callq  *%r8
		assert(pp3 = page_alloc(0));
  800420625c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206261:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004206268:	00 00 00 
  800420626b:	ff d0                	callq  *%rax
  800420626d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004206271:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004206276:	75 35                	jne    80042062ad <page_check+0x180>
  8004206278:	48 b9 7b 80 21 04 80 	movabs $0x800421807b,%rcx
  800420627f:	00 00 00 
  8004206282:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206289:	00 00 00 
  800420628c:	be c2 04 00 00       	mov    $0x4c2,%esi
  8004206291:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206298:	00 00 00 
  800420629b:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062a0:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042062a7:	00 00 00 
  80042062aa:	41 ff d0             	callq  *%r8
		assert(pp4 = page_alloc(0));
  80042062ad:	bf 00 00 00 00       	mov    $0x0,%edi
  80042062b2:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042062b9:	00 00 00 
  80042062bc:	ff d0                	callq  *%rax
  80042062be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042062c2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042062c7:	75 35                	jne    80042062fe <page_check+0x1d1>
  80042062c9:	48 b9 8f 80 21 04 80 	movabs $0x800421808f,%rcx
  80042062d0:	00 00 00 
  80042062d3:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042062da:	00 00 00 
  80042062dd:	be c3 04 00 00       	mov    $0x4c3,%esi
  80042062e2:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042062e9:	00 00 00 
  80042062ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062f1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042062f8:	00 00 00 
  80042062fb:	41 ff d0             	callq  *%r8
		assert(pp5 = page_alloc(0));
  80042062fe:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206303:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  800420630a:	00 00 00 
  800420630d:	ff d0                	callq  *%rax
  800420630f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004206313:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004206318:	75 35                	jne    800420634f <page_check+0x222>
  800420631a:	48 b9 a3 80 21 04 80 	movabs $0x80042180a3,%rcx
  8004206321:	00 00 00 
  8004206324:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420632b:	00 00 00 
  800420632e:	be c4 04 00 00       	mov    $0x4c4,%esi
  8004206333:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420633a:	00 00 00 
  800420633d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206342:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206349:	00 00 00 
  800420634c:	41 ff d0             	callq  *%r8

		assert(pp0);
  800420634f:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004206354:	75 35                	jne    800420638b <page_check+0x25e>
  8004206356:	48 b9 f1 7d 21 04 80 	movabs $0x8004217df1,%rcx
  800420635d:	00 00 00 
  8004206360:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206367:	00 00 00 
  800420636a:	be c6 04 00 00       	mov    $0x4c6,%esi
  800420636f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206376:	00 00 00 
  8004206379:	b8 00 00 00 00       	mov    $0x0,%eax
  800420637e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206385:	00 00 00 
  8004206388:	41 ff d0             	callq  *%r8
		assert(pp1 && pp1 != pp0);
  800420638b:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004206390:	74 0a                	je     800420639c <page_check+0x26f>
  8004206392:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206396:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420639a:	75 35                	jne    80042063d1 <page_check+0x2a4>
  800420639c:	48 b9 f5 7d 21 04 80 	movabs $0x8004217df5,%rcx
  80042063a3:	00 00 00 
  80042063a6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042063ad:	00 00 00 
  80042063b0:	be c7 04 00 00       	mov    $0x4c7,%esi
  80042063b5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042063bc:	00 00 00 
  80042063bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063c4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042063cb:	00 00 00 
  80042063ce:	41 ff d0             	callq  *%r8
		assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042063d1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042063d6:	74 14                	je     80042063ec <page_check+0x2bf>
  80042063d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042063dc:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042063e0:	74 0a                	je     80042063ec <page_check+0x2bf>
  80042063e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042063e6:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042063ea:	75 35                	jne    8004206421 <page_check+0x2f4>
  80042063ec:	48 b9 08 7e 21 04 80 	movabs $0x8004217e08,%rcx
  80042063f3:	00 00 00 
  80042063f6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042063fd:	00 00 00 
  8004206400:	be c8 04 00 00       	mov    $0x4c8,%esi
  8004206405:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420640c:	00 00 00 
  800420640f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206414:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420641b:	00 00 00 
  800420641e:	41 ff d0             	callq  *%r8
		assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004206421:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004206426:	74 1e                	je     8004206446 <page_check+0x319>
  8004206428:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420642c:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004206430:	74 14                	je     8004206446 <page_check+0x319>
  8004206432:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206436:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420643a:	74 0a                	je     8004206446 <page_check+0x319>
  800420643c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206440:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004206444:	75 35                	jne    800420647b <page_check+0x34e>
  8004206446:	48 b9 b8 80 21 04 80 	movabs $0x80042180b8,%rcx
  800420644d:	00 00 00 
  8004206450:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206457:	00 00 00 
  800420645a:	be c9 04 00 00       	mov    $0x4c9,%esi
  800420645f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206466:	00 00 00 
  8004206469:	b8 00 00 00 00       	mov    $0x0,%eax
  800420646e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206475:	00 00 00 
  8004206478:	41 ff d0             	callq  *%r8
		assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  800420647b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004206480:	74 28                	je     80042064aa <page_check+0x37d>
  8004206482:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206486:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420648a:	74 1e                	je     80042064aa <page_check+0x37d>
  800420648c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206490:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004206494:	74 14                	je     80042064aa <page_check+0x37d>
  8004206496:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420649a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420649e:	74 0a                	je     80042064aa <page_check+0x37d>
  80042064a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042064a4:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042064a8:	75 35                	jne    80042064df <page_check+0x3b2>
  80042064aa:	48 b9 e8 80 21 04 80 	movabs $0x80042180e8,%rcx
  80042064b1:	00 00 00 
  80042064b4:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042064bb:	00 00 00 
  80042064be:	be ca 04 00 00       	mov    $0x4ca,%esi
  80042064c3:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042064ca:	00 00 00 
  80042064cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064d2:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042064d9:	00 00 00 
  80042064dc:	41 ff d0             	callq  *%r8
		assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  80042064df:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042064e4:	74 32                	je     8004206518 <page_check+0x3eb>
  80042064e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042064ea:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042064ee:	74 28                	je     8004206518 <page_check+0x3eb>
  80042064f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042064f4:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042064f8:	74 1e                	je     8004206518 <page_check+0x3eb>
  80042064fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042064fe:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004206502:	74 14                	je     8004206518 <page_check+0x3eb>
  8004206504:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206508:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420650c:	74 0a                	je     8004206518 <page_check+0x3eb>
  800420650e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004206512:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004206516:	75 35                	jne    800420654d <page_check+0x420>
  8004206518:	48 b9 28 81 21 04 80 	movabs $0x8004218128,%rcx
  800420651f:	00 00 00 
  8004206522:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206529:	00 00 00 
  800420652c:	be cb 04 00 00       	mov    $0x4cb,%esi
  8004206531:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206538:	00 00 00 
  800420653b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206540:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206547:	00 00 00 
  800420654a:	41 ff d0             	callq  *%r8


	// temporarily steal the rest of the free pages
		fl = page_free_list;
  800420654d:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004206554:	00 00 00 
  8004206557:	48 8b 00             	mov    (%rax),%rax
  800420655a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		page_free_list = NULL;
  800420655e:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004206565:	00 00 00 
  8004206568:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
		assert(!page_alloc(0));
  800420656f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206574:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  800420657b:	00 00 00 
  800420657e:	ff d0                	callq  *%rax
  8004206580:	48 85 c0             	test   %rax,%rax
  8004206583:	74 35                	je     80042065ba <page_check+0x48d>
  8004206585:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  800420658c:	00 00 00 
  800420658f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206596:	00 00 00 
  8004206599:	be d3 04 00 00       	mov    $0x4d3,%esi
  800420659e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042065a5:	00 00 00 
  80042065a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065ad:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042065b4:	00 00 00 
  80042065b7:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
		assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  80042065ba:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042065c1:	00 00 00 
  80042065c4:	48 8b 00             	mov    (%rax),%rax
  80042065c7:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  80042065ce:	be 00 00 00 00       	mov    $0x0,%esi
  80042065d3:	48 89 c7             	mov    %rax,%rdi
  80042065d6:	48 b8 b5 43 20 04 80 	movabs $0x80042043b5,%rax
  80042065dd:	00 00 00 
  80042065e0:	ff d0                	callq  *%rax
  80042065e2:	48 85 c0             	test   %rax,%rax
  80042065e5:	74 35                	je     800420661c <page_check+0x4ef>
  80042065e7:	48 b9 78 81 21 04 80 	movabs $0x8004218178,%rcx
  80042065ee:	00 00 00 
  80042065f1:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042065f8:	00 00 00 
  80042065fb:	be d6 04 00 00       	mov    $0x4d6,%esi
  8004206600:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206607:	00 00 00 
  800420660a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420660f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206616:	00 00 00 
  8004206619:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
		assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  800420661c:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206623:	00 00 00 
  8004206626:	48 8b 00             	mov    (%rax),%rax
  8004206629:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420662d:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206632:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206637:	48 89 c7             	mov    %rax,%rdi
  800420663a:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004206641:	00 00 00 
  8004206644:	ff d0                	callq  *%rax
  8004206646:	85 c0                	test   %eax,%eax
  8004206648:	78 35                	js     800420667f <page_check+0x552>
  800420664a:	48 b9 b0 81 21 04 80 	movabs $0x80042181b0,%rcx
  8004206651:	00 00 00 
  8004206654:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420665b:	00 00 00 
  800420665e:	be d9 04 00 00       	mov    $0x4d9,%esi
  8004206663:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420666a:	00 00 00 
  800420666d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206672:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206679:	00 00 00 
  800420667c:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	//	cprintf("pp1_ref %d\n",pp1->pp_ref);
		page_free(pp0);
  800420667f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206683:	48 89 c7             	mov    %rax,%rdi
  8004206686:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  800420668d:	00 00 00 
  8004206690:	ff d0                	callq  *%rax
		//cprintf("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2\n");
		assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004206692:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206699:	00 00 00 
  800420669c:	48 8b 00             	mov    (%rax),%rax
  800420669f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042066a3:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042066a8:	ba 00 00 00 00       	mov    $0x0,%edx
  80042066ad:	48 89 c7             	mov    %rax,%rdi
  80042066b0:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  80042066b7:	00 00 00 
  80042066ba:	ff d0                	callq  *%rax
  80042066bc:	85 c0                	test   %eax,%eax
  80042066be:	78 35                	js     80042066f5 <page_check+0x5c8>
  80042066c0:	48 b9 b0 81 21 04 80 	movabs $0x80042181b0,%rcx
  80042066c7:	00 00 00 
  80042066ca:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042066d1:	00 00 00 
  80042066d4:	be df 04 00 00       	mov    $0x4df,%esi
  80042066d9:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042066e0:	00 00 00 
  80042066e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066e8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042066ef:	00 00 00 
  80042066f2:	41 ff d0             	callq  *%r8
	//	cprintf("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1\n");
		page_free(pp2);
  80042066f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042066f9:	48 89 c7             	mov    %rax,%rdi
  80042066fc:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004206703:	00 00 00 
  8004206706:	ff d0                	callq  *%rax
		page_free(pp3);
  8004206708:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420670c:	48 89 c7             	mov    %rax,%rdi
  800420670f:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  8004206716:	00 00 00 
  8004206719:	ff d0                	callq  *%rax

	// cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	// cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	// cprintf("pp2 ref count = %d\n",pp2->pp_ref);

		assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  800420671b:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206722:	00 00 00 
  8004206725:	48 8b 00             	mov    (%rax),%rax
  8004206728:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420672c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206731:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206736:	48 89 c7             	mov    %rax,%rdi
  8004206739:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004206740:	00 00 00 
  8004206743:	ff d0                	callq  *%rax
  8004206745:	85 c0                	test   %eax,%eax
  8004206747:	74 35                	je     800420677e <page_check+0x651>
  8004206749:	48 b9 e0 81 21 04 80 	movabs $0x80042181e0,%rcx
  8004206750:	00 00 00 
  8004206753:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420675a:	00 00 00 
  800420675d:	be e8 04 00 00       	mov    $0x4e8,%esi
  8004206762:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206769:	00 00 00 
  800420676c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206771:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206778:	00 00 00 
  800420677b:	41 ff d0             	callq  *%r8
	//	cprintf("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3\n");
		assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  800420677e:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206785:	00 00 00 
  8004206788:	48 8b 00             	mov    (%rax),%rax
  800420678b:	48 8b 00             	mov    (%rax),%rax
  800420678e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206794:	48 89 c3             	mov    %rax,%rbx
  8004206797:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420679b:	48 89 c7             	mov    %rax,%rdi
  800420679e:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042067a5:	00 00 00 
  80042067a8:	ff d0                	callq  *%rax
  80042067aa:	48 39 c3             	cmp    %rax,%rbx
  80042067ad:	0f 84 97 00 00 00    	je     800420684a <page_check+0x71d>
  80042067b3:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042067ba:	00 00 00 
  80042067bd:	48 8b 00             	mov    (%rax),%rax
  80042067c0:	48 8b 00             	mov    (%rax),%rax
  80042067c3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042067c9:	48 89 c3             	mov    %rax,%rbx
  80042067cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042067d0:	48 89 c7             	mov    %rax,%rdi
  80042067d3:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042067da:	00 00 00 
  80042067dd:	ff d0                	callq  *%rax
  80042067df:	48 39 c3             	cmp    %rax,%rbx
  80042067e2:	74 66                	je     800420684a <page_check+0x71d>
  80042067e4:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042067eb:	00 00 00 
  80042067ee:	48 8b 00             	mov    (%rax),%rax
  80042067f1:	48 8b 00             	mov    (%rax),%rax
  80042067f4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042067fa:	48 89 c3             	mov    %rax,%rbx
  80042067fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206801:	48 89 c7             	mov    %rax,%rdi
  8004206804:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420680b:	00 00 00 
  800420680e:	ff d0                	callq  *%rax
  8004206810:	48 39 c3             	cmp    %rax,%rbx
  8004206813:	74 35                	je     800420684a <page_check+0x71d>
  8004206815:	48 b9 10 82 21 04 80 	movabs $0x8004218210,%rcx
  800420681c:	00 00 00 
  800420681f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206826:	00 00 00 
  8004206829:	be ea 04 00 00       	mov    $0x4ea,%esi
  800420682e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206835:	00 00 00 
  8004206838:	b8 00 00 00 00       	mov    $0x0,%eax
  800420683d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206844:	00 00 00 
  8004206847:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  800420684a:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206851:	00 00 00 
  8004206854:	48 8b 00             	mov    (%rax),%rax
  8004206857:	be 00 00 00 00       	mov    $0x0,%esi
  800420685c:	48 89 c7             	mov    %rax,%rdi
  800420685f:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004206866:	00 00 00 
  8004206869:	ff d0                	callq  *%rax
  800420686b:	48 89 c3             	mov    %rax,%rbx
  800420686e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206872:	48 89 c7             	mov    %rax,%rdi
  8004206875:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  800420687c:	00 00 00 
  800420687f:	ff d0                	callq  *%rax
  8004206881:	48 39 c3             	cmp    %rax,%rbx
  8004206884:	74 35                	je     80042068bb <page_check+0x78e>
  8004206886:	48 b9 98 82 21 04 80 	movabs $0x8004218298,%rcx
  800420688d:	00 00 00 
  8004206890:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206897:	00 00 00 
  800420689a:	be eb 04 00 00       	mov    $0x4eb,%esi
  800420689f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042068a6:	00 00 00 
  80042068a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068ae:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042068b5:	00 00 00 
  80042068b8:	41 ff d0             	callq  *%r8
		assert(pp1->pp_ref == 1);
  80042068bb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068bf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042068c3:	66 83 f8 01          	cmp    $0x1,%ax
  80042068c7:	74 35                	je     80042068fe <page_check+0x7d1>
  80042068c9:	48 b9 c5 82 21 04 80 	movabs $0x80042182c5,%rcx
  80042068d0:	00 00 00 
  80042068d3:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042068da:	00 00 00 
  80042068dd:	be ec 04 00 00       	mov    $0x4ec,%esi
  80042068e2:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042068e9:	00 00 00 
  80042068ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068f1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042068f8:	00 00 00 
  80042068fb:	41 ff d0             	callq  *%r8
		assert(pp0->pp_ref == 1);
  80042068fe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206902:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206906:	66 83 f8 01          	cmp    $0x1,%ax
  800420690a:	74 35                	je     8004206941 <page_check+0x814>
  800420690c:	48 b9 d6 82 21 04 80 	movabs $0x80042182d6,%rcx
  8004206913:	00 00 00 
  8004206916:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420691d:	00 00 00 
  8004206920:	be ed 04 00 00       	mov    $0x4ed,%esi
  8004206925:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420692c:	00 00 00 
  800420692f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206934:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420693b:	00 00 00 
  800420693e:	41 ff d0             	callq  *%r8
		assert(pp2->pp_ref == 1);
  8004206941:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206945:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206949:	66 83 f8 01          	cmp    $0x1,%ax
  800420694d:	74 35                	je     8004206984 <page_check+0x857>
  800420694f:	48 b9 e7 82 21 04 80 	movabs $0x80042182e7,%rcx
  8004206956:	00 00 00 
  8004206959:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206960:	00 00 00 
  8004206963:	be ee 04 00 00       	mov    $0x4ee,%esi
  8004206968:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420696f:	00 00 00 
  8004206972:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206977:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420697e:	00 00 00 
  8004206981:	41 ff d0             	callq  *%r8

//cprintf("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4\n");
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
		assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206984:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420698b:	00 00 00 
  800420698e:	48 8b 00             	mov    (%rax),%rax
  8004206991:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206995:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420699a:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420699f:	48 89 c7             	mov    %rax,%rdi
  80042069a2:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  80042069a9:	00 00 00 
  80042069ac:	ff d0                	callq  *%rax
  80042069ae:	85 c0                	test   %eax,%eax
  80042069b0:	74 35                	je     80042069e7 <page_check+0x8ba>
  80042069b2:	48 b9 f8 82 21 04 80 	movabs $0x80042182f8,%rcx
  80042069b9:	00 00 00 
  80042069bc:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042069c3:	00 00 00 
  80042069c6:	be f2 04 00 00       	mov    $0x4f2,%esi
  80042069cb:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042069d2:	00 00 00 
  80042069d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069da:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042069e1:	00 00 00 
  80042069e4:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042069e7:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042069ee:	00 00 00 
  80042069f1:	48 8b 00             	mov    (%rax),%rax
  80042069f4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042069f9:	48 89 c7             	mov    %rax,%rdi
  80042069fc:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004206a03:	00 00 00 
  8004206a06:	ff d0                	callq  *%rax
  8004206a08:	48 89 c3             	mov    %rax,%rbx
  8004206a0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206a0f:	48 89 c7             	mov    %rax,%rdi
  8004206a12:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004206a19:	00 00 00 
  8004206a1c:	ff d0                	callq  *%rax
  8004206a1e:	48 39 c3             	cmp    %rax,%rbx
  8004206a21:	74 35                	je     8004206a58 <page_check+0x92b>
  8004206a23:	48 b9 30 83 21 04 80 	movabs $0x8004218330,%rcx
  8004206a2a:	00 00 00 
  8004206a2d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206a34:	00 00 00 
  8004206a37:	be f3 04 00 00       	mov    $0x4f3,%esi
  8004206a3c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206a43:	00 00 00 
  8004206a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a4b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206a52:	00 00 00 
  8004206a55:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 2);
  8004206a58:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206a5c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a60:	66 83 f8 02          	cmp    $0x2,%ax
  8004206a64:	74 35                	je     8004206a9b <page_check+0x96e>
  8004206a66:	48 b9 60 83 21 04 80 	movabs $0x8004218360,%rcx
  8004206a6d:	00 00 00 
  8004206a70:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206a77:	00 00 00 
  8004206a7a:	be f4 04 00 00       	mov    $0x4f4,%esi
  8004206a7f:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206a86:	00 00 00 
  8004206a89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a8e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206a95:	00 00 00 
  8004206a98:	41 ff d0             	callq  *%r8

	// should be no free memory
		assert(!page_alloc(0));
  8004206a9b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206aa0:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004206aa7:	00 00 00 
  8004206aaa:	ff d0                	callq  *%rax
  8004206aac:	48 85 c0             	test   %rax,%rax
  8004206aaf:	74 35                	je     8004206ae6 <page_check+0x9b9>
  8004206ab1:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  8004206ab8:	00 00 00 
  8004206abb:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206ac2:	00 00 00 
  8004206ac5:	be f7 04 00 00       	mov    $0x4f7,%esi
  8004206aca:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206ad1:	00 00 00 
  8004206ad4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad9:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206ae0:	00 00 00 
  8004206ae3:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
		assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206ae6:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206aed:	00 00 00 
  8004206af0:	48 8b 00             	mov    (%rax),%rax
  8004206af3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206af7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206afc:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206b01:	48 89 c7             	mov    %rax,%rdi
  8004206b04:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004206b0b:	00 00 00 
  8004206b0e:	ff d0                	callq  *%rax
  8004206b10:	85 c0                	test   %eax,%eax
  8004206b12:	74 35                	je     8004206b49 <page_check+0xa1c>
  8004206b14:	48 b9 f8 82 21 04 80 	movabs $0x80042182f8,%rcx
  8004206b1b:	00 00 00 
  8004206b1e:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206b25:	00 00 00 
  8004206b28:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004206b2d:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206b34:	00 00 00 
  8004206b37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b3c:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206b43:	00 00 00 
  8004206b46:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206b49:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206b50:	00 00 00 
  8004206b53:	48 8b 00             	mov    (%rax),%rax
  8004206b56:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206b5b:	48 89 c7             	mov    %rax,%rdi
  8004206b5e:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004206b65:	00 00 00 
  8004206b68:	ff d0                	callq  *%rax
  8004206b6a:	48 89 c3             	mov    %rax,%rbx
  8004206b6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206b71:	48 89 c7             	mov    %rax,%rdi
  8004206b74:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004206b7b:	00 00 00 
  8004206b7e:	ff d0                	callq  *%rax
  8004206b80:	48 39 c3             	cmp    %rax,%rbx
  8004206b83:	74 35                	je     8004206bba <page_check+0xa8d>
  8004206b85:	48 b9 30 83 21 04 80 	movabs $0x8004218330,%rcx
  8004206b8c:	00 00 00 
  8004206b8f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206b96:	00 00 00 
  8004206b99:	be fb 04 00 00       	mov    $0x4fb,%esi
  8004206b9e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206ba5:	00 00 00 
  8004206ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bad:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206bb4:	00 00 00 
  8004206bb7:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 2);
  8004206bba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206bbe:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206bc2:	66 83 f8 02          	cmp    $0x2,%ax
  8004206bc6:	74 35                	je     8004206bfd <page_check+0xad0>
  8004206bc8:	48 b9 60 83 21 04 80 	movabs $0x8004218360,%rcx
  8004206bcf:	00 00 00 
  8004206bd2:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206bd9:	00 00 00 
  8004206bdc:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004206be1:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206be8:	00 00 00 
  8004206beb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bf0:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206bf7:	00 00 00 
  8004206bfa:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
		assert(!page_alloc(0));
  8004206bfd:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206c02:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  8004206c09:	00 00 00 
  8004206c0c:	ff d0                	callq  *%rax
  8004206c0e:	48 85 c0             	test   %rax,%rax
  8004206c11:	74 35                	je     8004206c48 <page_check+0xb1b>
  8004206c13:	48 b9 7f 7e 21 04 80 	movabs $0x8004217e7f,%rcx
  8004206c1a:	00 00 00 
  8004206c1d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206c24:	00 00 00 
  8004206c27:	be 00 05 00 00       	mov    $0x500,%esi
  8004206c2c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206c33:	00 00 00 
  8004206c36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c3b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206c42:	00 00 00 
  8004206c45:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
		pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004206c48:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206c4f:	00 00 00 
  8004206c52:	48 8b 00             	mov    (%rax),%rax
  8004206c55:	48 8b 00             	mov    (%rax),%rax
  8004206c58:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206c5e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004206c62:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206c66:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c6a:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004206c6d:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206c70:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004206c77:	00 00 00 
  8004206c7a:	48 8b 00             	mov    (%rax),%rax
  8004206c7d:	48 39 c2             	cmp    %rax,%rdx
  8004206c80:	72 32                	jb     8004206cb4 <page_check+0xb87>
  8004206c82:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206c86:	48 89 c1             	mov    %rax,%rcx
  8004206c89:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004206c90:	00 00 00 
  8004206c93:	be 02 05 00 00       	mov    $0x502,%esi
  8004206c98:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206c9f:	00 00 00 
  8004206ca2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ca7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206cae:	00 00 00 
  8004206cb1:	41 ff d0             	callq  *%r8
  8004206cb4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206cbb:	00 00 00 
  8004206cbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206cc2:	48 01 d0             	add    %rdx,%rax
  8004206cc5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004206cc9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206ccd:	48 8b 00             	mov    (%rax),%rax
  8004206cd0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206cd6:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004206cda:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206cde:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ce2:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004206ce5:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004206ce8:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004206cef:	00 00 00 
  8004206cf2:	48 8b 00             	mov    (%rax),%rax
  8004206cf5:	48 39 c2             	cmp    %rax,%rdx
  8004206cf8:	72 32                	jb     8004206d2c <page_check+0xbff>
  8004206cfa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206cfe:	48 89 c1             	mov    %rax,%rcx
  8004206d01:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004206d08:	00 00 00 
  8004206d0b:	be 03 05 00 00       	mov    $0x503,%esi
  8004206d10:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206d17:	00 00 00 
  8004206d1a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d1f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206d26:	00 00 00 
  8004206d29:	41 ff d0             	callq  *%r8
  8004206d2c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206d33:	00 00 00 
  8004206d36:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206d3a:	48 01 d0             	add    %rdx,%rax
  8004206d3d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206d41:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206d45:	48 8b 00             	mov    (%rax),%rax
  8004206d48:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d4e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004206d55:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206d5c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d60:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206d66:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206d6c:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004206d73:	00 00 00 
  8004206d76:	48 8b 00             	mov    (%rax),%rax
  8004206d79:	48 39 c2             	cmp    %rax,%rdx
  8004206d7c:	72 35                	jb     8004206db3 <page_check+0xc86>
  8004206d7e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206d85:	48 89 c1             	mov    %rax,%rcx
  8004206d88:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004206d8f:	00 00 00 
  8004206d92:	be 04 05 00 00       	mov    $0x504,%esi
  8004206d97:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206d9e:	00 00 00 
  8004206da1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206da6:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206dad:	00 00 00 
  8004206db0:	41 ff d0             	callq  *%r8
  8004206db3:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206dba:	00 00 00 
  8004206dbd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206dc4:	48 01 d0             	add    %rdx,%rax
  8004206dc7:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
		assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206dce:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206dd5:	00 00 00 
  8004206dd8:	48 8b 00             	mov    (%rax),%rax
  8004206ddb:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206de0:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206de5:	48 89 c7             	mov    %rax,%rdi
  8004206de8:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004206def:	00 00 00 
  8004206df2:	ff d0                	callq  *%rax
  8004206df4:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004206dfb:	48 83 c2 08          	add    $0x8,%rdx
  8004206dff:	48 39 d0             	cmp    %rdx,%rax
  8004206e02:	74 35                	je     8004206e39 <page_check+0xd0c>
  8004206e04:	48 b9 78 83 21 04 80 	movabs $0x8004218378,%rcx
  8004206e0b:	00 00 00 
  8004206e0e:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206e15:	00 00 00 
  8004206e18:	be 05 05 00 00       	mov    $0x505,%esi
  8004206e1d:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206e24:	00 00 00 
  8004206e27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e2c:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206e33:	00 00 00 
  8004206e36:	41 ff d0             	callq  *%r8


	// should be able to change permissions too.
		assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  8004206e39:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206e40:	00 00 00 
  8004206e43:	48 8b 00             	mov    (%rax),%rax
  8004206e46:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206e4a:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206e4f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206e54:	48 89 c7             	mov    %rax,%rdi
  8004206e57:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004206e5e:	00 00 00 
  8004206e61:	ff d0                	callq  *%rax
  8004206e63:	85 c0                	test   %eax,%eax
  8004206e65:	74 35                	je     8004206e9c <page_check+0xd6f>
  8004206e67:	48 b9 b8 83 21 04 80 	movabs $0x80042183b8,%rcx
  8004206e6e:	00 00 00 
  8004206e71:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206e78:	00 00 00 
  8004206e7b:	be 09 05 00 00       	mov    $0x509,%esi
  8004206e80:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206e87:	00 00 00 
  8004206e8a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e8f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206e96:	00 00 00 
  8004206e99:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004206e9c:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206ea3:	00 00 00 
  8004206ea6:	48 8b 00             	mov    (%rax),%rax
  8004206ea9:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206eae:	48 89 c7             	mov    %rax,%rdi
  8004206eb1:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004206eb8:	00 00 00 
  8004206ebb:	ff d0                	callq  *%rax
  8004206ebd:	48 89 c3             	mov    %rax,%rbx
  8004206ec0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206ec4:	48 89 c7             	mov    %rax,%rdi
  8004206ec7:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004206ece:	00 00 00 
  8004206ed1:	ff d0                	callq  *%rax
  8004206ed3:	48 39 c3             	cmp    %rax,%rbx
  8004206ed6:	74 35                	je     8004206f0d <page_check+0xde0>
  8004206ed8:	48 b9 30 83 21 04 80 	movabs $0x8004218330,%rcx
  8004206edf:	00 00 00 
  8004206ee2:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206ee9:	00 00 00 
  8004206eec:	be 0a 05 00 00       	mov    $0x50a,%esi
  8004206ef1:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206ef8:	00 00 00 
  8004206efb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f00:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206f07:	00 00 00 
  8004206f0a:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 2);
  8004206f0d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206f11:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f15:	66 83 f8 02          	cmp    $0x2,%ax
  8004206f19:	74 35                	je     8004206f50 <page_check+0xe23>
  8004206f1b:	48 b9 60 83 21 04 80 	movabs $0x8004218360,%rcx
  8004206f22:	00 00 00 
  8004206f25:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206f2c:	00 00 00 
  8004206f2f:	be 0b 05 00 00       	mov    $0x50b,%esi
  8004206f34:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206f3b:	00 00 00 
  8004206f3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f43:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206f4a:	00 00 00 
  8004206f4d:	41 ff d0             	callq  *%r8
		assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206f50:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206f57:	00 00 00 
  8004206f5a:	48 8b 00             	mov    (%rax),%rax
  8004206f5d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206f62:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206f67:	48 89 c7             	mov    %rax,%rdi
  8004206f6a:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004206f71:	00 00 00 
  8004206f74:	ff d0                	callq  *%rax
  8004206f76:	48 8b 00             	mov    (%rax),%rax
  8004206f79:	83 e0 04             	and    $0x4,%eax
  8004206f7c:	48 85 c0             	test   %rax,%rax
  8004206f7f:	75 35                	jne    8004206fb6 <page_check+0xe89>
  8004206f81:	48 b9 f8 83 21 04 80 	movabs $0x80042183f8,%rcx
  8004206f88:	00 00 00 
  8004206f8b:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206f92:	00 00 00 
  8004206f95:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004206f9a:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206fa1:	00 00 00 
  8004206fa4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fa9:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206fb0:	00 00 00 
  8004206fb3:	41 ff d0             	callq  *%r8
		assert(boot_pml4e[0] & PTE_U);
  8004206fb6:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004206fbd:	00 00 00 
  8004206fc0:	48 8b 00             	mov    (%rax),%rax
  8004206fc3:	48 8b 00             	mov    (%rax),%rax
  8004206fc6:	83 e0 04             	and    $0x4,%eax
  8004206fc9:	48 85 c0             	test   %rax,%rax
  8004206fcc:	75 35                	jne    8004207003 <page_check+0xed6>
  8004206fce:	48 b9 2b 84 21 04 80 	movabs $0x800421842b,%rcx
  8004206fd5:	00 00 00 
  8004206fd8:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004206fdf:	00 00 00 
  8004206fe2:	be 0d 05 00 00       	mov    $0x50d,%esi
  8004206fe7:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004206fee:	00 00 00 
  8004206ff1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ff6:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004206ffd:	00 00 00 
  8004207000:	41 ff d0             	callq  *%r8

	// should not be able to map at PTSIZE because need free page for page table
		assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004207003:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420700a:	00 00 00 
  800420700d:	48 8b 00             	mov    (%rax),%rax
  8004207010:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004207014:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004207019:	ba 00 00 20 00       	mov    $0x200000,%edx
  800420701e:	48 89 c7             	mov    %rax,%rdi
  8004207021:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004207028:	00 00 00 
  800420702b:	ff d0                	callq  *%rax
  800420702d:	85 c0                	test   %eax,%eax
  800420702f:	78 35                	js     8004207066 <page_check+0xf39>
  8004207031:	48 b9 48 84 21 04 80 	movabs $0x8004218448,%rcx
  8004207038:	00 00 00 
  800420703b:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207042:	00 00 00 
  8004207045:	be 10 05 00 00       	mov    $0x510,%esi
  800420704a:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207051:	00 00 00 
  8004207054:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207059:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207060:	00 00 00 
  8004207063:	41 ff d0             	callq  *%r8


	// insert pp1 at PGSIZE (replacing pp3)
		assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004207066:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420706d:	00 00 00 
  8004207070:	48 8b 00             	mov    (%rax),%rax
  8004207073:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004207077:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420707c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207081:	48 89 c7             	mov    %rax,%rdi
  8004207084:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  800420708b:	00 00 00 
  800420708e:	ff d0                	callq  *%rax
  8004207090:	85 c0                	test   %eax,%eax
  8004207092:	74 35                	je     80042070c9 <page_check+0xf9c>
  8004207094:	48 b9 80 84 21 04 80 	movabs $0x8004218480,%rcx
  800420709b:	00 00 00 
  800420709e:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042070a5:	00 00 00 
  80042070a8:	be 14 05 00 00       	mov    $0x514,%esi
  80042070ad:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042070b4:	00 00 00 
  80042070b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070bc:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042070c3:	00 00 00 
  80042070c6:	41 ff d0             	callq  *%r8

		assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  80042070c9:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042070d0:	00 00 00 
  80042070d3:	48 8b 00             	mov    (%rax),%rax
  80042070d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042070db:	be 00 10 00 00       	mov    $0x1000,%esi
  80042070e0:	48 89 c7             	mov    %rax,%rdi
  80042070e3:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  80042070ea:	00 00 00 
  80042070ed:	ff d0                	callq  *%rax
  80042070ef:	48 8b 00             	mov    (%rax),%rax
  80042070f2:	83 e0 04             	and    $0x4,%eax
  80042070f5:	48 85 c0             	test   %rax,%rax
  80042070f8:	74 35                	je     800420712f <page_check+0x1002>
  80042070fa:	48 b9 b8 84 21 04 80 	movabs $0x80042184b8,%rcx
  8004207101:	00 00 00 
  8004207104:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420710b:	00 00 00 
  800420710e:	be 16 05 00 00       	mov    $0x516,%esi
  8004207113:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420711a:	00 00 00 
  800420711d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207122:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207129:	00 00 00 
  800420712c:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
		assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  800420712f:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207136:	00 00 00 
  8004207139:	48 8b 00             	mov    (%rax),%rax
  800420713c:	be 00 00 00 00       	mov    $0x0,%esi
  8004207141:	48 89 c7             	mov    %rax,%rdi
  8004207144:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  800420714b:	00 00 00 
  800420714e:	ff d0                	callq  *%rax
  8004207150:	48 89 c3             	mov    %rax,%rbx
  8004207153:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207157:	48 89 c7             	mov    %rax,%rdi
  800420715a:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004207161:	00 00 00 
  8004207164:	ff d0                	callq  *%rax
  8004207166:	48 39 c3             	cmp    %rax,%rbx
  8004207169:	74 35                	je     80042071a0 <page_check+0x1073>
  800420716b:	48 b9 f0 84 21 04 80 	movabs $0x80042184f0,%rcx
  8004207172:	00 00 00 
  8004207175:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420717c:	00 00 00 
  800420717f:	be 19 05 00 00       	mov    $0x519,%esi
  8004207184:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420718b:	00 00 00 
  800420718e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207193:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420719a:	00 00 00 
  800420719d:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042071a0:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042071a7:	00 00 00 
  80042071aa:	48 8b 00             	mov    (%rax),%rax
  80042071ad:	be 00 10 00 00       	mov    $0x1000,%esi
  80042071b2:	48 89 c7             	mov    %rax,%rdi
  80042071b5:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  80042071bc:	00 00 00 
  80042071bf:	ff d0                	callq  *%rax
  80042071c1:	48 89 c3             	mov    %rax,%rbx
  80042071c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042071c8:	48 89 c7             	mov    %rax,%rdi
  80042071cb:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  80042071d2:	00 00 00 
  80042071d5:	ff d0                	callq  *%rax
  80042071d7:	48 39 c3             	cmp    %rax,%rbx
  80042071da:	74 35                	je     8004207211 <page_check+0x10e4>
  80042071dc:	48 b9 20 85 21 04 80 	movabs $0x8004218520,%rcx
  80042071e3:	00 00 00 
  80042071e6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042071ed:	00 00 00 
  80042071f0:	be 1a 05 00 00       	mov    $0x51a,%esi
  80042071f5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042071fc:	00 00 00 
  80042071ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207204:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420720b:	00 00 00 
  800420720e:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
		assert(pp1->pp_ref == 2);
  8004207211:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207215:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207219:	66 83 f8 02          	cmp    $0x2,%ax
  800420721d:	74 35                	je     8004207254 <page_check+0x1127>
  800420721f:	48 b9 50 85 21 04 80 	movabs $0x8004218550,%rcx
  8004207226:	00 00 00 
  8004207229:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207230:	00 00 00 
  8004207233:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004207238:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420723f:	00 00 00 
  8004207242:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207247:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420724e:	00 00 00 
  8004207251:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 1);
  8004207254:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207258:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420725c:	66 83 f8 01          	cmp    $0x1,%ax
  8004207260:	74 35                	je     8004207297 <page_check+0x116a>
  8004207262:	48 b9 61 85 21 04 80 	movabs $0x8004218561,%rcx
  8004207269:	00 00 00 
  800420726c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207273:	00 00 00 
  8004207276:	be 1d 05 00 00       	mov    $0x51d,%esi
  800420727b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207282:	00 00 00 
  8004207285:	b8 00 00 00 00       	mov    $0x0,%eax
  800420728a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207291:	00 00 00 
  8004207294:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
		page_remove(boot_pml4e, 0x0);
  8004207297:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420729e:	00 00 00 
  80042072a1:	48 8b 00             	mov    (%rax),%rax
  80042072a4:	be 00 00 00 00       	mov    $0x0,%esi
  80042072a9:	48 89 c7             	mov    %rax,%rdi
  80042072ac:	48 b8 24 44 20 04 80 	movabs $0x8004204424,%rax
  80042072b3:	00 00 00 
  80042072b6:	ff d0                	callq  *%rax
		assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  80042072b8:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042072bf:	00 00 00 
  80042072c2:	48 8b 00             	mov    (%rax),%rax
  80042072c5:	be 00 00 00 00       	mov    $0x0,%esi
  80042072ca:	48 89 c7             	mov    %rax,%rdi
  80042072cd:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  80042072d4:	00 00 00 
  80042072d7:	ff d0                	callq  *%rax
  80042072d9:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042072dd:	74 35                	je     8004207314 <page_check+0x11e7>
  80042072df:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  80042072e6:	00 00 00 
  80042072e9:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042072f0:	00 00 00 
  80042072f3:	be 22 05 00 00       	mov    $0x522,%esi
  80042072f8:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042072ff:	00 00 00 
  8004207302:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207307:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420730e:	00 00 00 
  8004207311:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004207314:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420731b:	00 00 00 
  800420731e:	48 8b 00             	mov    (%rax),%rax
  8004207321:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207326:	48 89 c7             	mov    %rax,%rdi
  8004207329:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004207330:	00 00 00 
  8004207333:	ff d0                	callq  *%rax
  8004207335:	48 89 c3             	mov    %rax,%rbx
  8004207338:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420733c:	48 89 c7             	mov    %rax,%rdi
  800420733f:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004207346:	00 00 00 
  8004207349:	ff d0                	callq  *%rax
  800420734b:	48 39 c3             	cmp    %rax,%rbx
  800420734e:	74 35                	je     8004207385 <page_check+0x1258>
  8004207350:	48 b9 20 85 21 04 80 	movabs $0x8004218520,%rcx
  8004207357:	00 00 00 
  800420735a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207361:	00 00 00 
  8004207364:	be 23 05 00 00       	mov    $0x523,%esi
  8004207369:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207370:	00 00 00 
  8004207373:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207378:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420737f:	00 00 00 
  8004207382:	41 ff d0             	callq  *%r8
		assert(pp1->pp_ref == 1);
  8004207385:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207389:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420738d:	66 83 f8 01          	cmp    $0x1,%ax
  8004207391:	74 35                	je     80042073c8 <page_check+0x129b>
  8004207393:	48 b9 c5 82 21 04 80 	movabs $0x80042182c5,%rcx
  800420739a:	00 00 00 
  800420739d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042073a4:	00 00 00 
  80042073a7:	be 24 05 00 00       	mov    $0x524,%esi
  80042073ac:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042073b3:	00 00 00 
  80042073b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073bb:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042073c2:	00 00 00 
  80042073c5:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 1);
  80042073c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042073cc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042073d0:	66 83 f8 01          	cmp    $0x1,%ax
  80042073d4:	74 35                	je     800420740b <page_check+0x12de>
  80042073d6:	48 b9 61 85 21 04 80 	movabs $0x8004218561,%rcx
  80042073dd:	00 00 00 
  80042073e0:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042073e7:	00 00 00 
  80042073ea:	be 25 05 00 00       	mov    $0x525,%esi
  80042073ef:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042073f6:	00 00 00 
  80042073f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073fe:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207405:	00 00 00 
  8004207408:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
		assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420740b:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207412:	00 00 00 
  8004207415:	48 8b 00             	mov    (%rax),%rax
  8004207418:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420741c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004207421:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207426:	48 89 c7             	mov    %rax,%rdi
  8004207429:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  8004207430:	00 00 00 
  8004207433:	ff d0                	callq  *%rax
  8004207435:	85 c0                	test   %eax,%eax
  8004207437:	74 35                	je     800420746e <page_check+0x1341>
  8004207439:	48 b9 80 84 21 04 80 	movabs $0x8004218480,%rcx
  8004207440:	00 00 00 
  8004207443:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420744a:	00 00 00 
  800420744d:	be 29 05 00 00       	mov    $0x529,%esi
  8004207452:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207459:	00 00 00 
  800420745c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207461:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207468:	00 00 00 
  800420746b:	41 ff d0             	callq  *%r8
		assert(pp1->pp_ref);
  800420746e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207472:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207476:	66 85 c0             	test   %ax,%ax
  8004207479:	75 35                	jne    80042074b0 <page_check+0x1383>
  800420747b:	48 b9 9b 85 21 04 80 	movabs $0x800421859b,%rcx
  8004207482:	00 00 00 
  8004207485:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420748c:	00 00 00 
  800420748f:	be 2a 05 00 00       	mov    $0x52a,%esi
  8004207494:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420749b:	00 00 00 
  800420749e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074a3:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042074aa:	00 00 00 
  80042074ad:	41 ff d0             	callq  *%r8
		assert(pp1->pp_link == NULL);
  80042074b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042074b4:	48 8b 00             	mov    (%rax),%rax
  80042074b7:	48 85 c0             	test   %rax,%rax
  80042074ba:	74 35                	je     80042074f1 <page_check+0x13c4>
  80042074bc:	48 b9 a7 85 21 04 80 	movabs $0x80042185a7,%rcx
  80042074c3:	00 00 00 
  80042074c6:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042074cd:	00 00 00 
  80042074d0:	be 2b 05 00 00       	mov    $0x52b,%esi
  80042074d5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042074dc:	00 00 00 
  80042074df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074e4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042074eb:	00 00 00 
  80042074ee:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
		page_remove(boot_pml4e, (void*) PGSIZE);
  80042074f1:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042074f8:	00 00 00 
  80042074fb:	48 8b 00             	mov    (%rax),%rax
  80042074fe:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207503:	48 89 c7             	mov    %rax,%rdi
  8004207506:	48 b8 24 44 20 04 80 	movabs $0x8004204424,%rax
  800420750d:	00 00 00 
  8004207510:	ff d0                	callq  *%rax
		assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004207512:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207519:	00 00 00 
  800420751c:	48 8b 00             	mov    (%rax),%rax
  800420751f:	be 00 00 00 00       	mov    $0x0,%esi
  8004207524:	48 89 c7             	mov    %rax,%rdi
  8004207527:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  800420752e:	00 00 00 
  8004207531:	ff d0                	callq  *%rax
  8004207533:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207537:	74 35                	je     800420756e <page_check+0x1441>
  8004207539:	48 b9 78 85 21 04 80 	movabs $0x8004218578,%rcx
  8004207540:	00 00 00 
  8004207543:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420754a:	00 00 00 
  800420754d:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004207552:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207559:	00 00 00 
  800420755c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207561:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207568:	00 00 00 
  800420756b:	41 ff d0             	callq  *%r8
		assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  800420756e:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207575:	00 00 00 
  8004207578:	48 8b 00             	mov    (%rax),%rax
  800420757b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207580:	48 89 c7             	mov    %rax,%rdi
  8004207583:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  800420758a:	00 00 00 
  800420758d:	ff d0                	callq  *%rax
  800420758f:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207593:	74 35                	je     80042075ca <page_check+0x149d>
  8004207595:	48 b9 c0 85 21 04 80 	movabs $0x80042185c0,%rcx
  800420759c:	00 00 00 
  800420759f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042075a6:	00 00 00 
  80042075a9:	be 30 05 00 00       	mov    $0x530,%esi
  80042075ae:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042075b5:	00 00 00 
  80042075b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075bd:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042075c4:	00 00 00 
  80042075c7:	41 ff d0             	callq  *%r8
		assert(pp1->pp_ref == 0);
  80042075ca:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042075ce:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042075d2:	66 85 c0             	test   %ax,%ax
  80042075d5:	74 35                	je     800420760c <page_check+0x14df>
  80042075d7:	48 b9 e6 85 21 04 80 	movabs $0x80042185e6,%rcx
  80042075de:	00 00 00 
  80042075e1:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042075e8:	00 00 00 
  80042075eb:	be 31 05 00 00       	mov    $0x531,%esi
  80042075f0:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042075f7:	00 00 00 
  80042075fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075ff:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207606:	00 00 00 
  8004207609:	41 ff d0             	callq  *%r8
		assert(pp3->pp_ref == 1);
  800420760c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207610:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207614:	66 83 f8 01          	cmp    $0x1,%ax
  8004207618:	74 35                	je     800420764f <page_check+0x1522>
  800420761a:	48 b9 61 85 21 04 80 	movabs $0x8004218561,%rcx
  8004207621:	00 00 00 
  8004207624:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420762b:	00 00 00 
  800420762e:	be 32 05 00 00       	mov    $0x532,%esi
  8004207633:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420763a:	00 00 00 
  800420763d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207642:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207649:	00 00 00 
  800420764c:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  800420764f:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207656:	00 00 00 
  8004207659:	48 8b 00             	mov    (%rax),%rax
  800420765c:	48 8b 00             	mov    (%rax),%rax
  800420765f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207665:	48 89 c3             	mov    %rax,%rbx
  8004207668:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420766c:	48 89 c7             	mov    %rax,%rdi
  800420766f:	48 b8 d7 26 20 04 80 	movabs $0x80042026d7,%rax
  8004207676:	00 00 00 
  8004207679:	ff d0                	callq  *%rax
  800420767b:	48 39 c3             	cmp    %rax,%rbx
  800420767e:	74 35                	je     80042076b5 <page_check+0x1588>
  8004207680:	48 b9 f8 85 21 04 80 	movabs $0x80042185f8,%rcx
  8004207687:	00 00 00 
  800420768a:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207691:	00 00 00 
  8004207694:	be 46 05 00 00       	mov    $0x546,%esi
  8004207699:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042076a0:	00 00 00 
  80042076a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076a8:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042076af:	00 00 00 
  80042076b2:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  80042076b5:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042076bc:	00 00 00 
  80042076bf:	48 8b 00             	mov    (%rax),%rax
  80042076c2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  80042076c9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042076cd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042076d1:	66 83 f8 01          	cmp    $0x1,%ax
  80042076d5:	74 35                	je     800420770c <page_check+0x15df>
  80042076d7:	48 b9 61 85 21 04 80 	movabs $0x8004218561,%rcx
  80042076de:	00 00 00 
  80042076e1:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042076e8:	00 00 00 
  80042076eb:	be 48 05 00 00       	mov    $0x548,%esi
  80042076f0:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042076f7:	00 00 00 
  80042076fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076ff:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207706:	00 00 00 
  8004207709:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  800420770c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207710:	48 89 c7             	mov    %rax,%rdi
  8004207713:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  800420771a:	00 00 00 
  800420771d:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  800420771f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207723:	48 89 c7             	mov    %rax,%rdi
  8004207726:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  800420772d:	00 00 00 
  8004207730:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207732:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207736:	48 89 c7             	mov    %rax,%rdi
  8004207739:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004207740:	00 00 00 
  8004207743:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004207745:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  800420774c:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004207750:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207757:	00 00 00 
  800420775a:	48 8b 00             	mov    (%rax),%rax
  800420775d:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004207764:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207769:	48 89 ce             	mov    %rcx,%rsi
  800420776c:	48 89 c7             	mov    %rax,%rdi
  800420776f:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004207776:	00 00 00 
  8004207779:	ff d0                	callq  *%rax
  800420777b:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004207782:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207789:	00 00 00 
  800420778c:	48 8b 00             	mov    (%rax),%rax
  800420778f:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004207796:	48 c1 ea 27          	shr    $0x27,%rdx
  800420779a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  80042077a0:	48 c1 e2 03          	shl    $0x3,%rdx
  80042077a4:	48 01 d0             	add    %rdx,%rax
  80042077a7:	48 8b 00             	mov    (%rax),%rax
  80042077aa:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042077b0:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042077b7:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042077be:	48 c1 e8 0c          	shr    $0xc,%rax
  80042077c2:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  80042077c8:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  80042077ce:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042077d5:	00 00 00 
  80042077d8:	48 8b 00             	mov    (%rax),%rax
  80042077db:	48 39 c2             	cmp    %rax,%rdx
  80042077de:	72 35                	jb     8004207815 <page_check+0x16e8>
  80042077e0:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042077e7:	48 89 c1             	mov    %rax,%rcx
  80042077ea:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  80042077f1:	00 00 00 
  80042077f4:	be 4f 05 00 00       	mov    $0x54f,%esi
  80042077f9:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207800:	00 00 00 
  8004207803:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207808:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420780f:	00 00 00 
  8004207812:	41 ff d0             	callq  *%r8
  8004207815:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420781c:	00 00 00 
  800420781f:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004207826:	48 01 d0             	add    %rdx,%rax
  8004207829:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  800420782d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207834:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004207838:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420783d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207844:	00 
  8004207845:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207849:	48 01 d0             	add    %rdx,%rax
  800420784c:	48 8b 00             	mov    (%rax),%rax
  800420784f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207855:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  800420785c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004207863:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207867:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  800420786d:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004207873:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420787a:	00 00 00 
  800420787d:	48 8b 00             	mov    (%rax),%rax
  8004207880:	48 39 c2             	cmp    %rax,%rdx
  8004207883:	72 35                	jb     80042078ba <page_check+0x178d>
  8004207885:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420788c:	48 89 c1             	mov    %rax,%rcx
  800420788f:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004207896:	00 00 00 
  8004207899:	be 50 05 00 00       	mov    $0x550,%esi
  800420789e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042078a5:	00 00 00 
  80042078a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078ad:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042078b4:	00 00 00 
  80042078b7:	41 ff d0             	callq  *%r8
  80042078ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042078c1:	00 00 00 
  80042078c4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042078cb:	48 01 d0             	add    %rdx,%rax
  80042078ce:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  80042078d2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042078d9:	48 c1 e8 15          	shr    $0x15,%rax
  80042078dd:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042078e2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042078e9:	00 
  80042078ea:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042078ee:	48 01 d0             	add    %rdx,%rax
  80042078f1:	48 8b 00             	mov    (%rax),%rax
  80042078f4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042078fa:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004207901:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207908:	48 c1 e8 0c          	shr    $0xc,%rax
  800420790c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004207912:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004207918:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420791f:	00 00 00 
  8004207922:	48 8b 00             	mov    (%rax),%rax
  8004207925:	48 39 c2             	cmp    %rax,%rdx
  8004207928:	72 35                	jb     800420795f <page_check+0x1832>
  800420792a:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207931:	48 89 c1             	mov    %rax,%rcx
  8004207934:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  800420793b:	00 00 00 
  800420793e:	be 51 05 00 00       	mov    $0x551,%esi
  8004207943:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  800420794a:	00 00 00 
  800420794d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207952:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207959:	00 00 00 
  800420795c:	41 ff d0             	callq  *%r8
  800420795f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207966:	00 00 00 
  8004207969:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207970:	48 01 d0             	add    %rdx,%rax
  8004207973:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  800420797a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207981:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207985:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420798a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207991:	00 
  8004207992:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004207999:	48 01 c2             	add    %rax,%rdx
  800420799c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042079a3:	48 39 c2             	cmp    %rax,%rdx
  80042079a6:	74 35                	je     80042079dd <page_check+0x18b0>
  80042079a8:	48 b9 20 86 21 04 80 	movabs $0x8004218620,%rcx
  80042079af:	00 00 00 
  80042079b2:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  80042079b9:	00 00 00 
  80042079bc:	be 52 05 00 00       	mov    $0x552,%esi
  80042079c1:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042079c8:	00 00 00 
  80042079cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042079d0:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042079d7:	00 00 00 
  80042079da:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  80042079dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042079e1:	48 89 c7             	mov    %rax,%rdi
  80042079e4:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  80042079eb:	00 00 00 
  80042079ee:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042079f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042079f4:	48 89 c7             	mov    %rax,%rdi
  80042079f7:	48 b8 6d 27 20 04 80 	movabs $0x800420276d,%rax
  80042079fe:	00 00 00 
  8004207a01:	ff d0                	callq  *%rax
  8004207a03:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207a08:	be ff 00 00 00       	mov    $0xff,%esi
  8004207a0d:	48 89 c7             	mov    %rax,%rdi
  8004207a10:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004207a17:	00 00 00 
  8004207a1a:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004207a1c:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207a23:	00 00 00 
  8004207a26:	48 8b 00             	mov    (%rax),%rax
  8004207a29:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207a2e:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a33:	48 89 c7             	mov    %rax,%rdi
  8004207a36:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004207a3d:	00 00 00 
  8004207a40:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004207a42:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207a49:	00 00 00 
  8004207a4c:	48 8b 00             	mov    (%rax),%rax
  8004207a4f:	48 8b 00             	mov    (%rax),%rax
  8004207a52:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207a58:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004207a5f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207a66:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207a6a:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004207a70:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004207a76:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004207a7d:	00 00 00 
  8004207a80:	48 8b 00             	mov    (%rax),%rax
  8004207a83:	48 39 c2             	cmp    %rax,%rdx
  8004207a86:	72 35                	jb     8004207abd <page_check+0x1990>
  8004207a88:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207a8f:	48 89 c1             	mov    %rax,%rcx
  8004207a92:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004207a99:	00 00 00 
  8004207a9c:	be 58 05 00 00       	mov    $0x558,%esi
  8004207aa1:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207aa8:	00 00 00 
  8004207aab:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ab0:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207ab7:	00 00 00 
  8004207aba:	41 ff d0             	callq  *%r8
  8004207abd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207ac4:	00 00 00 
  8004207ac7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207ace:	48 01 d0             	add    %rdx,%rax
  8004207ad1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207ad5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004207ad9:	48 8b 00             	mov    (%rax),%rax
  8004207adc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207ae2:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004207ae9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207af0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207af4:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004207afa:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004207b00:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004207b07:	00 00 00 
  8004207b0a:	48 8b 00             	mov    (%rax),%rax
  8004207b0d:	48 39 c2             	cmp    %rax,%rdx
  8004207b10:	72 35                	jb     8004207b47 <page_check+0x1a1a>
  8004207b12:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207b19:	48 89 c1             	mov    %rax,%rcx
  8004207b1c:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004207b23:	00 00 00 
  8004207b26:	be 59 05 00 00       	mov    $0x559,%esi
  8004207b2b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207b32:	00 00 00 
  8004207b35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207b3a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207b41:	00 00 00 
  8004207b44:	41 ff d0             	callq  *%r8
  8004207b47:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207b4e:	00 00 00 
  8004207b51:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207b58:	48 01 d0             	add    %rdx,%rax
  8004207b5b:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004207b5f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207b63:	48 8b 00             	mov    (%rax),%rax
  8004207b66:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207b6c:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004207b73:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207b7a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207b7e:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004207b84:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004207b8a:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004207b91:	00 00 00 
  8004207b94:	48 8b 00             	mov    (%rax),%rax
  8004207b97:	48 39 c2             	cmp    %rax,%rdx
  8004207b9a:	72 35                	jb     8004207bd1 <page_check+0x1aa4>
  8004207b9c:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207ba3:	48 89 c1             	mov    %rax,%rcx
  8004207ba6:	48 ba c8 78 21 04 80 	movabs $0x80042178c8,%rdx
  8004207bad:	00 00 00 
  8004207bb0:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004207bb5:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207bbc:	00 00 00 
  8004207bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bc4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207bcb:	00 00 00 
  8004207bce:	41 ff d0             	callq  *%r8
  8004207bd1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207bd8:	00 00 00 
  8004207bdb:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207be2:	48 01 d0             	add    %rdx,%rax
  8004207be5:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004207bec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207bf3:	eb 58                	jmp    8004207c4d <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  8004207bf5:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207bfc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004207bff:	48 63 d2             	movslq %edx,%rdx
  8004207c02:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207c06:	48 01 d0             	add    %rdx,%rax
  8004207c09:	48 8b 00             	mov    (%rax),%rax
  8004207c0c:	83 e0 01             	and    $0x1,%eax
  8004207c0f:	48 85 c0             	test   %rax,%rax
  8004207c12:	74 35                	je     8004207c49 <page_check+0x1b1c>
  8004207c14:	48 b9 38 86 21 04 80 	movabs $0x8004218638,%rcx
  8004207c1b:	00 00 00 
  8004207c1e:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207c25:	00 00 00 
  8004207c28:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004207c2d:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207c34:	00 00 00 
  8004207c37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c3c:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207c43:	00 00 00 
  8004207c46:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004207c49:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207c4d:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004207c54:	7e 9f                	jle    8004207bf5 <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004207c56:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207c5d:	00 00 00 
  8004207c60:	48 8b 00             	mov    (%rax),%rax
  8004207c63:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004207c6a:	48 b8 38 42 37 04 80 	movabs $0x8004374238,%rax
  8004207c71:	00 00 00 
  8004207c74:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207c78:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004207c7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207c7f:	48 89 c7             	mov    %rax,%rdi
  8004207c82:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004207c89:	00 00 00 
  8004207c8c:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207c8e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207c92:	48 89 c7             	mov    %rax,%rdi
  8004207c95:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004207c9c:	00 00 00 
  8004207c9f:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207ca1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207ca5:	48 89 c7             	mov    %rax,%rdi
  8004207ca8:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004207caf:	00 00 00 
  8004207cb2:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207cb4:	be 01 10 00 00       	mov    $0x1001,%esi
  8004207cb9:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207cbe:	48 b8 77 45 20 04 80 	movabs $0x8004204577,%rax
  8004207cc5:	00 00 00 
  8004207cc8:	ff d0                	callq  *%rax
  8004207cca:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207cd1:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207cd6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207cdb:	48 b8 77 45 20 04 80 	movabs $0x8004204577,%rax
  8004207ce2:	00 00 00 
  8004207ce5:	ff d0                	callq  *%rax
  8004207ce7:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207cee:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207cf5:	00 00 00 
  8004207cf8:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004207cff:	76 1d                	jbe    8004207d1e <page_check+0x1bf1>
  8004207d01:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207d08:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207d0f:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207d16:	00 00 00 
  8004207d19:	48 39 c2             	cmp    %rax,%rdx
  8004207d1c:	76 35                	jbe    8004207d53 <page_check+0x1c26>
  8004207d1e:	48 b9 50 86 21 04 80 	movabs $0x8004218650,%rcx
  8004207d25:	00 00 00 
  8004207d28:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207d2f:	00 00 00 
  8004207d32:	be 6b 05 00 00       	mov    $0x56b,%esi
  8004207d37:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207d3e:	00 00 00 
  8004207d41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d46:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207d4d:	00 00 00 
  8004207d50:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004207d53:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207d5a:	00 00 00 
  8004207d5d:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207d64:	76 1d                	jbe    8004207d83 <page_check+0x1c56>
  8004207d66:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207d6d:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207d74:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207d7b:	00 00 00 
  8004207d7e:	48 39 c2             	cmp    %rax,%rdx
  8004207d81:	76 35                	jbe    8004207db8 <page_check+0x1c8b>
  8004207d83:	48 b9 78 86 21 04 80 	movabs $0x8004218678,%rcx
  8004207d8a:	00 00 00 
  8004207d8d:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207d94:	00 00 00 
  8004207d97:	be 6c 05 00 00       	mov    $0x56c,%esi
  8004207d9c:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207da3:	00 00 00 
  8004207da6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207dab:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207db2:	00 00 00 
  8004207db5:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  8004207db8:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207dbf:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207dc4:	48 85 c0             	test   %rax,%rax
  8004207dc7:	75 11                	jne    8004207dda <page_check+0x1cad>
  8004207dc9:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207dd0:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207dd5:	48 85 c0             	test   %rax,%rax
  8004207dd8:	74 35                	je     8004207e0f <page_check+0x1ce2>
  8004207dda:	48 b9 a0 86 21 04 80 	movabs $0x80042186a0,%rcx
  8004207de1:	00 00 00 
  8004207de4:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207deb:	00 00 00 
  8004207dee:	be 6e 05 00 00       	mov    $0x56e,%esi
  8004207df3:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207dfa:	00 00 00 
  8004207dfd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e02:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207e09:	00 00 00 
  8004207e0c:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  8004207e0f:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207e16:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207e1c:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  8004207e23:	76 35                	jbe    8004207e5a <page_check+0x1d2d>
  8004207e25:	48 b9 c7 86 21 04 80 	movabs $0x80042186c7,%rcx
  8004207e2c:	00 00 00 
  8004207e2f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207e36:	00 00 00 
  8004207e39:	be 70 05 00 00       	mov    $0x570,%esi
  8004207e3e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207e45:	00 00 00 
  8004207e48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e4d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207e54:	00 00 00 
  8004207e57:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207e5a:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207e61:	00 00 00 
  8004207e64:	48 8b 00             	mov    (%rax),%rax
  8004207e67:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004207e6e:	48 89 d6             	mov    %rdx,%rsi
  8004207e71:	48 89 c7             	mov    %rax,%rdi
  8004207e74:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004207e7b:	00 00 00 
  8004207e7e:	ff d0                	callq  *%rax
  8004207e80:	48 85 c0             	test   %rax,%rax
  8004207e83:	74 35                	je     8004207eba <page_check+0x1d8d>
  8004207e85:	48 b9 e0 86 21 04 80 	movabs $0x80042186e0,%rcx
  8004207e8c:	00 00 00 
  8004207e8f:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207e96:	00 00 00 
  8004207e99:	be 73 05 00 00       	mov    $0x573,%esi
  8004207e9e:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207ea5:	00 00 00 
  8004207ea8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ead:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207eb4:	00 00 00 
  8004207eb7:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  8004207eba:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207ec1:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207ec8:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207ecf:	00 00 00 
  8004207ed2:	48 8b 00             	mov    (%rax),%rax
  8004207ed5:	48 89 d6             	mov    %rdx,%rsi
  8004207ed8:	48 89 c7             	mov    %rax,%rdi
  8004207edb:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004207ee2:	00 00 00 
  8004207ee5:	ff d0                	callq  *%rax
  8004207ee7:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  8004207eed:	74 35                	je     8004207f24 <page_check+0x1df7>
  8004207eef:	48 b9 08 87 21 04 80 	movabs $0x8004218708,%rcx
  8004207ef6:	00 00 00 
  8004207ef9:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207f00:	00 00 00 
  8004207f03:	be 74 05 00 00       	mov    $0x574,%esi
  8004207f08:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207f0f:	00 00 00 
  8004207f12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f17:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207f1e:	00 00 00 
  8004207f21:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207f24:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207f2b:	00 00 00 
  8004207f2e:	48 8b 00             	mov    (%rax),%rax
  8004207f31:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004207f38:	48 89 d6             	mov    %rdx,%rsi
  8004207f3b:	48 89 c7             	mov    %rax,%rdi
  8004207f3e:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004207f45:	00 00 00 
  8004207f48:	ff d0                	callq  *%rax
  8004207f4a:	48 85 c0             	test   %rax,%rax
  8004207f4d:	74 35                	je     8004207f84 <page_check+0x1e57>
  8004207f4f:	48 b9 38 87 21 04 80 	movabs $0x8004218738,%rcx
  8004207f56:	00 00 00 
  8004207f59:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207f60:	00 00 00 
  8004207f63:	be 75 05 00 00       	mov    $0x575,%esi
  8004207f68:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207f6f:	00 00 00 
  8004207f72:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f77:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207f7e:	00 00 00 
  8004207f81:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207f84:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207f8b:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207f92:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207f99:	00 00 00 
  8004207f9c:	48 8b 00             	mov    (%rax),%rax
  8004207f9f:	48 89 d6             	mov    %rdx,%rsi
  8004207fa2:	48 89 c7             	mov    %rax,%rdi
  8004207fa5:	48 b8 b3 5e 20 04 80 	movabs $0x8004205eb3,%rax
  8004207fac:	00 00 00 
  8004207faf:	ff d0                	callq  *%rax
  8004207fb1:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207fb5:	74 35                	je     8004207fec <page_check+0x1ebf>
  8004207fb7:	48 b9 60 87 21 04 80 	movabs $0x8004218760,%rcx
  8004207fbe:	00 00 00 
  8004207fc1:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004207fc8:	00 00 00 
  8004207fcb:	be 76 05 00 00       	mov    $0x576,%esi
  8004207fd0:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004207fd7:	00 00 00 
  8004207fda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207fdf:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004207fe6:	00 00 00 
  8004207fe9:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207fec:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207ff3:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004207ffa:	00 00 00 
  8004207ffd:	48 8b 00             	mov    (%rax),%rax
  8004208000:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208005:	48 89 ce             	mov    %rcx,%rsi
  8004208008:	48 89 c7             	mov    %rax,%rdi
  800420800b:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004208012:	00 00 00 
  8004208015:	ff d0                	callq  *%rax
  8004208017:	48 8b 00             	mov    (%rax),%rax
  800420801a:	83 e0 1a             	and    $0x1a,%eax
  800420801d:	48 85 c0             	test   %rax,%rax
  8004208020:	75 35                	jne    8004208057 <page_check+0x1f2a>
  8004208022:	48 b9 90 87 21 04 80 	movabs $0x8004218790,%rcx
  8004208029:	00 00 00 
  800420802c:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  8004208033:	00 00 00 
  8004208036:	be 78 05 00 00       	mov    $0x578,%esi
  800420803b:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  8004208042:	00 00 00 
  8004208045:	b8 00 00 00 00       	mov    $0x0,%eax
  800420804a:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004208051:	00 00 00 
  8004208054:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004208057:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420805e:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004208065:	00 00 00 
  8004208068:	48 8b 00             	mov    (%rax),%rax
  800420806b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208070:	48 89 ce             	mov    %rcx,%rsi
  8004208073:	48 89 c7             	mov    %rax,%rdi
  8004208076:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  800420807d:	00 00 00 
  8004208080:	ff d0                	callq  *%rax
  8004208082:	48 8b 00             	mov    (%rax),%rax
  8004208085:	83 e0 04             	and    $0x4,%eax
  8004208088:	48 85 c0             	test   %rax,%rax
  800420808b:	74 35                	je     80042080c2 <page_check+0x1f95>
  800420808d:	48 b9 d8 87 21 04 80 	movabs $0x80042187d8,%rcx
  8004208094:	00 00 00 
  8004208097:	48 ba 51 79 21 04 80 	movabs $0x8004217951,%rdx
  800420809e:	00 00 00 
  80042080a1:	be 79 05 00 00       	mov    $0x579,%esi
  80042080a6:	48 bf 66 79 21 04 80 	movabs $0x8004217966,%rdi
  80042080ad:	00 00 00 
  80042080b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080b5:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042080bc:	00 00 00 
  80042080bf:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  80042080c2:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042080c9:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  80042080d0:	00 00 00 
  80042080d3:	48 8b 00             	mov    (%rax),%rax
  80042080d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042080db:	48 89 ce             	mov    %rcx,%rsi
  80042080de:	48 89 c7             	mov    %rax,%rdi
  80042080e1:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  80042080e8:	00 00 00 
  80042080eb:	ff d0                	callq  *%rax
  80042080ed:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  80042080f4:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042080fb:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004208101:	48 89 c1             	mov    %rax,%rcx
  8004208104:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420810b:	00 00 00 
  800420810e:	48 8b 00             	mov    (%rax),%rax
  8004208111:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208116:	48 89 ce             	mov    %rcx,%rsi
  8004208119:	48 89 c7             	mov    %rax,%rdi
  800420811c:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004208123:	00 00 00 
  8004208126:	ff d0                	callq  *%rax
  8004208128:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  800420812f:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004208136:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420813d:	00 00 00 
  8004208140:	48 8b 00             	mov    (%rax),%rax
  8004208143:	ba 00 00 00 00       	mov    $0x0,%edx
  8004208148:	48 89 ce             	mov    %rcx,%rsi
  800420814b:	48 89 c7             	mov    %rax,%rdi
  800420814e:	48 b8 a2 3c 20 04 80 	movabs $0x8004203ca2,%rax
  8004208155:	00 00 00 
  8004208158:	ff d0                	callq  *%rax
  800420815a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004208161:	48 bf 0b 88 21 04 80 	movabs $0x800421880b,%rdi
  8004208168:	00 00 00 
  800420816b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208170:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004208177:	00 00 00 
  800420817a:	ff d2                	callq  *%rdx
}
  800420817c:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004208183:	5b                   	pop    %rbx
  8004208184:	5d                   	pop    %rbp
  8004208185:	c3                   	retq   

0000008004208186 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004208186:	55                   	push   %rbp
  8004208187:	48 89 e5             	mov    %rsp,%rbp
  800420818a:	48 83 ec 08          	sub    $0x8,%rsp
  800420818e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004208192:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208196:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  800420819d:	00 00 00 
  80042081a0:	48 8b 00             	mov    (%rax),%rax
  80042081a3:	48 29 c2             	sub    %rax,%rdx
  80042081a6:	48 89 d0             	mov    %rdx,%rax
  80042081a9:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042081ad:	c9                   	leaveq 
  80042081ae:	c3                   	retq   

00000080042081af <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042081af:	55                   	push   %rbp
  80042081b0:	48 89 e5             	mov    %rsp,%rbp
  80042081b3:	48 83 ec 08          	sub    $0x8,%rsp
  80042081b7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042081bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042081bf:	48 89 c7             	mov    %rax,%rdi
  80042081c2:	48 b8 86 81 20 04 80 	movabs $0x8004208186,%rax
  80042081c9:	00 00 00 
  80042081cc:	ff d0                	callq  *%rax
  80042081ce:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042081d2:	c9                   	leaveq 
  80042081d3:	c3                   	retq   

00000080042081d4 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042081d4:	55                   	push   %rbp
  80042081d5:	48 89 e5             	mov    %rsp,%rbp
  80042081d8:	48 83 ec 10          	sub    $0x10,%rsp
  80042081dc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042081e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042081e4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042081e8:	48 89 c2             	mov    %rax,%rdx
  80042081eb:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042081f2:	00 00 00 
  80042081f5:	48 8b 00             	mov    (%rax),%rax
  80042081f8:	48 39 c2             	cmp    %rax,%rdx
  80042081fb:	72 2a                	jb     8004208227 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042081fd:	48 ba 28 88 21 04 80 	movabs $0x8004218828,%rdx
  8004208204:	00 00 00 
  8004208207:	be 54 00 00 00       	mov    $0x54,%esi
  800420820c:	48 bf 47 88 21 04 80 	movabs $0x8004218847,%rdi
  8004208213:	00 00 00 
  8004208216:	b8 00 00 00 00       	mov    $0x0,%eax
  800420821b:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004208222:	00 00 00 
  8004208225:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004208227:	48 b8 80 57 37 04 80 	movabs $0x8004375780,%rax
  800420822e:	00 00 00 
  8004208231:	48 8b 00             	mov    (%rax),%rax
  8004208234:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208238:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420823c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208240:	48 01 d0             	add    %rdx,%rax
}
  8004208243:	c9                   	leaveq 
  8004208244:	c3                   	retq   

0000008004208245 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004208245:	55                   	push   %rbp
  8004208246:	48 89 e5             	mov    %rsp,%rbp
  8004208249:	48 83 ec 20          	sub    $0x20,%rsp
  800420824d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004208251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208255:	48 89 c7             	mov    %rax,%rdi
  8004208258:	48 b8 af 81 20 04 80 	movabs $0x80042081af,%rax
  800420825f:	00 00 00 
  8004208262:	ff d0                	callq  *%rax
  8004208264:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208268:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420826c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208270:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004208273:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208276:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800420827d:	00 00 00 
  8004208280:	48 8b 00             	mov    (%rax),%rax
  8004208283:	48 39 c2             	cmp    %rax,%rdx
  8004208286:	72 32                	jb     80042082ba <page2kva+0x75>
  8004208288:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420828c:	48 89 c1             	mov    %rax,%rcx
  800420828f:	48 ba 58 88 21 04 80 	movabs $0x8004218858,%rdx
  8004208296:	00 00 00 
  8004208299:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420829e:	48 bf 47 88 21 04 80 	movabs $0x8004218847,%rdi
  80042082a5:	00 00 00 
  80042082a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042082ad:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042082b4:	00 00 00 
  80042082b7:	41 ff d0             	callq  *%r8
  80042082ba:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042082c1:	00 00 00 
  80042082c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042082c8:	48 01 d0             	add    %rdx,%rax
}
  80042082cb:	c9                   	leaveq 
  80042082cc:	c3                   	retq   

00000080042082cd <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  80042082cd:	55                   	push   %rbp
  80042082ce:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  80042082d1:	48 bf 60 b9 22 04 80 	movabs $0x800422b960,%rdi
  80042082d8:	00 00 00 
  80042082db:	48 b8 bc 62 21 04 80 	movabs $0x80042162bc,%rax
  80042082e2:	00 00 00 
  80042082e5:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  80042082e7:	f3 90                	pause  
}
  80042082e9:	5d                   	pop    %rbp
  80042082ea:	c3                   	retq   

00000080042082eb <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  80042082eb:	55                   	push   %rbp
  80042082ec:	48 89 e5             	mov    %rsp,%rbp
  80042082ef:	53                   	push   %rbx
  80042082f0:	48 83 ec 28          	sub    $0x28,%rsp
  80042082f4:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042082f7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042082fb:	89 d0                	mov    %edx,%eax
  80042082fd:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004208300:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004208304:	75 41                	jne    8004208347 <envid2env+0x5c>
		*env_store = curenv;
  8004208306:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420830d:	00 00 00 
  8004208310:	ff d0                	callq  *%rax
  8004208312:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004208319:	00 00 00 
  800420831c:	48 98                	cltq   
  800420831e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208322:	48 89 c1             	mov    %rax,%rcx
  8004208325:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208329:	48 01 c8             	add    %rcx,%rax
  800420832c:	48 01 d0             	add    %rdx,%rax
  800420832f:	48 83 c0 08          	add    $0x8,%rax
  8004208333:	48 8b 10             	mov    (%rax),%rdx
  8004208336:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420833a:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  800420833d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208342:	e9 fd 00 00 00       	jmpq   8004208444 <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004208347:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420834e:	00 00 00 
  8004208351:	48 8b 10             	mov    (%rax),%rdx
  8004208354:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004208357:	48 98                	cltq   
  8004208359:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420835e:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  8004208365:	48 01 d0             	add    %rdx,%rax
  8004208368:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  800420836c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208370:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208376:	85 c0                	test   %eax,%eax
  8004208378:	74 0f                	je     8004208389 <envid2env+0x9e>
  800420837a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420837e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208384:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004208387:	74 15                	je     800420839e <envid2env+0xb3>
		*env_store = 0;
  8004208389:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420838d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004208394:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004208399:	e9 a6 00 00 00       	jmpq   8004208444 <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  800420839e:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  80042083a2:	0f 84 8c 00 00 00    	je     8004208434 <envid2env+0x149>
  80042083a8:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042083af:	00 00 00 
  80042083b2:	ff d0                	callq  *%rax
  80042083b4:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042083bb:	00 00 00 
  80042083be:	48 98                	cltq   
  80042083c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042083c4:	48 89 c1             	mov    %rax,%rcx
  80042083c7:	48 c1 e1 04          	shl    $0x4,%rcx
  80042083cb:	48 01 c8             	add    %rcx,%rax
  80042083ce:	48 01 d0             	add    %rdx,%rax
  80042083d1:	48 83 c0 08          	add    $0x8,%rax
  80042083d5:	48 8b 00             	mov    (%rax),%rax
  80042083d8:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042083dc:	74 56                	je     8004208434 <envid2env+0x149>
  80042083de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083e2:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  80042083e8:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042083ef:	00 00 00 
  80042083f2:	ff d0                	callq  *%rax
  80042083f4:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042083fb:	00 00 00 
  80042083fe:	48 98                	cltq   
  8004208400:	48 c1 e0 03          	shl    $0x3,%rax
  8004208404:	48 89 c1             	mov    %rax,%rcx
  8004208407:	48 c1 e1 04          	shl    $0x4,%rcx
  800420840b:	48 01 c8             	add    %rcx,%rax
  800420840e:	48 01 d0             	add    %rdx,%rax
  8004208411:	48 83 c0 08          	add    $0x8,%rax
  8004208415:	48 8b 00             	mov    (%rax),%rax
  8004208418:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420841e:	39 c3                	cmp    %eax,%ebx
  8004208420:	74 12                	je     8004208434 <envid2env+0x149>
		*env_store = 0;
  8004208422:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208426:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420842d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004208432:	eb 10                	jmp    8004208444 <envid2env+0x159>
	}

	*env_store = e;
  8004208434:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208438:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420843c:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  800420843f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208444:	48 83 c4 28          	add    $0x28,%rsp
  8004208448:	5b                   	pop    %rbx
  8004208449:	5d                   	pop    %rbp
  800420844a:	c3                   	retq   

000000800420844b <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  800420844b:	55                   	push   %rbp
  800420844c:	48 89 e5             	mov    %rsp,%rbp
  800420844f:	48 83 ec 10          	sub    $0x10,%rsp
	// LAB 3: Your code here.

	// Per-CPU part of the initialization

	size_t i;
	struct Env* last = NULL;
  8004208453:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420845a:	00 
	for (i = 0; i < NENV; i++) {
  800420845b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208462:	00 
  8004208463:	e9 eb 00 00 00       	jmpq   8004208553 <env_init+0x108>
		envs[i].env_status=ENV_FREE;
  8004208468:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420846f:	00 00 00 
  8004208472:	48 8b 10             	mov    (%rax),%rdx
  8004208475:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208479:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  8004208480:	48 01 d0             	add    %rdx,%rax
  8004208483:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  800420848a:	00 00 00 
		envs[i].env_id = 0;
  800420848d:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  8004208494:	00 00 00 
  8004208497:	48 8b 10             	mov    (%rax),%rdx
  800420849a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420849e:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  80042084a5:	48 01 d0             	add    %rdx,%rax
  80042084a8:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  80042084af:	00 00 00 
		envs[i].env_link = NULL;
  80042084b2:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  80042084b9:	00 00 00 
  80042084bc:	48 8b 10             	mov    (%rax),%rdx
  80042084bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084c3:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  80042084ca:	48 01 d0             	add    %rdx,%rax
  80042084cd:	48 c7 80 c0 00 00 00 	movq   $0x0,0xc0(%rax)
  80042084d4:	00 00 00 00 
		if(last)
  80042084d8:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042084dd:	74 28                	je     8004208507 <env_init+0xbc>
			last->env_link = &envs[i];
  80042084df:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  80042084e6:	00 00 00 
  80042084e9:	48 8b 10             	mov    (%rax),%rdx
  80042084ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042084f0:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  80042084f7:	48 01 c2             	add    %rax,%rdx
  80042084fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084fe:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004208505:	eb 28                	jmp    800420852f <env_init+0xe4>
		else
			env_free_list = &envs[i];
  8004208507:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420850e:	00 00 00 
  8004208511:	48 8b 10             	mov    (%rax),%rdx
  8004208514:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208518:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420851f:	48 01 c2             	add    %rax,%rdx
  8004208522:	48 b8 60 42 37 04 80 	movabs $0x8004374260,%rax
  8004208529:	00 00 00 
  800420852c:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  800420852f:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  8004208536:	00 00 00 
  8004208539:	48 8b 10             	mov    (%rax),%rdx
  800420853c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208540:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  8004208547:	48 01 d0             	add    %rdx,%rax
  800420854a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	// Per-CPU part of the initialization

	size_t i;
	struct Env* last = NULL;
	for (i = 0; i < NENV; i++) {
  800420854e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208553:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  800420855a:	00 
  800420855b:	0f 86 07 ff ff ff    	jbe    8004208468 <env_init+0x1d>
		last = &envs[i];
	}
	//modified


	env_init_percpu();
  8004208561:	48 b8 6f 85 20 04 80 	movabs $0x800420856f,%rax
  8004208568:	00 00 00 
  800420856b:	ff d0                	callq  *%rax
}
  800420856d:	c9                   	leaveq 
  800420856e:	c3                   	retq   

000000800420856f <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  800420856f:	55                   	push   %rbp
  8004208570:	48 89 e5             	mov    %rsp,%rbp
  8004208573:	53                   	push   %rbx
  8004208574:	48 83 ec 10          	sub    $0x10,%rsp
  8004208578:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420857f:	00 00 00 
  8004208582:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

    static __inline void
lgdt(void *p)
{
    __asm __volatile("lgdt (%0)" : : "r" (p));
  8004208586:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420858a:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  800420858d:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208592:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004208594:	b8 23 00 00 00       	mov    $0x23,%eax
  8004208599:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420859b:	b8 10 00 00 00       	mov    $0x10,%eax
  80042085a0:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  80042085a2:	b8 10 00 00 00       	mov    $0x10,%eax
  80042085a7:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  80042085a9:	b8 10 00 00 00       	mov    $0x10,%eax
  80042085ae:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042085b0:	b8 08 00 00 00       	mov    $0x8,%eax
  80042085b5:	89 c3                	mov    %eax,%ebx
  80042085b7:	53                   	push   %rbx
  80042085b8:	48 b8 c5 85 20 04 80 	movabs $0x80042085c5,%rax
  80042085bf:	00 00 00 
  80042085c2:	50                   	push   %rax
  80042085c3:	48 cb                	lretq  
  80042085c5:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

    static __inline void
lldt(uint16_t sel)
{
    __asm __volatile("lldt %0" : : "r" (sel));
  80042085cb:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042085cf:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  80042085d2:	48 83 c4 10          	add    $0x10,%rsp
  80042085d6:	5b                   	pop    %rbx
  80042085d7:	5d                   	pop    %rbp
  80042085d8:	c3                   	retq   

00000080042085d9 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  80042085d9:	55                   	push   %rbp
  80042085da:	48 89 e5             	mov    %rsp,%rbp
  80042085dd:	48 83 ec 20          	sub    $0x20,%rsp
  80042085e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042085e5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042085ec:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(0)))
  80042085ed:	bf 00 00 00 00       	mov    $0x0,%edi
  80042085f2:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  80042085f9:	00 00 00 
  80042085fc:	ff d0                	callq  *%rax
  80042085fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208602:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004208607:	75 0a                	jne    8004208613 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004208609:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420860e:	e9 91 00 00 00       	jmpq   80042086a4 <env_setup_vm+0xcb>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	e->env_pml4e=page2kva(p);
  8004208613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208617:	48 89 c7             	mov    %rax,%rdi
  800420861a:	48 b8 45 82 20 04 80 	movabs $0x8004208245,%rax
  8004208621:	00 00 00 
  8004208624:	ff d0                	callq  *%rax
  8004208626:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420862a:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3=page2pa(p);
  8004208631:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208635:	48 89 c7             	mov    %rax,%rdi
  8004208638:	48 b8 af 81 20 04 80 	movabs $0x80042081af,%rax
  800420863f:	00 00 00 
  8004208642:	ff d0                	callq  *%rax
  8004208644:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208648:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	memcpy(e->env_pml4e,boot_pml4e,PGSIZE);  
  800420864f:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  8004208656:	00 00 00 
  8004208659:	48 8b 08             	mov    (%rax),%rcx
  800420865c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208660:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208667:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420866c:	48 89 ce             	mov    %rcx,%rsi
  800420866f:	48 89 c7             	mov    %rax,%rdi
  8004208672:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  8004208679:	00 00 00 
  800420867c:	ff d0                	callq  *%rax

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  800420867e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208682:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208689:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420868d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208691:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208698:	48 83 c8 05          	or     $0x5,%rax
  800420869c:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  800420869f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042086a4:	c9                   	leaveq 
  80042086a5:	c3                   	retq   

00000080042086a6 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042086a6:	55                   	push   %rbp
  80042086a7:	48 89 e5             	mov    %rsp,%rbp
  80042086aa:	48 83 ec 30          	sub    $0x30,%rsp
  80042086ae:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042086b2:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042086b5:	48 b8 60 42 37 04 80 	movabs $0x8004374260,%rax
  80042086bc:	00 00 00 
  80042086bf:	48 8b 00             	mov    (%rax),%rax
  80042086c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042086c6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042086cb:	75 0a                	jne    80042086d7 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042086cd:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042086d2:	e9 76 01 00 00       	jmpq   800420884d <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042086d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086db:	48 89 c7             	mov    %rax,%rdi
  80042086de:	48 b8 d9 85 20 04 80 	movabs $0x80042085d9,%rax
  80042086e5:	00 00 00 
  80042086e8:	ff d0                	callq  *%rax
  80042086ea:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042086ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042086f1:	79 08                	jns    80042086fb <env_alloc+0x55>
		return r;
  80042086f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042086f6:	e9 52 01 00 00       	jmpq   800420884d <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  80042086fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086ff:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208705:	05 00 10 00 00       	add    $0x1000,%eax
  800420870a:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  800420870f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004208712:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208716:	7f 07                	jg     800420871f <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208718:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  800420871f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208723:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420872a:	00 00 00 
  800420872d:	48 8b 00             	mov    (%rax),%rax
  8004208730:	48 29 c2             	sub    %rax,%rdx
  8004208733:	48 89 d0             	mov    %rdx,%rax
  8004208736:	48 c1 f8 04          	sar    $0x4,%rax
  800420873a:	48 89 c2             	mov    %rax,%rdx
  800420873d:	48 b8 a7 37 bd e9 4d 	movabs $0xd37a6f4de9bd37a7,%rax
  8004208744:	6f 7a d3 
  8004208747:	48 0f af c2          	imul   %rdx,%rax
  800420874b:	0b 45 fc             	or     -0x4(%rbp),%eax
  800420874e:	89 c2                	mov    %eax,%edx
  8004208750:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208754:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  800420875a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420875e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208761:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208767:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420876b:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004208772:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004208775:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208779:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208780:	00 00 00 
	e->env_runs = 0;
  8004208783:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208787:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  800420878e:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208791:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208795:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420879a:	be 00 00 00 00       	mov    $0x0,%esi
  800420879f:	48 89 c7             	mov    %rax,%rdi
  80042087a2:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042087a9:	00 00 00 
  80042087ac:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  80042087ae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087b2:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042087b9:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042087bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087bf:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042087c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087c9:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042087d0:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042087d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087d6:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  80042087db:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042087e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087e6:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  80042087ed:	1b 00 

	// Enable interrupts while in user mode.


	// LAB 4: Your code here.
	e->env_tf.tf_eflags |= FL_IF;
  80042087ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042087f3:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80042087fa:	80 cc 02             	or     $0x2,%ah
  80042087fd:	48 89 c2             	mov    %rax,%rdx
  8004208800:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208804:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)


	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  800420880b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420880f:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208816:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  800420881a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420881e:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004208825:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208829:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004208830:	48 b8 60 42 37 04 80 	movabs $0x8004374260,%rax
  8004208837:	00 00 00 
  800420883a:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  800420883d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208841:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208845:	48 89 10             	mov    %rdx,(%rax)


	//cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	return 0;
  8004208848:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420884d:	c9                   	leaveq 
  800420884e:	c3                   	retq   

000000800420884f <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  800420884f:	55                   	push   %rbp
  8004208850:	48 89 e5             	mov    %rsp,%rbp
  8004208853:	48 83 ec 50          	sub    $0x50,%rsp
  8004208857:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420885b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420885f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)

	size_t i=ROUNDDOWN((size_t)va,PGSIZE);
  8004208863:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208867:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420886b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420886f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208875:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	struct PageInfo *newPage;
	while (i<ROUNDUP(((size_t)va)+len,PGSIZE))
  8004208879:	e9 a3 00 00 00       	jmpq   8004208921 <region_alloc+0xd2>
	{
		
		
		if (!(newPage=page_alloc(PGSIZE)))
  800420887e:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004208883:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  800420888a:	00 00 00 
  800420888d:	ff d0                	callq  *%rax
  800420888f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208893:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004208898:	75 2a                	jne    80042088c4 <region_alloc+0x75>
			panic("region_alloc: page_alloc failed\n");
  800420889a:	48 ba 80 88 21 04 80 	movabs $0x8004218880,%rdx
  80042088a1:	00 00 00 
  80042088a4:	be be 01 00 00       	mov    $0x1be,%esi
  80042088a9:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  80042088b0:	00 00 00 
  80042088b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088b8:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  80042088bf:	00 00 00 
  80042088c2:	ff d1                	callq  *%rcx
		if (page_insert(e->env_pml4e, newPage, (void*)i, PTE_U | PTE_W)!=0)	
  80042088c4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042088c8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042088cc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042088d3:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  80042088d7:	b9 06 00 00 00       	mov    $0x6,%ecx
  80042088dc:	48 89 c7             	mov    %rax,%rdi
  80042088df:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  80042088e6:	00 00 00 
  80042088e9:	ff d0                	callq  *%rax
  80042088eb:	85 c0                	test   %eax,%eax
  80042088ed:	74 2a                	je     8004208919 <region_alloc+0xca>
			panic("region_alloc: page_insert failed\n");
  80042088ef:	48 ba b0 88 21 04 80 	movabs $0x80042188b0,%rdx
  80042088f6:	00 00 00 
  80042088f9:	be c0 01 00 00       	mov    $0x1c0,%esi
  80042088fe:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  8004208905:	00 00 00 
  8004208908:	b8 00 00 00 00       	mov    $0x0,%eax
  800420890d:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004208914:	00 00 00 
  8004208917:	ff d1                	callq  *%rcx
		i+=PGSIZE;
  8004208919:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004208920:	00 
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)

	size_t i=ROUNDDOWN((size_t)va,PGSIZE);
	struct PageInfo *newPage;
	while (i<ROUNDUP(((size_t)va)+len,PGSIZE))
  8004208921:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004208928:	00 
  8004208929:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420892d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208931:	48 01 c2             	add    %rax,%rdx
  8004208934:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208938:	48 01 d0             	add    %rdx,%rax
  800420893b:	48 83 e8 01          	sub    $0x1,%rax
  800420893f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208943:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208947:	ba 00 00 00 00       	mov    $0x0,%edx
  800420894c:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004208950:	48 89 d0             	mov    %rdx,%rax
  8004208953:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004208957:	48 29 c2             	sub    %rax,%rdx
  800420895a:	48 89 d0             	mov    %rdx,%rax
  800420895d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208961:	0f 87 17 ff ff ff    	ja     800420887e <region_alloc+0x2f>
			panic("region_alloc: page_insert failed\n");
		i+=PGSIZE;
	}


}
  8004208967:	c9                   	leaveq 
  8004208968:	c3                   	retq   

0000008004208969 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004208969:	55                   	push   %rbp
  800420896a:	48 89 e5             	mov    %rsp,%rbp
  800420896d:	53                   	push   %rbx
  800420896e:	48 83 ec 48          	sub    $0x48,%rsp
  8004208972:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004208976:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	// LAB 3: Your code here.


	    /* uint32_t multiboot_info; */ 
    /* __asm __volatile("movl %%ebx, %0": "=r" (multiboot_info)); */
    	e->elf = binary;
  800420897a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420897e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004208982:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	struct Proghdr *ph, *eph;

 //    extern char multiboot_info[];
	// // read 1st 2 pages off disk
	// readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
	struct Elf* ELFHDR=(struct Elf*) binary;
  8004208989:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420898d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	// is this a valid ELF?
	if (ELFHDR->e_magic != ELF_MAGIC)
  8004208991:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208995:	8b 00                	mov    (%rax),%eax
  8004208997:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  800420899c:	74 2a                	je     80042089c8 <load_icode+0x5f>
		panic("load_icode: invalid ELF\n");
  800420899e:	48 ba d2 88 21 04 80 	movabs $0x80042188d2,%rdx
  80042089a5:	00 00 00 
  80042089a8:	be 0e 02 00 00       	mov    $0x20e,%esi
  80042089ad:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  80042089b4:	00 00 00 
  80042089b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089bc:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  80042089c3:	00 00 00 
  80042089c6:	ff d1                	callq  *%rcx

	// load each program segment (ignores ph flags)
	// test whether this has written to 0x100000
	ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
  80042089c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089cc:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042089d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089d4:	48 01 d0             	add    %rdx,%rax
  80042089d7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	eph = ph + ELFHDR->e_phnum;
  80042089db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089df:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  80042089e3:	0f b7 c0             	movzwl %ax,%eax
  80042089e6:	48 c1 e0 03          	shl    $0x3,%rax
  80042089ea:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042089f1:	00 
  80042089f2:	48 29 c2             	sub    %rax,%rdx
  80042089f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042089f9:	48 01 d0             	add    %rdx,%rax
  80042089fc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	
	lcr3 (e->env_cr3);
  8004208a00:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208a04:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208a0b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004208a0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208a13:	0f 22 d8             	mov    %rax,%cr3
   
	
	for (; ph < eph; ph++)
  8004208a16:	e9 8e 00 00 00       	jmpq   8004208aa9 <load_icode+0x140>
		if (ph->p_type == ELF_PROG_LOAD)
  8004208a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a1f:	8b 00                	mov    (%rax),%eax
  8004208a21:	83 f8 01             	cmp    $0x1,%eax
  8004208a24:	75 7e                	jne    8004208aa4 <load_icode+0x13b>
		{
			region_alloc (e, (void*) ph->p_va, ph->p_memsz);
  8004208a26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a2a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208a2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a32:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208a36:	48 89 c1             	mov    %rax,%rcx
  8004208a39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208a3d:	48 89 ce             	mov    %rcx,%rsi
  8004208a40:	48 89 c7             	mov    %rax,%rdi
  8004208a43:	48 b8 4f 88 20 04 80 	movabs $0x800420884f,%rax
  8004208a4a:	00 00 00 
  8004208a4d:	ff d0                	callq  *%rax
 			memset ((void *)ph->p_va, 0, ph->p_memsz);
  8004208a4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a53:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208a57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a5b:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208a5f:	be 00 00 00 00       	mov    $0x0,%esi
  8004208a64:	48 89 c7             	mov    %rax,%rdi
  8004208a67:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004208a6e:	00 00 00 
  8004208a71:	ff d0                	callq  *%rax
 			memmove ((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004208a73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a77:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208a7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a7f:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004208a83:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004208a87:	48 01 c1             	add    %rax,%rcx
  8004208a8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a8e:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208a92:	48 89 ce             	mov    %rcx,%rsi
  8004208a95:	48 89 c7             	mov    %rax,%rdi
  8004208a98:	48 b8 db ee 20 04 80 	movabs $0x800420eedb,%rax
  8004208a9f:	00 00 00 
  8004208aa2:	ff d0                	callq  *%rax
	eph = ph + ELFHDR->e_phnum;
	
	lcr3 (e->env_cr3);
   
	
	for (; ph < eph; ph++)
  8004208aa4:	48 83 45 e8 38       	addq   $0x38,-0x18(%rbp)
  8004208aa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208aad:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004208ab1:	0f 82 64 ff ff ff    	jb     8004208a1b <load_icode+0xb2>
		}

	// call the entry point from the ELF header
	// note: does not return!
	
	 lcr3 (boot_cr3);
  8004208ab7:	48 b8 68 57 37 04 80 	movabs $0x8004375768,%rax
  8004208abe:	00 00 00 
  8004208ac1:	48 8b 00             	mov    (%rax),%rax
  8004208ac4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208ac8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208acc:	0f 22 d8             	mov    %rax,%cr3


 //    __asm __volatile("movl %0, %%ebx": : "r" (multiboot_info));
	// ((void (*)(void)) ((uint32_t)(ELFHDR->e_entry)))();
	e->env_tf.tf_rip = ELFHDR->e_entry;  
  8004208acf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208ad3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208ad7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208adb:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->env_tf.tf_rsp = USTACKTOP;  
  8004208ae2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208ae6:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004208aeb:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	region_alloc(e,(void*)USTACKTOP - PGSIZE,PGSIZE);  
  8004208af2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208af6:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208afb:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208b00:	48 89 c7             	mov    %rax,%rdi
  8004208b03:	48 b8 4f 88 20 04 80 	movabs $0x800420884f,%rax
  8004208b0a:	00 00 00 
  8004208b0d:	ff d0                	callq  *%rax


}
  8004208b0f:	48 83 c4 48          	add    $0x48,%rsp
  8004208b13:	5b                   	pop    %rbx
  8004208b14:	5d                   	pop    %rbp
  8004208b15:	c3                   	retq   

0000008004208b16 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004208b16:	55                   	push   %rbp
  8004208b17:	48 89 e5             	mov    %rsp,%rbp
  8004208b1a:	48 83 ec 20          	sub    $0x20,%rsp
  8004208b1e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208b22:	89 75 e4             	mov    %esi,-0x1c(%rbp)

	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

   struct Env *e;
   if (env_alloc(&e, 0)<0)
  8004208b25:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  8004208b29:	be 00 00 00 00       	mov    $0x0,%esi
  8004208b2e:	48 89 c7             	mov    %rax,%rdi
  8004208b31:	48 b8 a6 86 20 04 80 	movabs $0x80042086a6,%rax
  8004208b38:	00 00 00 
  8004208b3b:	ff d0                	callq  *%rax
  8004208b3d:	85 c0                	test   %eax,%eax
  8004208b3f:	79 2a                	jns    8004208b6b <env_create+0x55>
   	  panic("env_create: ");
  8004208b41:	48 ba eb 88 21 04 80 	movabs $0x80042188eb,%rdx
  8004208b48:	00 00 00 
  8004208b4b:	be 41 02 00 00       	mov    $0x241,%esi
  8004208b50:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  8004208b57:	00 00 00 
  8004208b5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b5f:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004208b66:	00 00 00 
  8004208b69:	ff d1                	callq  *%rcx
   load_icode(e, binary);
  8004208b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b6f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208b73:	48 89 d6             	mov    %rdx,%rsi
  8004208b76:	48 89 c7             	mov    %rax,%rdi
  8004208b79:	48 b8 69 89 20 04 80 	movabs $0x8004208969,%rax
  8004208b80:	00 00 00 
  8004208b83:	ff d0                	callq  *%rax
   e->env_type = type;  
  8004208b85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b89:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208b8c:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
   if (e->env_type==ENV_TYPE_FS)
  8004208b92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b96:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004208b9c:	83 f8 01             	cmp    $0x1,%eax
  8004208b9f:	75 19                	jne    8004208bba <env_create+0xa4>
   	  e->env_tf.tf_eflags=FL_IOPL_3|e->env_tf.tf_eflags;
  8004208ba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208ba5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208ba9:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004208bb0:	80 ce 30             	or     $0x30,%dh
  8004208bb3:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  8004208bba:	c9                   	leaveq 
  8004208bbb:	c3                   	retq   

0000008004208bbc <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004208bbc:	55                   	push   %rbp
  8004208bbd:	48 89 e5             	mov    %rsp,%rbp
  8004208bc0:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208bc7:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
#endif

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208bce:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004208bd5:	00 00 00 
  8004208bd8:	ff d0                	callq  *%rax
  8004208bda:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004208be1:	00 00 00 
  8004208be4:	48 98                	cltq   
  8004208be6:	48 c1 e0 03          	shl    $0x3,%rax
  8004208bea:	48 89 c1             	mov    %rax,%rcx
  8004208bed:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208bf1:	48 01 c8             	add    %rcx,%rax
  8004208bf4:	48 01 d0             	add    %rdx,%rax
  8004208bf7:	48 83 c0 08          	add    $0x8,%rax
  8004208bfb:	48 8b 00             	mov    (%rax),%rax
  8004208bfe:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208c05:	75 18                	jne    8004208c1f <env_free+0x63>
		lcr3(boot_cr3);
  8004208c07:	48 b8 68 57 37 04 80 	movabs $0x8004375768,%rax
  8004208c0e:	00 00 00 
  8004208c11:	48 8b 00             	mov    (%rax),%rax
  8004208c14:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004208c18:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208c1c:	0f 22 d8             	mov    %rax,%cr3

	//cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);


	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208c1f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208c26:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208c2d:	48 8b 00             	mov    (%rax),%rax
  8004208c30:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208c36:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c3e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208c42:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004208c45:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208c48:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004208c4f:	00 00 00 
  8004208c52:	48 8b 00             	mov    (%rax),%rax
  8004208c55:	48 39 c2             	cmp    %rax,%rdx
  8004208c58:	72 32                	jb     8004208c8c <env_free+0xd0>
  8004208c5a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c5e:	48 89 c1             	mov    %rax,%rcx
  8004208c61:	48 ba 58 88 21 04 80 	movabs $0x8004218858,%rdx
  8004208c68:	00 00 00 
  8004208c6b:	be 67 02 00 00       	mov    $0x267,%esi
  8004208c70:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  8004208c77:	00 00 00 
  8004208c7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208c7f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004208c86:	00 00 00 
  8004208c89:	41 ff d0             	callq  *%r8
  8004208c8c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208c93:	00 00 00 
  8004208c96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208c9a:	48 01 d0             	add    %rdx,%rax
  8004208c9d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208ca1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208ca8:	00 
  8004208ca9:	e9 ab 02 00 00       	jmpq   8004208f59 <env_free+0x39d>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208cae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208cb2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208cb9:	00 
  8004208cba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208cbe:	48 01 d0             	add    %rdx,%rax
  8004208cc1:	48 8b 00             	mov    (%rax),%rax
  8004208cc4:	83 e0 01             	and    $0x1,%eax
  8004208cc7:	48 85 c0             	test   %rax,%rax
  8004208cca:	75 05                	jne    8004208cd1 <env_free+0x115>
			continue;
  8004208ccc:	e9 83 02 00 00       	jmpq   8004208f54 <env_free+0x398>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208cd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208cd5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208cdc:	00 
  8004208cdd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208ce1:	48 01 d0             	add    %rdx,%rax
  8004208ce4:	48 8b 00             	mov    (%rax),%rax
  8004208ce7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208ced:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208cf1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208cf5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208cf9:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208cfc:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208cff:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004208d06:	00 00 00 
  8004208d09:	48 8b 00             	mov    (%rax),%rax
  8004208d0c:	48 39 c2             	cmp    %rax,%rdx
  8004208d0f:	72 32                	jb     8004208d43 <env_free+0x187>
  8004208d11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208d15:	48 89 c1             	mov    %rax,%rcx
  8004208d18:	48 ba 58 88 21 04 80 	movabs $0x8004218858,%rdx
  8004208d1f:	00 00 00 
  8004208d22:	be 6f 02 00 00       	mov    $0x26f,%esi
  8004208d27:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  8004208d2e:	00 00 00 
  8004208d31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d36:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004208d3d:	00 00 00 
  8004208d40:	41 ff d0             	callq  *%r8
  8004208d43:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208d4a:	00 00 00 
  8004208d4d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208d51:	48 01 d0             	add    %rdx,%rax
  8004208d54:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208d58:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208d5d:	75 07                	jne    8004208d66 <env_free+0x1aa>
  8004208d5f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208d64:	eb 05                	jmp    8004208d6b <env_free+0x1af>
  8004208d66:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208d6b:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208d6e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208d75:	00 
  8004208d76:	e9 6e 01 00 00       	jmpq   8004208ee9 <env_free+0x32d>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208d7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208d7f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208d86:	00 
  8004208d87:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208d8b:	48 01 d0             	add    %rdx,%rax
  8004208d8e:	48 8b 00             	mov    (%rax),%rax
  8004208d91:	83 e0 01             	and    $0x1,%eax
  8004208d94:	48 85 c0             	test   %rax,%rax
  8004208d97:	75 05                	jne    8004208d9e <env_free+0x1e2>
				continue;
  8004208d99:	e9 46 01 00 00       	jmpq   8004208ee4 <env_free+0x328>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208d9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208da2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208da9:	00 
  8004208daa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208dae:	48 01 d0             	add    %rdx,%rax
  8004208db1:	48 8b 00             	mov    (%rax),%rax
  8004208db4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208dba:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208dbe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208dc2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208dc6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208dca:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208dce:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208dd1:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208dd4:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004208ddb:	00 00 00 
  8004208dde:	48 8b 00             	mov    (%rax),%rax
  8004208de1:	48 39 c2             	cmp    %rax,%rdx
  8004208de4:	72 32                	jb     8004208e18 <env_free+0x25c>
  8004208de6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208dea:	48 89 c1             	mov    %rax,%rcx
  8004208ded:	48 ba 58 88 21 04 80 	movabs $0x8004218858,%rdx
  8004208df4:	00 00 00 
  8004208df7:	be 79 02 00 00       	mov    $0x279,%esi
  8004208dfc:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  8004208e03:	00 00 00 
  8004208e06:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208e0b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004208e12:	00 00 00 
  8004208e15:	41 ff d0             	callq  *%r8
  8004208e18:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208e1f:	00 00 00 
  8004208e22:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208e26:	48 01 d0             	add    %rdx,%rax
  8004208e29:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208e2d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004208e34:	00 
  8004208e35:	eb 67                	jmp    8004208e9e <env_free+0x2e2>
				if (pt[pteno] & PTE_P){
  8004208e37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208e3b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208e42:	00 
  8004208e43:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208e47:	48 01 d0             	add    %rdx,%rax
  8004208e4a:	48 8b 00             	mov    (%rax),%rax
  8004208e4d:	83 e0 01             	and    $0x1,%eax
  8004208e50:	48 85 c0             	test   %rax,%rax
  8004208e53:	74 44                	je     8004208e99 <env_free+0x2dd>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208e55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208e59:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208e5d:	48 89 c2             	mov    %rax,%rdx
  8004208e60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e64:	48 c1 e0 15          	shl    $0x15,%rax
  8004208e68:	48 09 c2             	or     %rax,%rdx
  8004208e6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208e6f:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208e73:	48 09 d0             	or     %rdx,%rax
  8004208e76:	48 89 c2             	mov    %rax,%rdx
  8004208e79:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208e80:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208e87:	48 89 d6             	mov    %rdx,%rsi
  8004208e8a:	48 89 c7             	mov    %rax,%rdi
  8004208e8d:	48 b8 24 44 20 04 80 	movabs $0x8004204424,%rax
  8004208e94:	00 00 00 
  8004208e97:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208e99:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208e9e:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208ea5:	00 
  8004208ea6:	76 8f                	jbe    8004208e37 <env_free+0x27b>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208ea8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208eac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208eb3:	00 
  8004208eb4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208eb8:	48 01 d0             	add    %rdx,%rax
  8004208ebb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208ec2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208ec6:	48 89 c7             	mov    %rax,%rdi
  8004208ec9:	48 b8 d4 81 20 04 80 	movabs $0x80042081d4,%rax
  8004208ed0:	00 00 00 
  8004208ed3:	ff d0                	callq  *%rax
  8004208ed5:	48 89 c7             	mov    %rax,%rdi
  8004208ed8:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004208edf:	00 00 00 
  8004208ee2:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208ee4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208ee9:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208eec:	48 98                	cltq   
  8004208eee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208ef2:	0f 87 83 fe ff ff    	ja     8004208d7b <env_free+0x1bf>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208ef8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208efc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208f03:	00 
  8004208f04:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208f08:	48 01 d0             	add    %rdx,%rax
  8004208f0b:	48 8b 00             	mov    (%rax),%rax
  8004208f0e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208f14:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208f18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208f1c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208f23:	00 
  8004208f24:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208f28:	48 01 d0             	add    %rdx,%rax
  8004208f2b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208f32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208f36:	48 89 c7             	mov    %rax,%rdi
  8004208f39:	48 b8 d4 81 20 04 80 	movabs $0x80042081d4,%rax
  8004208f40:	00 00 00 
  8004208f43:	ff d0                	callq  *%rax
  8004208f45:	48 89 c7             	mov    %rax,%rdi
  8004208f48:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004208f4f:	00 00 00 
  8004208f52:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208f54:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208f59:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208f5e:	0f 86 4a fd ff ff    	jbe    8004208cae <env_free+0xf2>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208f64:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208f6b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208f72:	48 8b 00             	mov    (%rax),%rax
  8004208f75:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208f7b:	48 89 c7             	mov    %rax,%rdi
  8004208f7e:	48 b8 d4 81 20 04 80 	movabs $0x80042081d4,%rax
  8004208f85:	00 00 00 
  8004208f88:	ff d0                	callq  *%rax
  8004208f8a:	48 89 c7             	mov    %rax,%rdi
  8004208f8d:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004208f94:	00 00 00 
  8004208f97:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208f99:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208fa0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208fa7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208fae:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208fb5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208fbc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208fc0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208fc7:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208fce:	00 00 00 00 
	e->env_cr3 = 0;
  8004208fd2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208fd9:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208fe0:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208fe4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208fe8:	48 89 c7             	mov    %rax,%rdi
  8004208feb:	48 b8 d4 81 20 04 80 	movabs $0x80042081d4,%rax
  8004208ff2:	00 00 00 
  8004208ff5:	ff d0                	callq  *%rax
  8004208ff7:	48 89 c7             	mov    %rax,%rdi
  8004208ffa:	48 b8 61 3c 20 04 80 	movabs $0x8004203c61,%rax
  8004209001:	00 00 00 
  8004209004:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004209006:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420900d:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004209014:	00 00 00 
	e->env_link = env_free_list;
  8004209017:	48 b8 60 42 37 04 80 	movabs $0x8004374260,%rax
  800420901e:	00 00 00 
  8004209021:	48 8b 10             	mov    (%rax),%rdx
  8004209024:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420902b:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004209032:	48 b8 60 42 37 04 80 	movabs $0x8004374260,%rax
  8004209039:	00 00 00 
  800420903c:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004209043:	48 89 10             	mov    %rdx,(%rax)
}
  8004209046:	c9                   	leaveq 
  8004209047:	c3                   	retq   

0000008004209048 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004209048:	55                   	push   %rbp
  8004209049:	48 89 e5             	mov    %rsp,%rbp
  800420904c:	48 83 ec 10          	sub    $0x10,%rsp
  8004209050:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004209054:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004209058:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420905e:	83 f8 03             	cmp    $0x3,%eax
  8004209061:	75 49                	jne    80042090ac <env_destroy+0x64>
  8004209063:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420906a:	00 00 00 
  800420906d:	ff d0                	callq  *%rax
  800420906f:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209076:	00 00 00 
  8004209079:	48 98                	cltq   
  800420907b:	48 c1 e0 03          	shl    $0x3,%rax
  800420907f:	48 89 c1             	mov    %rax,%rcx
  8004209082:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209086:	48 01 c8             	add    %rcx,%rax
  8004209089:	48 01 d0             	add    %rdx,%rax
  800420908c:	48 83 c0 08          	add    $0x8,%rax
  8004209090:	48 8b 00             	mov    (%rax),%rax
  8004209093:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004209097:	74 13                	je     80042090ac <env_destroy+0x64>
		e->env_status = ENV_DYING;
  8004209099:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420909d:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042090a4:	00 00 00 
		return;
  80042090a7:	e9 89 00 00 00       	jmpq   8004209135 <env_destroy+0xed>
	}

	env_free(e);
  80042090ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042090b0:	48 89 c7             	mov    %rax,%rdi
  80042090b3:	48 b8 bc 8b 20 04 80 	movabs $0x8004208bbc,%rax
  80042090ba:	00 00 00 
  80042090bd:	ff d0                	callq  *%rax
	if (curenv == e) {
  80042090bf:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042090c6:	00 00 00 
  80042090c9:	ff d0                	callq  *%rax
  80042090cb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042090d2:	00 00 00 
  80042090d5:	48 98                	cltq   
  80042090d7:	48 c1 e0 03          	shl    $0x3,%rax
  80042090db:	48 89 c1             	mov    %rax,%rcx
  80042090de:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090e2:	48 01 c8             	add    %rcx,%rax
  80042090e5:	48 01 d0             	add    %rdx,%rax
  80042090e8:	48 83 c0 08          	add    $0x8,%rax
  80042090ec:	48 8b 00             	mov    (%rax),%rax
  80042090ef:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042090f3:	75 40                	jne    8004209135 <env_destroy+0xed>
		curenv = NULL;
  80042090f5:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042090fc:	00 00 00 
  80042090ff:	ff d0                	callq  *%rax
  8004209101:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209108:	00 00 00 
  800420910b:	48 98                	cltq   
  800420910d:	48 c1 e0 03          	shl    $0x3,%rax
  8004209111:	48 89 c1             	mov    %rax,%rcx
  8004209114:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209118:	48 01 c8             	add    %rcx,%rax
  800420911b:	48 01 d0             	add    %rdx,%rax
  800420911e:	48 83 c0 08          	add    $0x8,%rax
  8004209122:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004209129:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  8004209130:	00 00 00 
  8004209133:	ff d0                	callq  *%rax
	}
}
  8004209135:	c9                   	leaveq 
  8004209136:	c3                   	retq   

0000008004209137 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004209137:	55                   	push   %rbp
  8004209138:	48 89 e5             	mov    %rsp,%rbp
  800420913b:	53                   	push   %rbx
  800420913c:	48 83 ec 18          	sub    $0x18,%rsp
  8004209140:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004209144:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420914b:	00 00 00 
  800420914e:	ff d0                	callq  *%rax
  8004209150:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209157:	00 00 00 
  800420915a:	48 98                	cltq   
  800420915c:	48 c1 e0 03          	shl    $0x3,%rax
  8004209160:	48 89 c1             	mov    %rax,%rcx
  8004209163:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209167:	48 01 c8             	add    %rcx,%rax
  800420916a:	48 01 d0             	add    %rdx,%rax
  800420916d:	48 83 c0 08          	add    $0x8,%rax
  8004209171:	48 8b 18             	mov    (%rax),%rbx
  8004209174:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420917b:	00 00 00 
  800420917e:	ff d0                	callq  *%rax
  8004209180:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  8004209186:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  800420918a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420918e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004209193:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004209198:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420919d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  80042091a2:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80042091a7:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  80042091ac:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  80042091b1:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80042091b6:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  80042091bb:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  80042091c0:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  80042091c5:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  80042091ca:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  80042091cf:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  80042091d4:	48 83 c4 78          	add    $0x78,%rsp
  80042091d8:	8e 04 24             	mov    (%rsp),%es
  80042091db:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  80042091df:	48 83 c4 10          	add    $0x10,%rsp
  80042091e3:	48 83 c4 10          	add    $0x10,%rsp
  80042091e7:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  80042091e9:	48 ba f8 88 21 04 80 	movabs $0x80042188f8,%rdx
  80042091f0:	00 00 00 
  80042091f3:	be c5 02 00 00       	mov    $0x2c5,%esi
  80042091f8:	48 bf a1 88 21 04 80 	movabs $0x80042188a1,%rdi
  80042091ff:	00 00 00 
  8004209202:	b8 00 00 00 00       	mov    $0x0,%eax
  8004209207:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420920e:	00 00 00 
  8004209211:	ff d1                	callq  *%rcx

0000008004209213 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004209213:	55                   	push   %rbp
  8004209214:	48 89 e5             	mov    %rsp,%rbp
  8004209217:	48 83 ec 20          	sub    $0x20,%rsp
  800420921b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.

	if (curenv) {
  800420921f:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004209226:	00 00 00 
  8004209229:	ff d0                	callq  *%rax
  800420922b:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209232:	00 00 00 
  8004209235:	48 98                	cltq   
  8004209237:	48 c1 e0 03          	shl    $0x3,%rax
  800420923b:	48 89 c1             	mov    %rax,%rcx
  800420923e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209242:	48 01 c8             	add    %rcx,%rax
  8004209245:	48 01 d0             	add    %rdx,%rax
  8004209248:	48 83 c0 08          	add    $0x8,%rax
  800420924c:	48 8b 00             	mov    (%rax),%rax
  800420924f:	48 85 c0             	test   %rax,%rax
  8004209252:	74 75                	je     80042092c9 <env_run+0xb6>
		if (curenv->env_status == ENV_RUNNING) {
  8004209254:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420925b:	00 00 00 
  800420925e:	ff d0                	callq  *%rax
  8004209260:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209267:	00 00 00 
  800420926a:	48 98                	cltq   
  800420926c:	48 c1 e0 03          	shl    $0x3,%rax
  8004209270:	48 89 c1             	mov    %rax,%rcx
  8004209273:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209277:	48 01 c8             	add    %rcx,%rax
  800420927a:	48 01 d0             	add    %rdx,%rax
  800420927d:	48 83 c0 08          	add    $0x8,%rax
  8004209281:	48 8b 00             	mov    (%rax),%rax
  8004209284:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420928a:	83 f8 03             	cmp    $0x3,%eax
  800420928d:	75 3a                	jne    80042092c9 <env_run+0xb6>
			curenv->env_status = ENV_RUNNABLE;
  800420928f:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004209296:	00 00 00 
  8004209299:	ff d0                	callq  *%rax
  800420929b:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042092a2:	00 00 00 
  80042092a5:	48 98                	cltq   
  80042092a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042092ab:	48 89 c1             	mov    %rax,%rcx
  80042092ae:	48 c1 e1 04          	shl    $0x4,%rcx
  80042092b2:	48 01 c8             	add    %rcx,%rax
  80042092b5:	48 01 d0             	add    %rdx,%rax
  80042092b8:	48 83 c0 08          	add    $0x8,%rax
  80042092bc:	48 8b 00             	mov    (%rax),%rax
  80042092bf:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042092c6:	00 00 00 
		}
	}

	curenv = e;
  80042092c9:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042092d0:	00 00 00 
  80042092d3:	ff d0                	callq  *%rax
  80042092d5:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042092dc:	00 00 00 
  80042092df:	48 98                	cltq   
  80042092e1:	48 c1 e0 03          	shl    $0x3,%rax
  80042092e5:	48 89 c1             	mov    %rax,%rcx
  80042092e8:	48 c1 e1 04          	shl    $0x4,%rcx
  80042092ec:	48 01 c8             	add    %rcx,%rax
  80042092ef:	48 01 d0             	add    %rdx,%rax
  80042092f2:	48 8d 50 08          	lea    0x8(%rax),%rdx
  80042092f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042092fa:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  80042092fd:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004209304:	00 00 00 
  8004209307:	ff d0                	callq  *%rax
  8004209309:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209310:	00 00 00 
  8004209313:	48 98                	cltq   
  8004209315:	48 c1 e0 03          	shl    $0x3,%rax
  8004209319:	48 89 c1             	mov    %rax,%rcx
  800420931c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209320:	48 01 c8             	add    %rcx,%rax
  8004209323:	48 01 d0             	add    %rdx,%rax
  8004209326:	48 83 c0 08          	add    $0x8,%rax
  800420932a:	48 8b 00             	mov    (%rax),%rax
  800420932d:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004209334:	00 00 00 
	curenv->env_runs++;
  8004209337:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420933e:	00 00 00 
  8004209341:	ff d0                	callq  *%rax
  8004209343:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420934a:	00 00 00 
  800420934d:	48 98                	cltq   
  800420934f:	48 c1 e0 03          	shl    $0x3,%rax
  8004209353:	48 89 c1             	mov    %rax,%rcx
  8004209356:	48 c1 e1 04          	shl    $0x4,%rcx
  800420935a:	48 01 c8             	add    %rcx,%rax
  800420935d:	48 01 d0             	add    %rdx,%rax
  8004209360:	48 83 c0 08          	add    $0x8,%rax
  8004209364:	48 8b 00             	mov    (%rax),%rax
  8004209367:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420936d:	83 c2 01             	add    $0x1,%edx
  8004209370:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	lcr3(curenv->env_cr3);
  8004209376:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420937d:	00 00 00 
  8004209380:	ff d0                	callq  *%rax
  8004209382:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004209389:	00 00 00 
  800420938c:	48 98                	cltq   
  800420938e:	48 c1 e0 03          	shl    $0x3,%rax
  8004209392:	48 89 c1             	mov    %rax,%rcx
  8004209395:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209399:	48 01 c8             	add    %rcx,%rax
  800420939c:	48 01 d0             	add    %rdx,%rax
  800420939f:	48 83 c0 08          	add    $0x8,%rax
  80042093a3:	48 8b 00             	mov    (%rax),%rax
  80042093a6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042093ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042093b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042093b5:	0f 22 d8             	mov    %rax,%cr3
	unlock_kernel();
  80042093b8:	48 b8 cd 82 20 04 80 	movabs $0x80042082cd,%rax
  80042093bf:	00 00 00 
  80042093c2:	ff d0                	callq  *%rax
	env_pop_tf(&(curenv->env_tf));
  80042093c4:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  80042093cb:	00 00 00 
  80042093ce:	ff d0                	callq  *%rax
  80042093d0:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042093d7:	00 00 00 
  80042093da:	48 98                	cltq   
  80042093dc:	48 c1 e0 03          	shl    $0x3,%rax
  80042093e0:	48 89 c1             	mov    %rax,%rcx
  80042093e3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042093e7:	48 01 c8             	add    %rcx,%rax
  80042093ea:	48 01 d0             	add    %rdx,%rax
  80042093ed:	48 83 c0 08          	add    $0x8,%rax
  80042093f1:	48 8b 00             	mov    (%rax),%rax
  80042093f4:	48 89 c7             	mov    %rax,%rdi
  80042093f7:	48 b8 37 91 20 04 80 	movabs $0x8004209137,%rax
  80042093fe:	00 00 00 
  8004209401:	ff d0                	callq  *%rax

0000008004209403 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004209403:	55                   	push   %rbp
  8004209404:	48 89 e5             	mov    %rsp,%rbp
  8004209407:	48 83 ec 14          	sub    $0x14,%rsp
  800420940b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  800420940e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209411:	0f b6 c0             	movzbl %al,%eax
  8004209414:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420941b:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420941e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209422:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209425:	ee                   	out    %al,(%dx)
  8004209426:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420942d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004209430:	89 c2                	mov    %eax,%edx
  8004209432:	ec                   	in     (%dx),%al
  8004209433:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  8004209436:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  800420943a:	0f b6 c0             	movzbl %al,%eax
}
  800420943d:	c9                   	leaveq 
  800420943e:	c3                   	retq   

000000800420943f <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  800420943f:	55                   	push   %rbp
  8004209440:	48 89 e5             	mov    %rsp,%rbp
  8004209443:	48 83 ec 18          	sub    $0x18,%rsp
  8004209447:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420944a:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  800420944d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004209450:	0f b6 c0             	movzbl %al,%eax
  8004209453:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  800420945a:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420945d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209461:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209464:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004209465:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004209468:	0f b6 c0             	movzbl %al,%eax
  800420946b:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004209472:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209475:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209479:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420947c:	ee                   	out    %al,(%dx)
}
  800420947d:	c9                   	leaveq 
  800420947e:	c3                   	retq   

000000800420947f <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  800420947f:	55                   	push   %rbp
  8004209480:	48 89 e5             	mov    %rsp,%rbp
  8004209483:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004209487:	48 b8 68 42 37 04 80 	movabs $0x8004374268,%rax
  800420948e:	00 00 00 
  8004209491:	c6 00 01             	movb   $0x1,(%rax)
  8004209494:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  800420949b:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  800420949f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042094a3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042094a6:	ee                   	out    %al,(%dx)
  80042094a7:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  80042094ae:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  80042094b2:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042094b6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042094b9:	ee                   	out    %al,(%dx)
  80042094ba:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  80042094c1:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  80042094c5:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042094c9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042094cc:	ee                   	out    %al,(%dx)
  80042094cd:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  80042094d4:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  80042094d8:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042094dc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042094df:	ee                   	out    %al,(%dx)
  80042094e0:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  80042094e7:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  80042094eb:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042094ef:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042094f2:	ee                   	out    %al,(%dx)
  80042094f3:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  80042094fa:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  80042094fe:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004209502:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004209505:	ee                   	out    %al,(%dx)
  8004209506:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  800420950d:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004209511:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004209515:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004209518:	ee                   	out    %al,(%dx)
  8004209519:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004209520:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004209524:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004209528:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420952b:	ee                   	out    %al,(%dx)
  800420952c:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004209533:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004209537:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  800420953b:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420953e:	ee                   	out    %al,(%dx)
  800420953f:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004209546:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  800420954a:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  800420954e:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004209551:	ee                   	out    %al,(%dx)
  8004209552:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004209559:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  800420955d:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004209561:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004209564:	ee                   	out    %al,(%dx)
  8004209565:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  800420956c:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004209570:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004209574:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209577:	ee                   	out    %al,(%dx)
  8004209578:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  800420957f:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004209583:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209587:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420958a:	ee                   	out    %al,(%dx)
  800420958b:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004209592:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004209596:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  800420959a:	8b 55 94             	mov    -0x6c(%rbp),%edx
  800420959d:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  800420959e:	48 b8 d2 b6 22 04 80 	movabs $0x800422b6d2,%rax
  80042095a5:	00 00 00 
  80042095a8:	0f b7 00             	movzwl (%rax),%eax
  80042095ab:	66 83 f8 ff          	cmp    $0xffff,%ax
  80042095af:	74 1e                	je     80042095cf <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  80042095b1:	48 b8 d2 b6 22 04 80 	movabs $0x800422b6d2,%rax
  80042095b8:	00 00 00 
  80042095bb:	0f b7 00             	movzwl (%rax),%eax
  80042095be:	0f b7 c0             	movzwl %ax,%eax
  80042095c1:	89 c7                	mov    %eax,%edi
  80042095c3:	48 b8 d1 95 20 04 80 	movabs $0x80042095d1,%rax
  80042095ca:	00 00 00 
  80042095cd:	ff d0                	callq  *%rax
}
  80042095cf:	c9                   	leaveq 
  80042095d0:	c3                   	retq   

00000080042095d1 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  80042095d1:	55                   	push   %rbp
  80042095d2:	48 89 e5             	mov    %rsp,%rbp
  80042095d5:	48 83 ec 30          	sub    $0x30,%rsp
  80042095d9:	89 f8                	mov    %edi,%eax
  80042095db:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  80042095df:	48 b8 d2 b6 22 04 80 	movabs $0x800422b6d2,%rax
  80042095e6:	00 00 00 
  80042095e9:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80042095ed:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  80042095f0:	48 b8 68 42 37 04 80 	movabs $0x8004374268,%rax
  80042095f7:	00 00 00 
  80042095fa:	0f b6 00             	movzbl (%rax),%eax
  80042095fd:	83 f0 01             	xor    $0x1,%eax
  8004209600:	84 c0                	test   %al,%al
  8004209602:	74 05                	je     8004209609 <irq_setmask_8259A+0x38>
		return;
  8004209604:	e9 b7 00 00 00       	jmpq   80042096c0 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004209609:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  800420960d:	0f b6 c0             	movzbl %al,%eax
  8004209610:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004209617:	88 45 f7             	mov    %al,-0x9(%rbp)
  800420961a:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  800420961e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004209621:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004209622:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209626:	66 c1 e8 08          	shr    $0x8,%ax
  800420962a:	0f b6 c0             	movzbl %al,%eax
  800420962d:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004209634:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004209637:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420963b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420963e:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  800420963f:	48 bf 04 89 21 04 80 	movabs $0x8004218904,%rdi
  8004209646:	00 00 00 
  8004209649:	b8 00 00 00 00       	mov    $0x0,%eax
  800420964e:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004209655:	00 00 00 
  8004209658:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  800420965a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209661:	eb 3c                	jmp    800420969f <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004209663:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209667:	f7 d0                	not    %eax
  8004209669:	89 c2                	mov    %eax,%edx
  800420966b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420966e:	89 c1                	mov    %eax,%ecx
  8004209670:	d3 fa                	sar    %cl,%edx
  8004209672:	89 d0                	mov    %edx,%eax
  8004209674:	83 e0 01             	and    $0x1,%eax
  8004209677:	85 c0                	test   %eax,%eax
  8004209679:	74 20                	je     800420969b <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  800420967b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420967e:	89 c6                	mov    %eax,%esi
  8004209680:	48 bf 18 89 21 04 80 	movabs $0x8004218918,%rdi
  8004209687:	00 00 00 
  800420968a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420968f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004209696:	00 00 00 
  8004209699:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  800420969b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420969f:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042096a3:	7e be                	jle    8004209663 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  80042096a5:	48 bf 1c 89 21 04 80 	movabs $0x800421891c,%rdi
  80042096ac:	00 00 00 
  80042096af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042096b4:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042096bb:	00 00 00 
  80042096be:	ff d2                	callq  *%rdx
}
  80042096c0:	c9                   	leaveq 
  80042096c1:	c3                   	retq   

00000080042096c2 <irq_eoi>:

void
irq_eoi(void)
{
  80042096c2:	55                   	push   %rbp
  80042096c3:	48 89 e5             	mov    %rsp,%rbp
  80042096c6:	48 83 ec 10          	sub    $0x10,%rsp
  80042096ca:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  80042096d1:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  80042096d5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042096d9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042096dc:	ee                   	out    %al,(%dx)
  80042096dd:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  80042096e4:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  80042096e8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042096ec:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042096ef:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  80042096f0:	c9                   	leaveq 
  80042096f1:	c3                   	retq   

00000080042096f2 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  80042096f2:	55                   	push   %rbp
  80042096f3:	48 89 e5             	mov    %rsp,%rbp
  80042096f6:	48 83 ec 10          	sub    $0x10,%rsp
  80042096fa:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042096fd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004209701:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209704:	89 c7                	mov    %eax,%edi
  8004209706:	48 b8 60 13 20 04 80 	movabs $0x8004201360,%rax
  800420970d:	00 00 00 
  8004209710:	ff d0                	callq  *%rax
	*cnt++;
  8004209712:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004209716:	48 83 c0 04          	add    $0x4,%rax
  800420971a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  800420971e:	c9                   	leaveq 
  800420971f:	c3                   	retq   

0000008004209720 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004209720:	55                   	push   %rbp
  8004209721:	48 89 e5             	mov    %rsp,%rbp
  8004209724:	48 83 ec 30          	sub    $0x30,%rsp
  8004209728:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420972c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004209730:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209737:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420973b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420973f:	48 8b 0a             	mov    (%rdx),%rcx
  8004209742:	48 89 08             	mov    %rcx,(%rax)
  8004209745:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004209749:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420974d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209751:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004209755:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004209759:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420975d:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004209761:	48 89 c6             	mov    %rax,%rsi
  8004209764:	48 bf f2 96 20 04 80 	movabs $0x80042096f2,%rdi
  800420976b:	00 00 00 
  800420976e:	48 b8 1f e2 20 04 80 	movabs $0x800420e21f,%rax
  8004209775:	00 00 00 
  8004209778:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  800420977a:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  800420977d:	c9                   	leaveq 
  800420977e:	c3                   	retq   

000000800420977f <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800420977f:	55                   	push   %rbp
  8004209780:	48 89 e5             	mov    %rsp,%rbp
  8004209783:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  800420978a:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004209791:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209798:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420979f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042097a6:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042097ad:	84 c0                	test   %al,%al
  80042097af:	74 20                	je     80042097d1 <cprintf+0x52>
  80042097b1:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042097b5:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042097b9:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042097bd:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042097c1:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042097c5:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042097c9:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042097cd:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042097d1:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  80042097d8:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  80042097df:	00 00 00 
  80042097e2:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80042097e9:	00 00 00 
  80042097ec:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042097f0:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042097f7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042097fe:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004209805:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420980c:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004209813:	48 8b 0a             	mov    (%rdx),%rcx
  8004209816:	48 89 08             	mov    %rcx,(%rax)
  8004209819:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420981d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209821:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209825:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004209829:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004209830:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209837:	48 89 d6             	mov    %rdx,%rsi
  800420983a:	48 89 c7             	mov    %rax,%rdi
  800420983d:	48 b8 20 97 20 04 80 	movabs $0x8004209720,%rax
  8004209844:	00 00 00 
  8004209847:	ff d0                	callq  *%rax
  8004209849:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  800420984f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209855:	c9                   	leaveq 
  8004209856:	c3                   	retq   

0000008004209857 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209857:	55                   	push   %rbp
  8004209858:	48 89 e5             	mov    %rsp,%rbp
  800420985b:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420985f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209863:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209866:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420986a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420986d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209871:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209874:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209877:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420987a:	c9                   	leaveq 
  800420987b:	c3                   	retq   

000000800420987c <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420987c:	55                   	push   %rbp
  800420987d:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209880:	48 bf 60 b9 22 04 80 	movabs $0x800422b960,%rdi
  8004209887:	00 00 00 
  800420988a:	48 b8 e5 61 21 04 80 	movabs $0x80042161e5,%rax
  8004209891:	00 00 00 
  8004209894:	ff d0                	callq  *%rax
}
  8004209896:	5d                   	pop    %rbp
  8004209897:	c3                   	retq   

0000008004209898 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209898:	55                   	push   %rbp
  8004209899:	48 89 e5             	mov    %rsp,%rbp
  800420989c:	48 83 ec 04          	sub    $0x4,%rsp
  80042098a0:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  80042098a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042098a6:	83 f8 13             	cmp    $0x13,%eax
  80042098a9:	77 16                	ja     80042098c1 <trapname+0x29>
		return excnames[trapno];
  80042098ab:	48 b8 e0 8e 21 04 80 	movabs $0x8004218ee0,%rax
  80042098b2:	00 00 00 
  80042098b5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042098b8:	48 63 d2             	movslq %edx,%rdx
  80042098bb:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042098bf:	eb 34                	jmp    80042098f5 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  80042098c1:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  80042098c5:	75 0c                	jne    80042098d3 <trapname+0x3b>
		return "System call";
  80042098c7:	48 b8 20 89 21 04 80 	movabs $0x8004218920,%rax
  80042098ce:	00 00 00 
  80042098d1:	eb 22                	jmp    80042098f5 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  80042098d3:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80042098d7:	7e 12                	jle    80042098eb <trapname+0x53>
  80042098d9:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  80042098dd:	7f 0c                	jg     80042098eb <trapname+0x53>
		return "Hardware Interrupt";
  80042098df:	48 b8 2c 89 21 04 80 	movabs $0x800421892c,%rax
  80042098e6:	00 00 00 
  80042098e9:	eb 0a                	jmp    80042098f5 <trapname+0x5d>
	return "(unknown trap)";
  80042098eb:	48 b8 3f 89 21 04 80 	movabs $0x800421893f,%rax
  80042098f2:	00 00 00 
}
  80042098f5:	c9                   	leaveq 
  80042098f6:	c3                   	retq   

00000080042098f7 <trap_init>:


void
trap_init(void)
{
  80042098f7:	55                   	push   %rbp
  80042098f8:	48 89 e5             	mov    %rsp,%rbp
  80042098fb:	48 83 ec 10          	sub    $0x10,%rsp


	int i;
	extern uint64_t entries[];
	void entry48();
	for (i=0;i<20;i++)
  80042098ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004209906:	e9 b7 01 00 00       	jmpq   8004209ac2 <trap_init+0x1cb>
		SETGATE(idt[i], 0, GD_KT, entries[i], i==3?3:0);
  800420990b:	48 b8 d4 b6 22 04 80 	movabs $0x800422b6d4,%rax
  8004209912:	00 00 00 
  8004209915:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209918:	48 63 d2             	movslq %edx,%rdx
  800420991b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420991f:	48 ba 80 42 37 04 80 	movabs $0x8004374280,%rdx
  8004209926:	00 00 00 
  8004209929:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420992c:	48 63 c9             	movslq %ecx,%rcx
  800420992f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209933:	48 01 ca             	add    %rcx,%rdx
  8004209936:	66 89 02             	mov    %ax,(%rdx)
  8004209939:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209940:	00 00 00 
  8004209943:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209946:	48 63 d2             	movslq %edx,%rdx
  8004209949:	48 c1 e2 04          	shl    $0x4,%rdx
  800420994d:	48 01 d0             	add    %rdx,%rax
  8004209950:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004209956:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420995d:	00 00 00 
  8004209960:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209963:	48 63 d2             	movslq %edx,%rdx
  8004209966:	48 c1 e2 04          	shl    $0x4,%rdx
  800420996a:	48 01 d0             	add    %rdx,%rax
  800420996d:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209971:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209974:	88 50 04             	mov    %dl,0x4(%rax)
  8004209977:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420997e:	00 00 00 
  8004209981:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209984:	48 63 d2             	movslq %edx,%rdx
  8004209987:	48 c1 e2 04          	shl    $0x4,%rdx
  800420998b:	48 01 d0             	add    %rdx,%rax
  800420998e:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209992:	83 e2 07             	and    $0x7,%edx
  8004209995:	88 50 04             	mov    %dl,0x4(%rax)
  8004209998:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420999f:	00 00 00 
  80042099a2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042099a5:	48 63 d2             	movslq %edx,%rdx
  80042099a8:	48 c1 e2 04          	shl    $0x4,%rdx
  80042099ac:	48 01 d0             	add    %rdx,%rax
  80042099af:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042099b3:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099b6:	83 ca 0e             	or     $0xe,%edx
  80042099b9:	88 50 05             	mov    %dl,0x5(%rax)
  80042099bc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  80042099c3:	00 00 00 
  80042099c6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042099c9:	48 63 d2             	movslq %edx,%rdx
  80042099cc:	48 c1 e2 04          	shl    $0x4,%rdx
  80042099d0:	48 01 d0             	add    %rdx,%rax
  80042099d3:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042099d7:	83 e2 ef             	and    $0xffffffef,%edx
  80042099da:	88 50 05             	mov    %dl,0x5(%rax)
  80042099dd:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  80042099e1:	75 07                	jne    80042099ea <trap_init+0xf3>
  80042099e3:	ba 03 00 00 00       	mov    $0x3,%edx
  80042099e8:	eb 05                	jmp    80042099ef <trap_init+0xf8>
  80042099ea:	ba 00 00 00 00       	mov    $0x0,%edx
  80042099ef:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  80042099f6:	00 00 00 
  80042099f9:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042099fc:	48 63 c9             	movslq %ecx,%rcx
  80042099ff:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209a03:	48 01 c8             	add    %rcx,%rax
  8004209a06:	83 e2 03             	and    $0x3,%edx
  8004209a09:	89 d1                	mov    %edx,%ecx
  8004209a0b:	c1 e1 05             	shl    $0x5,%ecx
  8004209a0e:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209a12:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a15:	09 ca                	or     %ecx,%edx
  8004209a17:	88 50 05             	mov    %dl,0x5(%rax)
  8004209a1a:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209a21:	00 00 00 
  8004209a24:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209a27:	48 63 d2             	movslq %edx,%rdx
  8004209a2a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209a2e:	48 01 d0             	add    %rdx,%rax
  8004209a31:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209a35:	83 ca 80             	or     $0xffffff80,%edx
  8004209a38:	88 50 05             	mov    %dl,0x5(%rax)
  8004209a3b:	48 b8 d4 b6 22 04 80 	movabs $0x800422b6d4,%rax
  8004209a42:	00 00 00 
  8004209a45:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209a48:	48 63 d2             	movslq %edx,%rdx
  8004209a4b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209a4f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a53:	48 ba 80 42 37 04 80 	movabs $0x8004374280,%rdx
  8004209a5a:	00 00 00 
  8004209a5d:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004209a60:	48 63 c9             	movslq %ecx,%rcx
  8004209a63:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209a67:	48 01 ca             	add    %rcx,%rdx
  8004209a6a:	66 89 42 06          	mov    %ax,0x6(%rdx)
  8004209a6e:	48 b8 d4 b6 22 04 80 	movabs $0x800422b6d4,%rax
  8004209a75:	00 00 00 
  8004209a78:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209a7b:	48 63 d2             	movslq %edx,%rdx
  8004209a7e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004209a82:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a86:	48 ba 80 42 37 04 80 	movabs $0x8004374280,%rdx
  8004209a8d:	00 00 00 
  8004209a90:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004209a93:	48 63 c9             	movslq %ecx,%rcx
  8004209a96:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209a9a:	48 01 ca             	add    %rcx,%rdx
  8004209a9d:	89 42 08             	mov    %eax,0x8(%rdx)
  8004209aa0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209aa7:	00 00 00 
  8004209aaa:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209aad:	48 63 d2             	movslq %edx,%rdx
  8004209ab0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004209ab4:	48 01 d0             	add    %rdx,%rax
  8004209ab7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)


	int i;
	extern uint64_t entries[];
	void entry48();
	for (i=0;i<20;i++)
  8004209abe:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004209ac2:	83 7d fc 13          	cmpl   $0x13,-0x4(%rbp)
  8004209ac6:	0f 8e 3f fe ff ff    	jle    800420990b <trap_init+0x14>
		SETGATE(idt[i], 0, GD_KT, entries[i], i==3?3:0);
	// for (i=32;i<=47;i++)
	// 	SETGATE(idt[i], 0, GD_KT, entries[i], 0);
	SETGATE(idt[48], 0, GD_KT, entry48, 3);
  8004209acc:	48 b8 74 b7 22 04 80 	movabs $0x800422b774,%rax
  8004209ad3:	00 00 00 
  8004209ad6:	89 c2                	mov    %eax,%edx
  8004209ad8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209adf:	00 00 00 
  8004209ae2:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  8004209ae9:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209af0:	00 00 00 
  8004209af3:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004209afa:	08 00 
  8004209afc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b03:	00 00 00 
  8004209b06:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209b0d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b10:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209b16:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b1d:	00 00 00 
  8004209b20:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209b27:	83 e2 07             	and    $0x7,%edx
  8004209b2a:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209b30:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b37:	00 00 00 
  8004209b3a:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209b41:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209b44:	83 ca 0e             	or     $0xe,%edx
  8004209b47:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209b4d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b54:	00 00 00 
  8004209b57:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209b5e:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b61:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209b67:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b6e:	00 00 00 
  8004209b71:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209b78:	83 ca 60             	or     $0x60,%edx
  8004209b7b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209b81:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209b88:	00 00 00 
  8004209b8b:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209b92:	83 ca 80             	or     $0xffffff80,%edx
  8004209b95:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209b9b:	48 b8 74 b7 22 04 80 	movabs $0x800422b774,%rax
  8004209ba2:	00 00 00 
  8004209ba5:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ba9:	89 c2                	mov    %eax,%edx
  8004209bab:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209bb2:	00 00 00 
  8004209bb5:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209bbc:	48 b8 74 b7 22 04 80 	movabs $0x800422b774,%rax
  8004209bc3:	00 00 00 
  8004209bc6:	48 c1 e8 20          	shr    $0x20,%rax
  8004209bca:	89 c2                	mov    %eax,%edx
  8004209bcc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209bd3:	00 00 00 
  8004209bd6:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209bdc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209be3:	00 00 00 
  8004209be6:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  8004209bed:	00 00 00 
void entry46();
void entry47();



 	SETGATE(idt[32], 0, GD_KT, entry32, 0);
  8004209bf0:	48 b8 58 c1 20 04 80 	movabs $0x800420c158,%rax
  8004209bf7:	00 00 00 
  8004209bfa:	89 c2                	mov    %eax,%edx
  8004209bfc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c03:	00 00 00 
  8004209c06:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  8004209c0d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c14:	00 00 00 
  8004209c17:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  8004209c1e:	08 00 
  8004209c20:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c27:	00 00 00 
  8004209c2a:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209c31:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c34:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209c3a:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c41:	00 00 00 
  8004209c44:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209c4b:	83 e2 07             	and    $0x7,%edx
  8004209c4e:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209c54:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c5b:	00 00 00 
  8004209c5e:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209c65:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209c68:	83 ca 0e             	or     $0xe,%edx
  8004209c6b:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209c71:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c78:	00 00 00 
  8004209c7b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209c82:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c85:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209c8b:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209c92:	00 00 00 
  8004209c95:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209c9c:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c9f:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209ca5:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209cac:	00 00 00 
  8004209caf:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  8004209cb6:	83 ca 80             	or     $0xffffff80,%edx
  8004209cb9:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  8004209cbf:	48 b8 58 c1 20 04 80 	movabs $0x800420c158,%rax
  8004209cc6:	00 00 00 
  8004209cc9:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ccd:	89 c2                	mov    %eax,%edx
  8004209ccf:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209cd6:	00 00 00 
  8004209cd9:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  8004209ce0:	48 b8 58 c1 20 04 80 	movabs $0x800420c158,%rax
  8004209ce7:	00 00 00 
  8004209cea:	48 c1 e8 20          	shr    $0x20,%rax
  8004209cee:	89 c2                	mov    %eax,%edx
  8004209cf0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209cf7:	00 00 00 
  8004209cfa:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  8004209d00:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d07:	00 00 00 
  8004209d0a:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  8004209d11:	00 00 00 
    SETGATE(idt[33], 0, GD_KT, entry33, 0);
  8004209d14:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209d1b:	00 00 00 
  8004209d1e:	89 c2                	mov    %eax,%edx
  8004209d20:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d27:	00 00 00 
  8004209d2a:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  8004209d31:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d38:	00 00 00 
  8004209d3b:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  8004209d42:	08 00 
  8004209d44:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d4b:	00 00 00 
  8004209d4e:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209d55:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d58:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209d5e:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d65:	00 00 00 
  8004209d68:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  8004209d6f:	83 e2 07             	and    $0x7,%edx
  8004209d72:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  8004209d78:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d7f:	00 00 00 
  8004209d82:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209d89:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d8c:	83 ca 0e             	or     $0xe,%edx
  8004209d8f:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209d95:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209d9c:	00 00 00 
  8004209d9f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209da6:	83 e2 ef             	and    $0xffffffef,%edx
  8004209da9:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209daf:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209db6:	00 00 00 
  8004209db9:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209dc0:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209dc3:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209dc9:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209dd0:	00 00 00 
  8004209dd3:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  8004209dda:	83 ca 80             	or     $0xffffff80,%edx
  8004209ddd:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  8004209de3:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209dea:	00 00 00 
  8004209ded:	48 c1 e8 10          	shr    $0x10,%rax
  8004209df1:	89 c2                	mov    %eax,%edx
  8004209df3:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209dfa:	00 00 00 
  8004209dfd:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  8004209e04:	48 b8 62 c1 20 04 80 	movabs $0x800420c162,%rax
  8004209e0b:	00 00 00 
  8004209e0e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e12:	89 c2                	mov    %eax,%edx
  8004209e14:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e1b:	00 00 00 
  8004209e1e:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  8004209e24:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e2b:	00 00 00 
  8004209e2e:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  8004209e35:	00 00 00 
    SETGATE(idt[34], 0, GD_KT, entry34, 0);
  8004209e38:	48 b8 6c c1 20 04 80 	movabs $0x800420c16c,%rax
  8004209e3f:	00 00 00 
  8004209e42:	89 c2                	mov    %eax,%edx
  8004209e44:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e4b:	00 00 00 
  8004209e4e:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  8004209e55:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e5c:	00 00 00 
  8004209e5f:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  8004209e66:	08 00 
  8004209e68:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e6f:	00 00 00 
  8004209e72:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  8004209e79:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e7c:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  8004209e82:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209e89:	00 00 00 
  8004209e8c:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  8004209e93:	83 e2 07             	and    $0x7,%edx
  8004209e96:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  8004209e9c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209ea3:	00 00 00 
  8004209ea6:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209ead:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209eb0:	83 ca 0e             	or     $0xe,%edx
  8004209eb3:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209eb9:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209ec0:	00 00 00 
  8004209ec3:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209eca:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ecd:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209ed3:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209eda:	00 00 00 
  8004209edd:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209ee4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ee7:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209eed:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209ef4:	00 00 00 
  8004209ef7:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  8004209efe:	83 ca 80             	or     $0xffffff80,%edx
  8004209f01:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  8004209f07:	48 b8 6c c1 20 04 80 	movabs $0x800420c16c,%rax
  8004209f0e:	00 00 00 
  8004209f11:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f15:	89 c2                	mov    %eax,%edx
  8004209f17:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f1e:	00 00 00 
  8004209f21:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  8004209f28:	48 b8 6c c1 20 04 80 	movabs $0x800420c16c,%rax
  8004209f2f:	00 00 00 
  8004209f32:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f36:	89 c2                	mov    %eax,%edx
  8004209f38:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f3f:	00 00 00 
  8004209f42:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  8004209f48:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f4f:	00 00 00 
  8004209f52:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  8004209f59:	00 00 00 
    SETGATE(idt[35], 0, GD_KT, entry35, 0);
  8004209f5c:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  8004209f63:	00 00 00 
  8004209f66:	89 c2                	mov    %eax,%edx
  8004209f68:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f6f:	00 00 00 
  8004209f72:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  8004209f79:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f80:	00 00 00 
  8004209f83:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  8004209f8a:	08 00 
  8004209f8c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209f93:	00 00 00 
  8004209f96:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  8004209f9d:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209fa0:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  8004209fa6:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209fad:	00 00 00 
  8004209fb0:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  8004209fb7:	83 e2 07             	and    $0x7,%edx
  8004209fba:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  8004209fc0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209fc7:	00 00 00 
  8004209fca:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  8004209fd1:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209fd4:	83 ca 0e             	or     $0xe,%edx
  8004209fd7:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  8004209fdd:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209fe4:	00 00 00 
  8004209fe7:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  8004209fee:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ff1:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  8004209ff7:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  8004209ffe:	00 00 00 
  800420a001:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a008:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a00b:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a011:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a018:	00 00 00 
  800420a01b:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a022:	83 ca 80             	or     $0xffffff80,%edx
  800420a025:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a02b:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  800420a032:	00 00 00 
  800420a035:	48 c1 e8 10          	shr    $0x10,%rax
  800420a039:	89 c2                	mov    %eax,%edx
  800420a03b:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a042:	00 00 00 
  800420a045:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420a04c:	48 b8 76 c1 20 04 80 	movabs $0x800420c176,%rax
  800420a053:	00 00 00 
  800420a056:	48 c1 e8 20          	shr    $0x20,%rax
  800420a05a:	89 c2                	mov    %eax,%edx
  800420a05c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a063:	00 00 00 
  800420a066:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420a06c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a073:	00 00 00 
  800420a076:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420a07d:	00 00 00 
    SETGATE(idt[36], 0, GD_KT, entry36, 0);
  800420a080:	48 b8 80 c1 20 04 80 	movabs $0x800420c180,%rax
  800420a087:	00 00 00 
  800420a08a:	89 c2                	mov    %eax,%edx
  800420a08c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a093:	00 00 00 
  800420a096:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a09d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a0a4:	00 00 00 
  800420a0a7:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a0ae:	08 00 
  800420a0b0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a0b7:	00 00 00 
  800420a0ba:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a0c1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a0c4:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a0ca:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a0d1:	00 00 00 
  800420a0d4:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a0db:	83 e2 07             	and    $0x7,%edx
  800420a0de:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a0e4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a0eb:	00 00 00 
  800420a0ee:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a0f5:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0f8:	83 ca 0e             	or     $0xe,%edx
  800420a0fb:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a101:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a108:	00 00 00 
  800420a10b:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a112:	83 e2 ef             	and    $0xffffffef,%edx
  800420a115:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a11b:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a122:	00 00 00 
  800420a125:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a12c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a12f:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a135:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a13c:	00 00 00 
  800420a13f:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a146:	83 ca 80             	or     $0xffffff80,%edx
  800420a149:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a14f:	48 b8 80 c1 20 04 80 	movabs $0x800420c180,%rax
  800420a156:	00 00 00 
  800420a159:	48 c1 e8 10          	shr    $0x10,%rax
  800420a15d:	89 c2                	mov    %eax,%edx
  800420a15f:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a166:	00 00 00 
  800420a169:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a170:	48 b8 80 c1 20 04 80 	movabs $0x800420c180,%rax
  800420a177:	00 00 00 
  800420a17a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a17e:	89 c2                	mov    %eax,%edx
  800420a180:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a187:	00 00 00 
  800420a18a:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a190:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a197:	00 00 00 
  800420a19a:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a1a1:	00 00 00 
    SETGATE(idt[37], 0, GD_KT, entry37, 0);
  800420a1a4:	48 b8 8a c1 20 04 80 	movabs $0x800420c18a,%rax
  800420a1ab:	00 00 00 
  800420a1ae:	89 c2                	mov    %eax,%edx
  800420a1b0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a1b7:	00 00 00 
  800420a1ba:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420a1c1:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a1c8:	00 00 00 
  800420a1cb:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420a1d2:	08 00 
  800420a1d4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a1db:	00 00 00 
  800420a1de:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a1e5:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a1e8:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a1ee:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a1f5:	00 00 00 
  800420a1f8:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420a1ff:	83 e2 07             	and    $0x7,%edx
  800420a202:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420a208:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a20f:	00 00 00 
  800420a212:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a219:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a21c:	83 ca 0e             	or     $0xe,%edx
  800420a21f:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a225:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a22c:	00 00 00 
  800420a22f:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a236:	83 e2 ef             	and    $0xffffffef,%edx
  800420a239:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a23f:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a246:	00 00 00 
  800420a249:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a250:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a253:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a259:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a260:	00 00 00 
  800420a263:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420a26a:	83 ca 80             	or     $0xffffff80,%edx
  800420a26d:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420a273:	48 b8 8a c1 20 04 80 	movabs $0x800420c18a,%rax
  800420a27a:	00 00 00 
  800420a27d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a281:	89 c2                	mov    %eax,%edx
  800420a283:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a28a:	00 00 00 
  800420a28d:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420a294:	48 b8 8a c1 20 04 80 	movabs $0x800420c18a,%rax
  800420a29b:	00 00 00 
  800420a29e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a2a2:	89 c2                	mov    %eax,%edx
  800420a2a4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a2ab:	00 00 00 
  800420a2ae:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420a2b4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a2bb:	00 00 00 
  800420a2be:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420a2c5:	00 00 00 
    SETGATE(idt[38], 0, GD_KT, entry38, 0);
  800420a2c8:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a2cf:	00 00 00 
  800420a2d2:	89 c2                	mov    %eax,%edx
  800420a2d4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a2db:	00 00 00 
  800420a2de:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420a2e5:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a2ec:	00 00 00 
  800420a2ef:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420a2f6:	08 00 
  800420a2f8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a2ff:	00 00 00 
  800420a302:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a309:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a30c:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a312:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a319:	00 00 00 
  800420a31c:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420a323:	83 e2 07             	and    $0x7,%edx
  800420a326:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420a32c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a333:	00 00 00 
  800420a336:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a33d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a340:	83 ca 0e             	or     $0xe,%edx
  800420a343:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a349:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a350:	00 00 00 
  800420a353:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a35a:	83 e2 ef             	and    $0xffffffef,%edx
  800420a35d:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a363:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a36a:	00 00 00 
  800420a36d:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a374:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a377:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a37d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a384:	00 00 00 
  800420a387:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420a38e:	83 ca 80             	or     $0xffffff80,%edx
  800420a391:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420a397:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a39e:	00 00 00 
  800420a3a1:	48 c1 e8 10          	shr    $0x10,%rax
  800420a3a5:	89 c2                	mov    %eax,%edx
  800420a3a7:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a3ae:	00 00 00 
  800420a3b1:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420a3b8:	48 b8 94 c1 20 04 80 	movabs $0x800420c194,%rax
  800420a3bf:	00 00 00 
  800420a3c2:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3c6:	89 c2                	mov    %eax,%edx
  800420a3c8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a3cf:	00 00 00 
  800420a3d2:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420a3d8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a3df:	00 00 00 
  800420a3e2:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420a3e9:	00 00 00 
    SETGATE(idt[39], 0, GD_KT, entry39, 0);
  800420a3ec:	48 b8 9e c1 20 04 80 	movabs $0x800420c19e,%rax
  800420a3f3:	00 00 00 
  800420a3f6:	89 c2                	mov    %eax,%edx
  800420a3f8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a3ff:	00 00 00 
  800420a402:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a409:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a410:	00 00 00 
  800420a413:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a41a:	08 00 
  800420a41c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a423:	00 00 00 
  800420a426:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a42d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a430:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a436:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a43d:	00 00 00 
  800420a440:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a447:	83 e2 07             	and    $0x7,%edx
  800420a44a:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a450:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a457:	00 00 00 
  800420a45a:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a461:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a464:	83 ca 0e             	or     $0xe,%edx
  800420a467:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a46d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a474:	00 00 00 
  800420a477:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a47e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a481:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a487:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a48e:	00 00 00 
  800420a491:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a498:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a49b:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a4a1:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a4a8:	00 00 00 
  800420a4ab:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a4b2:	83 ca 80             	or     $0xffffff80,%edx
  800420a4b5:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a4bb:	48 b8 9e c1 20 04 80 	movabs $0x800420c19e,%rax
  800420a4c2:	00 00 00 
  800420a4c5:	48 c1 e8 10          	shr    $0x10,%rax
  800420a4c9:	89 c2                	mov    %eax,%edx
  800420a4cb:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a4d2:	00 00 00 
  800420a4d5:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a4dc:	48 b8 9e c1 20 04 80 	movabs $0x800420c19e,%rax
  800420a4e3:	00 00 00 
  800420a4e6:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4ea:	89 c2                	mov    %eax,%edx
  800420a4ec:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a4f3:	00 00 00 
  800420a4f6:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a4fc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a503:	00 00 00 
  800420a506:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a50d:	00 00 00 
    SETGATE(idt[40], 0, GD_KT, entry40, 0);
  800420a510:	48 b8 a8 c1 20 04 80 	movabs $0x800420c1a8,%rax
  800420a517:	00 00 00 
  800420a51a:	89 c2                	mov    %eax,%edx
  800420a51c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a523:	00 00 00 
  800420a526:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420a52d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a534:	00 00 00 
  800420a537:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420a53e:	08 00 
  800420a540:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a547:	00 00 00 
  800420a54a:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a551:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a554:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a55a:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a561:	00 00 00 
  800420a564:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420a56b:	83 e2 07             	and    $0x7,%edx
  800420a56e:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420a574:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a57b:	00 00 00 
  800420a57e:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a585:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a588:	83 ca 0e             	or     $0xe,%edx
  800420a58b:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a591:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a598:	00 00 00 
  800420a59b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a5a2:	83 e2 ef             	and    $0xffffffef,%edx
  800420a5a5:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a5ab:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a5b2:	00 00 00 
  800420a5b5:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a5bc:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a5bf:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a5c5:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a5cc:	00 00 00 
  800420a5cf:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420a5d6:	83 ca 80             	or     $0xffffff80,%edx
  800420a5d9:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420a5df:	48 b8 a8 c1 20 04 80 	movabs $0x800420c1a8,%rax
  800420a5e6:	00 00 00 
  800420a5e9:	48 c1 e8 10          	shr    $0x10,%rax
  800420a5ed:	89 c2                	mov    %eax,%edx
  800420a5ef:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a5f6:	00 00 00 
  800420a5f9:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420a600:	48 b8 a8 c1 20 04 80 	movabs $0x800420c1a8,%rax
  800420a607:	00 00 00 
  800420a60a:	48 c1 e8 20          	shr    $0x20,%rax
  800420a60e:	89 c2                	mov    %eax,%edx
  800420a610:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a617:	00 00 00 
  800420a61a:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420a620:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a627:	00 00 00 
  800420a62a:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420a631:	00 00 00 
    SETGATE(idt[41], 0, GD_KT, entry41, 0);
  800420a634:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420a63b:	00 00 00 
  800420a63e:	89 c2                	mov    %eax,%edx
  800420a640:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a647:	00 00 00 
  800420a64a:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420a651:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a658:	00 00 00 
  800420a65b:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420a662:	08 00 
  800420a664:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a66b:	00 00 00 
  800420a66e:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a675:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a678:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a67e:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a685:	00 00 00 
  800420a688:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420a68f:	83 e2 07             	and    $0x7,%edx
  800420a692:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420a698:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a69f:	00 00 00 
  800420a6a2:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a6a9:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a6ac:	83 ca 0e             	or     $0xe,%edx
  800420a6af:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a6b5:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a6bc:	00 00 00 
  800420a6bf:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a6c6:	83 e2 ef             	and    $0xffffffef,%edx
  800420a6c9:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a6cf:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a6d6:	00 00 00 
  800420a6d9:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a6e0:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a6e3:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a6e9:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a6f0:	00 00 00 
  800420a6f3:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420a6fa:	83 ca 80             	or     $0xffffff80,%edx
  800420a6fd:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420a703:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420a70a:	00 00 00 
  800420a70d:	48 c1 e8 10          	shr    $0x10,%rax
  800420a711:	89 c2                	mov    %eax,%edx
  800420a713:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a71a:	00 00 00 
  800420a71d:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420a724:	48 b8 b2 c1 20 04 80 	movabs $0x800420c1b2,%rax
  800420a72b:	00 00 00 
  800420a72e:	48 c1 e8 20          	shr    $0x20,%rax
  800420a732:	89 c2                	mov    %eax,%edx
  800420a734:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a73b:	00 00 00 
  800420a73e:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420a744:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a74b:	00 00 00 
  800420a74e:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420a755:	00 00 00 
    SETGATE(idt[42], 0, GD_KT, entry42, 0);
  800420a758:	48 b8 bc c1 20 04 80 	movabs $0x800420c1bc,%rax
  800420a75f:	00 00 00 
  800420a762:	89 c2                	mov    %eax,%edx
  800420a764:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a76b:	00 00 00 
  800420a76e:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420a775:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a77c:	00 00 00 
  800420a77f:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420a786:	08 00 
  800420a788:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a78f:	00 00 00 
  800420a792:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a799:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a79c:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a7a2:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a7a9:	00 00 00 
  800420a7ac:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420a7b3:	83 e2 07             	and    $0x7,%edx
  800420a7b6:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420a7bc:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a7c3:	00 00 00 
  800420a7c6:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a7cd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a7d0:	83 ca 0e             	or     $0xe,%edx
  800420a7d3:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a7d9:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a7e0:	00 00 00 
  800420a7e3:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a7ea:	83 e2 ef             	and    $0xffffffef,%edx
  800420a7ed:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a7f3:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a7fa:	00 00 00 
  800420a7fd:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a804:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a807:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a80d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a814:	00 00 00 
  800420a817:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420a81e:	83 ca 80             	or     $0xffffff80,%edx
  800420a821:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420a827:	48 b8 bc c1 20 04 80 	movabs $0x800420c1bc,%rax
  800420a82e:	00 00 00 
  800420a831:	48 c1 e8 10          	shr    $0x10,%rax
  800420a835:	89 c2                	mov    %eax,%edx
  800420a837:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a83e:	00 00 00 
  800420a841:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420a848:	48 b8 bc c1 20 04 80 	movabs $0x800420c1bc,%rax
  800420a84f:	00 00 00 
  800420a852:	48 c1 e8 20          	shr    $0x20,%rax
  800420a856:	89 c2                	mov    %eax,%edx
  800420a858:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a85f:	00 00 00 
  800420a862:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420a868:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a86f:	00 00 00 
  800420a872:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420a879:	00 00 00 
    SETGATE(idt[43], 0, GD_KT, entry43, 0);
  800420a87c:	48 b8 c6 c1 20 04 80 	movabs $0x800420c1c6,%rax
  800420a883:	00 00 00 
  800420a886:	89 c2                	mov    %eax,%edx
  800420a888:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a88f:	00 00 00 
  800420a892:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420a899:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a8a0:	00 00 00 
  800420a8a3:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420a8aa:	08 00 
  800420a8ac:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a8b3:	00 00 00 
  800420a8b6:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420a8bd:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a8c0:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420a8c6:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a8cd:	00 00 00 
  800420a8d0:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420a8d7:	83 e2 07             	and    $0x7,%edx
  800420a8da:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420a8e0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a8e7:	00 00 00 
  800420a8ea:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a8f1:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8f4:	83 ca 0e             	or     $0xe,%edx
  800420a8f7:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a8fd:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a904:	00 00 00 
  800420a907:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a90e:	83 e2 ef             	and    $0xffffffef,%edx
  800420a911:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a917:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a91e:	00 00 00 
  800420a921:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a928:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a92b:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a931:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a938:	00 00 00 
  800420a93b:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420a942:	83 ca 80             	or     $0xffffff80,%edx
  800420a945:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420a94b:	48 b8 c6 c1 20 04 80 	movabs $0x800420c1c6,%rax
  800420a952:	00 00 00 
  800420a955:	48 c1 e8 10          	shr    $0x10,%rax
  800420a959:	89 c2                	mov    %eax,%edx
  800420a95b:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a962:	00 00 00 
  800420a965:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420a96c:	48 b8 c6 c1 20 04 80 	movabs $0x800420c1c6,%rax
  800420a973:	00 00 00 
  800420a976:	48 c1 e8 20          	shr    $0x20,%rax
  800420a97a:	89 c2                	mov    %eax,%edx
  800420a97c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a983:	00 00 00 
  800420a986:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420a98c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a993:	00 00 00 
  800420a996:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420a99d:	00 00 00 
    SETGATE(idt[44], 0, GD_KT, entry44, 0);
  800420a9a0:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420a9a7:	00 00 00 
  800420a9aa:	89 c2                	mov    %eax,%edx
  800420a9ac:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a9b3:	00 00 00 
  800420a9b6:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420a9bd:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a9c4:	00 00 00 
  800420a9c7:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420a9ce:	08 00 
  800420a9d0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a9d7:	00 00 00 
  800420a9da:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420a9e1:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a9e4:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420a9ea:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420a9f1:	00 00 00 
  800420a9f4:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420a9fb:	83 e2 07             	and    $0x7,%edx
  800420a9fe:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420aa04:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aa0b:	00 00 00 
  800420aa0e:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aa15:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aa18:	83 ca 0e             	or     $0xe,%edx
  800420aa1b:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aa21:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aa28:	00 00 00 
  800420aa2b:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aa32:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa35:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aa3b:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aa42:	00 00 00 
  800420aa45:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aa4c:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa4f:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aa55:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aa5c:	00 00 00 
  800420aa5f:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420aa66:	83 ca 80             	or     $0xffffff80,%edx
  800420aa69:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420aa6f:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420aa76:	00 00 00 
  800420aa79:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa7d:	89 c2                	mov    %eax,%edx
  800420aa7f:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aa86:	00 00 00 
  800420aa89:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420aa90:	48 b8 d0 c1 20 04 80 	movabs $0x800420c1d0,%rax
  800420aa97:	00 00 00 
  800420aa9a:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa9e:	89 c2                	mov    %eax,%edx
  800420aaa0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aaa7:	00 00 00 
  800420aaaa:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420aab0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aab7:	00 00 00 
  800420aaba:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420aac1:	00 00 00 
    SETGATE(idt[45], 0, GD_KT, entry45, 0);
  800420aac4:	48 b8 da c1 20 04 80 	movabs $0x800420c1da,%rax
  800420aacb:	00 00 00 
  800420aace:	89 c2                	mov    %eax,%edx
  800420aad0:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aad7:	00 00 00 
  800420aada:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420aae1:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aae8:	00 00 00 
  800420aaeb:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420aaf2:	08 00 
  800420aaf4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aafb:	00 00 00 
  800420aafe:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420ab05:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ab08:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420ab0e:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ab15:	00 00 00 
  800420ab18:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420ab1f:	83 e2 07             	and    $0x7,%edx
  800420ab22:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420ab28:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ab2f:	00 00 00 
  800420ab32:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ab39:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab3c:	83 ca 0e             	or     $0xe,%edx
  800420ab3f:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ab45:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ab4c:	00 00 00 
  800420ab4f:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ab56:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab59:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ab5f:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ab66:	00 00 00 
  800420ab69:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ab70:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ab73:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ab79:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ab80:	00 00 00 
  800420ab83:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420ab8a:	83 ca 80             	or     $0xffffff80,%edx
  800420ab8d:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420ab93:	48 b8 da c1 20 04 80 	movabs $0x800420c1da,%rax
  800420ab9a:	00 00 00 
  800420ab9d:	48 c1 e8 10          	shr    $0x10,%rax
  800420aba1:	89 c2                	mov    %eax,%edx
  800420aba3:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420abaa:	00 00 00 
  800420abad:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420abb4:	48 b8 da c1 20 04 80 	movabs $0x800420c1da,%rax
  800420abbb:	00 00 00 
  800420abbe:	48 c1 e8 20          	shr    $0x20,%rax
  800420abc2:	89 c2                	mov    %eax,%edx
  800420abc4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420abcb:	00 00 00 
  800420abce:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420abd4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420abdb:	00 00 00 
  800420abde:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420abe5:	00 00 00 
    SETGATE(idt[46], 0, GD_KT, entry46, 0);
  800420abe8:	48 b8 e4 c1 20 04 80 	movabs $0x800420c1e4,%rax
  800420abef:	00 00 00 
  800420abf2:	89 c2                	mov    %eax,%edx
  800420abf4:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420abfb:	00 00 00 
  800420abfe:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420ac05:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac0c:	00 00 00 
  800420ac0f:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420ac16:	08 00 
  800420ac18:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac1f:	00 00 00 
  800420ac22:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420ac29:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac2c:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420ac32:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac39:	00 00 00 
  800420ac3c:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420ac43:	83 e2 07             	and    $0x7,%edx
  800420ac46:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420ac4c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac53:	00 00 00 
  800420ac56:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ac5d:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac60:	83 ca 0e             	or     $0xe,%edx
  800420ac63:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ac69:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac70:	00 00 00 
  800420ac73:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ac7a:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac7d:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ac83:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ac8a:	00 00 00 
  800420ac8d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420ac94:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac97:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420ac9d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420aca4:	00 00 00 
  800420aca7:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420acae:	83 ca 80             	or     $0xffffff80,%edx
  800420acb1:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420acb7:	48 b8 e4 c1 20 04 80 	movabs $0x800420c1e4,%rax
  800420acbe:	00 00 00 
  800420acc1:	48 c1 e8 10          	shr    $0x10,%rax
  800420acc5:	89 c2                	mov    %eax,%edx
  800420acc7:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420acce:	00 00 00 
  800420acd1:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420acd8:	48 b8 e4 c1 20 04 80 	movabs $0x800420c1e4,%rax
  800420acdf:	00 00 00 
  800420ace2:	48 c1 e8 20          	shr    $0x20,%rax
  800420ace6:	89 c2                	mov    %eax,%edx
  800420ace8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420acef:	00 00 00 
  800420acf2:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420acf8:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420acff:	00 00 00 
  800420ad02:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420ad09:	00 00 00 
    SETGATE(idt[47], 0, GD_KT, entry47, 0);
  800420ad0c:	48 b8 ee c1 20 04 80 	movabs $0x800420c1ee,%rax
  800420ad13:	00 00 00 
  800420ad16:	89 c2                	mov    %eax,%edx
  800420ad18:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad1f:	00 00 00 
  800420ad22:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420ad29:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad30:	00 00 00 
  800420ad33:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420ad3a:	08 00 
  800420ad3c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad43:	00 00 00 
  800420ad46:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420ad4d:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad50:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420ad56:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad5d:	00 00 00 
  800420ad60:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420ad67:	83 e2 07             	and    $0x7,%edx
  800420ad6a:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420ad70:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad77:	00 00 00 
  800420ad7a:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ad81:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad84:	83 ca 0e             	or     $0xe,%edx
  800420ad87:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ad8d:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ad94:	00 00 00 
  800420ad97:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420ad9e:	83 e2 ef             	and    $0xffffffef,%edx
  800420ada1:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420ada7:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420adae:	00 00 00 
  800420adb1:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420adb8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420adbb:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420adc1:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420adc8:	00 00 00 
  800420adcb:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420add2:	83 ca 80             	or     $0xffffff80,%edx
  800420add5:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420addb:	48 b8 ee c1 20 04 80 	movabs $0x800420c1ee,%rax
  800420ade2:	00 00 00 
  800420ade5:	48 c1 e8 10          	shr    $0x10,%rax
  800420ade9:	89 c2                	mov    %eax,%edx
  800420adeb:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420adf2:	00 00 00 
  800420adf5:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420adfc:	48 b8 ee c1 20 04 80 	movabs $0x800420c1ee,%rax
  800420ae03:	00 00 00 
  800420ae06:	48 c1 e8 20          	shr    $0x20,%rax
  800420ae0a:	89 c2                	mov    %eax,%edx
  800420ae0c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ae13:	00 00 00 
  800420ae16:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420ae1c:	48 b8 80 42 37 04 80 	movabs $0x8004374280,%rax
  800420ae23:	00 00 00 
  800420ae26:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420ae2d:	00 00 00 
//  SETGATE (idt[IRQ_OFFSET + 12], 0, GD_KT, routine_irq12, 0);
//  SETGATE (idt[IRQ_OFFSET + 13], 0, GD_KT, routine_irq13, 0);
//  SETGATE (idt[IRQ_OFFSET + 14], 0, GD_KT, routine_irq14, 0);
//  SETGATE (idt[IRQ_OFFSET + 15], 0, GD_KT, routine_irq15, 0);

idt_pd.pd_lim = sizeof(idt)-1;
  800420ae30:	48 b8 80 52 37 04 80 	movabs $0x8004375280,%rax
  800420ae37:	00 00 00 
  800420ae3a:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)

    idt_pd.pd_base = (uint64_t)idt;
  800420ae3f:	48 ba 80 42 37 04 80 	movabs $0x8004374280,%rdx
  800420ae46:	00 00 00 
  800420ae49:	48 b8 80 52 37 04 80 	movabs $0x8004375280,%rax
  800420ae50:	00 00 00 
  800420ae53:	48 89 50 02          	mov    %rdx,0x2(%rax)

	// Per-CPU setup
	trap_init_percpu();
  800420ae57:	48 b8 65 ae 20 04 80 	movabs $0x800420ae65,%rax
  800420ae5e:	00 00 00 
  800420ae61:	ff d0                	callq  *%rax
}
  800420ae63:	c9                   	leaveq 
  800420ae64:	c3                   	retq   

000000800420ae65 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420ae65:	55                   	push   %rbp
  800420ae66:	48 89 e5             	mov    %rsp,%rbp
  800420ae69:	53                   	push   %rbx
  800420ae6a:	48 83 ec 18          	sub    $0x18,%rsp
	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.



	int id=cpunum();
  800420ae6e:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ae75:	00 00 00 
  800420ae78:	ff d0                	callq  *%rax
  800420ae7a:	89 45 ec             	mov    %eax,-0x14(%rbp)
	thiscpu->cpu_ts.ts_esp0 = (uintptr_t)percpu_kstacks[id]+KSTKSIZE;
  800420ae7d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ae84:	00 00 00 
  800420ae87:	ff d0                	callq  *%rax
  800420ae89:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420ae8c:	48 63 d2             	movslq %edx,%rdx
  800420ae8f:	48 89 d1             	mov    %rdx,%rcx
  800420ae92:	48 c1 e1 10          	shl    $0x10,%rcx
  800420ae96:	48 ba 00 80 37 04 80 	movabs $0x8004378000,%rdx
  800420ae9d:	00 00 00 
  800420aea0:	48 01 ca             	add    %rcx,%rdx
  800420aea3:	48 81 c2 00 00 01 00 	add    $0x10000,%rdx
  800420aeaa:	48 b9 20 70 37 04 80 	movabs $0x8004377020,%rcx
  800420aeb1:	00 00 00 
  800420aeb4:	48 98                	cltq   
  800420aeb6:	48 c1 e0 03          	shl    $0x3,%rax
  800420aeba:	48 89 c6             	mov    %rax,%rsi
  800420aebd:	48 c1 e6 04          	shl    $0x4,%rsi
  800420aec1:	48 01 f0             	add    %rsi,%rax
  800420aec4:	48 01 c8             	add    %rcx,%rax
  800420aec7:	48 83 c0 10          	add    $0x10,%rax
  800420aecb:	48 89 50 04          	mov    %rdx,0x4(%rax)
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+id*16),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420aecf:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420aed6:	00 00 00 
  800420aed9:	48 8b 00             	mov    (%rax),%rax
  800420aedc:	48 c1 f8 10          	sar    $0x10,%rax
  800420aee0:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aee4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aee7:	c1 e0 04             	shl    $0x4,%eax
  800420aeea:	48 98                	cltq   
  800420aeec:	48 01 d0             	add    %rdx,%rax
  800420aeef:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420aef4:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420aefb:	00 00 00 
  800420aefe:	48 8b 00             	mov    (%rax),%rax
  800420af01:	48 c1 f8 10          	sar    $0x10,%rax
  800420af05:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420af09:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420af0c:	c1 e0 04             	shl    $0x4,%eax
  800420af0f:	48 98                	cltq   
  800420af11:	48 01 d0             	add    %rdx,%rax
  800420af14:	48 89 c3             	mov    %rax,%rbx
  800420af17:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420af1e:	00 00 00 
  800420af21:	ff d0                	callq  *%rax
  800420af23:	48 98                	cltq   
  800420af25:	48 c1 e0 03          	shl    $0x3,%rax
  800420af29:	48 89 c2             	mov    %rax,%rdx
  800420af2c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420af30:	48 01 d0             	add    %rdx,%rax
  800420af33:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420af37:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  800420af3e:	00 00 00 
  800420af41:	48 01 d0             	add    %rdx,%rax
  800420af44:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420af48:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420af4f:	00 00 00 
  800420af52:	48 8b 00             	mov    (%rax),%rax
  800420af55:	48 c1 f8 10          	sar    $0x10,%rax
  800420af59:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420af5d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420af60:	c1 e0 04             	shl    $0x4,%eax
  800420af63:	48 98                	cltq   
  800420af65:	48 01 d0             	add    %rdx,%rax
  800420af68:	48 89 c3             	mov    %rax,%rbx
  800420af6b:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420af72:	00 00 00 
  800420af75:	ff d0                	callq  *%rax
  800420af77:	48 98                	cltq   
  800420af79:	48 c1 e0 03          	shl    $0x3,%rax
  800420af7d:	48 89 c2             	mov    %rax,%rdx
  800420af80:	48 c1 e2 04          	shl    $0x4,%rdx
  800420af84:	48 01 d0             	add    %rdx,%rax
  800420af87:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420af8b:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  800420af92:	00 00 00 
  800420af95:	48 01 d0             	add    %rdx,%rax
  800420af98:	48 c1 e8 10          	shr    $0x10,%rax
  800420af9c:	88 43 04             	mov    %al,0x4(%rbx)
  800420af9f:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420afa6:	00 00 00 
  800420afa9:	48 8b 00             	mov    (%rax),%rax
  800420afac:	48 c1 f8 10          	sar    $0x10,%rax
  800420afb0:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420afb4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420afb7:	c1 e0 04             	shl    $0x4,%eax
  800420afba:	48 98                	cltq   
  800420afbc:	48 01 d0             	add    %rdx,%rax
  800420afbf:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420afc3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420afc6:	83 ca 09             	or     $0x9,%edx
  800420afc9:	88 50 05             	mov    %dl,0x5(%rax)
  800420afcc:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420afd3:	00 00 00 
  800420afd6:	48 8b 00             	mov    (%rax),%rax
  800420afd9:	48 c1 f8 10          	sar    $0x10,%rax
  800420afdd:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420afe1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420afe4:	c1 e0 04             	shl    $0x4,%eax
  800420afe7:	48 98                	cltq   
  800420afe9:	48 01 d0             	add    %rdx,%rax
  800420afec:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420aff0:	83 e2 ef             	and    $0xffffffef,%edx
  800420aff3:	88 50 05             	mov    %dl,0x5(%rax)
  800420aff6:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420affd:	00 00 00 
  800420b000:	48 8b 00             	mov    (%rax),%rax
  800420b003:	48 c1 f8 10          	sar    $0x10,%rax
  800420b007:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b00b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b00e:	c1 e0 04             	shl    $0x4,%eax
  800420b011:	48 98                	cltq   
  800420b013:	48 01 d0             	add    %rdx,%rax
  800420b016:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b01a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b01d:	88 50 05             	mov    %dl,0x5(%rax)
  800420b020:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b027:	00 00 00 
  800420b02a:	48 8b 00             	mov    (%rax),%rax
  800420b02d:	48 c1 f8 10          	sar    $0x10,%rax
  800420b031:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b035:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b038:	c1 e0 04             	shl    $0x4,%eax
  800420b03b:	48 98                	cltq   
  800420b03d:	48 01 d0             	add    %rdx,%rax
  800420b040:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420b044:	83 ca 80             	or     $0xffffff80,%edx
  800420b047:	88 50 05             	mov    %dl,0x5(%rax)
  800420b04a:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b051:	00 00 00 
  800420b054:	48 8b 00             	mov    (%rax),%rax
  800420b057:	48 c1 f8 10          	sar    $0x10,%rax
  800420b05b:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b05f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b062:	c1 e0 04             	shl    $0x4,%eax
  800420b065:	48 98                	cltq   
  800420b067:	48 01 d0             	add    %rdx,%rax
  800420b06a:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b06e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b071:	88 50 06             	mov    %dl,0x6(%rax)
  800420b074:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b07b:	00 00 00 
  800420b07e:	48 8b 00             	mov    (%rax),%rax
  800420b081:	48 c1 f8 10          	sar    $0x10,%rax
  800420b085:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b089:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b08c:	c1 e0 04             	shl    $0x4,%eax
  800420b08f:	48 98                	cltq   
  800420b091:	48 01 d0             	add    %rdx,%rax
  800420b094:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b098:	83 e2 ef             	and    $0xffffffef,%edx
  800420b09b:	88 50 06             	mov    %dl,0x6(%rax)
  800420b09e:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b0a5:	00 00 00 
  800420b0a8:	48 8b 00             	mov    (%rax),%rax
  800420b0ab:	48 c1 f8 10          	sar    $0x10,%rax
  800420b0af:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b0b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b0b6:	c1 e0 04             	shl    $0x4,%eax
  800420b0b9:	48 98                	cltq   
  800420b0bb:	48 01 d0             	add    %rdx,%rax
  800420b0be:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b0c2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b0c5:	88 50 06             	mov    %dl,0x6(%rax)
  800420b0c8:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b0cf:	00 00 00 
  800420b0d2:	48 8b 00             	mov    (%rax),%rax
  800420b0d5:	48 c1 f8 10          	sar    $0x10,%rax
  800420b0d9:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b0dd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b0e0:	c1 e0 04             	shl    $0x4,%eax
  800420b0e3:	48 98                	cltq   
  800420b0e5:	48 01 d0             	add    %rdx,%rax
  800420b0e8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420b0ec:	83 e2 7f             	and    $0x7f,%edx
  800420b0ef:	88 50 06             	mov    %dl,0x6(%rax)
  800420b0f2:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b0f9:	00 00 00 
  800420b0fc:	48 8b 00             	mov    (%rax),%rax
  800420b0ff:	48 c1 f8 10          	sar    $0x10,%rax
  800420b103:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b107:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b10a:	c1 e0 04             	shl    $0x4,%eax
  800420b10d:	48 98                	cltq   
  800420b10f:	48 01 d0             	add    %rdx,%rax
  800420b112:	48 89 c3             	mov    %rax,%rbx
  800420b115:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420b11c:	00 00 00 
  800420b11f:	ff d0                	callq  *%rax
  800420b121:	48 98                	cltq   
  800420b123:	48 c1 e0 03          	shl    $0x3,%rax
  800420b127:	48 89 c2             	mov    %rax,%rdx
  800420b12a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b12e:	48 01 d0             	add    %rdx,%rax
  800420b131:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420b135:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  800420b13c:	00 00 00 
  800420b13f:	48 01 d0             	add    %rdx,%rax
  800420b142:	48 c1 e8 18          	shr    $0x18,%rax
  800420b146:	88 43 07             	mov    %al,0x7(%rbx)
  800420b149:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b150:	00 00 00 
  800420b153:	48 8b 00             	mov    (%rax),%rax
  800420b156:	48 c1 f8 10          	sar    $0x10,%rax
  800420b15a:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b15e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b161:	c1 e0 04             	shl    $0x4,%eax
  800420b164:	48 98                	cltq   
  800420b166:	48 01 d0             	add    %rdx,%rax
  800420b169:	48 89 c3             	mov    %rax,%rbx
  800420b16c:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420b173:	00 00 00 
  800420b176:	ff d0                	callq  *%rax
  800420b178:	48 98                	cltq   
  800420b17a:	48 c1 e0 03          	shl    $0x3,%rax
  800420b17e:	48 89 c2             	mov    %rax,%rdx
  800420b181:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b185:	48 01 d0             	add    %rdx,%rax
  800420b188:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420b18c:	48 b8 20 70 37 04 80 	movabs $0x8004377020,%rax
  800420b193:	00 00 00 
  800420b196:	48 01 d0             	add    %rdx,%rax
  800420b199:	48 c1 e8 20          	shr    $0x20,%rax
  800420b19d:	89 43 08             	mov    %eax,0x8(%rbx)
  800420b1a0:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b1a7:	00 00 00 
  800420b1aa:	48 8b 00             	mov    (%rax),%rax
  800420b1ad:	48 c1 f8 10          	sar    $0x10,%rax
  800420b1b1:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b1b5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b1b8:	c1 e0 04             	shl    $0x4,%eax
  800420b1bb:	48 98                	cltq   
  800420b1bd:	48 01 d0             	add    %rdx,%rax
  800420b1c0:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420b1c4:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b1cb:	00 00 00 
  800420b1ce:	48 8b 00             	mov    (%rax),%rax
  800420b1d1:	48 c1 f8 10          	sar    $0x10,%rax
  800420b1d5:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b1d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b1dc:	c1 e0 04             	shl    $0x4,%eax
  800420b1df:	48 98                	cltq   
  800420b1e1:	48 01 d0             	add    %rdx,%rax
  800420b1e4:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420b1e8:	48 b8 c8 b6 22 04 80 	movabs $0x800422b6c8,%rax
  800420b1ef:	00 00 00 
  800420b1f2:	48 8b 00             	mov    (%rax),%rax
  800420b1f5:	48 c1 f8 10          	sar    $0x10,%rax
  800420b1f9:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420b1fd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b200:	c1 e0 04             	shl    $0x4,%eax
  800420b203:	48 98                	cltq   
  800420b205:	48 01 d0             	add    %rdx,%rax
  800420b208:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0+id*16);
  800420b20e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420b211:	c1 e0 04             	shl    $0x4,%eax
  800420b214:	83 c0 28             	add    $0x28,%eax
  800420b217:	0f b7 c0             	movzwl %ax,%eax
  800420b21a:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
    __asm __volatile("lgdt (%0)" : : "r" (p));
}
    static __inline void
ltr(uint16_t sel)
{
    __asm __volatile("ltr %0" : : "r" (sel));
  800420b21e:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420b222:	0f 00 d8             	ltr    %ax
  800420b225:	48 b8 80 52 37 04 80 	movabs $0x8004375280,%rax
  800420b22c:	00 00 00 
  800420b22f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

    static __inline void
lidt(void *p)
{
    __asm __volatile("lidt (%0)" : : "r" (p));
  800420b233:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b237:	0f 01 18             	lidt   (%rax)


	// Load the IDT
	lidt(&idt_pd);
}
  800420b23a:	48 83 c4 18          	add    $0x18,%rsp
  800420b23e:	5b                   	pop    %rbx
  800420b23f:	5d                   	pop    %rbp
  800420b240:	c3                   	retq   

000000800420b241 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420b241:	55                   	push   %rbp
  800420b242:	48 89 e5             	mov    %rsp,%rbp
  800420b245:	48 83 ec 20          	sub    $0x20,%rsp
  800420b249:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420b24d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420b254:	00 00 00 
  800420b257:	ff d0                	callq  *%rax
  800420b259:	89 c2                	mov    %eax,%edx
  800420b25b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b25f:	48 89 c6             	mov    %rax,%rsi
  800420b262:	48 bf 4e 89 21 04 80 	movabs $0x800421894e,%rdi
  800420b269:	00 00 00 
  800420b26c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b271:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800420b278:	00 00 00 
  800420b27b:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420b27d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b281:	48 89 c7             	mov    %rax,%rdi
  800420b284:	48 b8 52 b5 20 04 80 	movabs $0x800420b552,%rax
  800420b28b:	00 00 00 
  800420b28e:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420b290:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b294:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420b298:	0f b7 c0             	movzwl %ax,%eax
  800420b29b:	89 c6                	mov    %eax,%esi
  800420b29d:	48 bf 6c 89 21 04 80 	movabs $0x800421896c,%rdi
  800420b2a4:	00 00 00 
  800420b2a7:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2ac:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b2b3:	00 00 00 
  800420b2b6:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420b2b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2bc:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420b2c3:	0f b7 c0             	movzwl %ax,%eax
  800420b2c6:	89 c6                	mov    %eax,%esi
  800420b2c8:	48 bf 7f 89 21 04 80 	movabs $0x800421897f,%rdi
  800420b2cf:	00 00 00 
  800420b2d2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2d7:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b2de:	00 00 00 
  800420b2e1:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420b2e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2e7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b2ee:	89 c7                	mov    %eax,%edi
  800420b2f0:	48 b8 98 98 20 04 80 	movabs $0x8004209898,%rax
  800420b2f7:	00 00 00 
  800420b2fa:	ff d0                	callq  *%rax
  800420b2fc:	48 89 c2             	mov    %rax,%rdx
  800420b2ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b303:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b30a:	48 89 c6             	mov    %rax,%rsi
  800420b30d:	48 bf 92 89 21 04 80 	movabs $0x8004218992,%rdi
  800420b314:	00 00 00 
  800420b317:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b31c:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800420b323:	00 00 00 
  800420b326:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420b328:	48 b8 90 52 37 04 80 	movabs $0x8004375290,%rax
  800420b32f:	00 00 00 
  800420b332:	48 8b 00             	mov    (%rax),%rax
  800420b335:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420b339:	75 3a                	jne    800420b375 <print_trapframe+0x134>
  800420b33b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b33f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b346:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b34a:	75 29                	jne    800420b375 <print_trapframe+0x134>

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b34c:	0f 20 d0             	mov    %cr2,%rax
  800420b34f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return val;
  800420b353:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420b357:	48 89 c6             	mov    %rax,%rsi
  800420b35a:	48 bf a4 89 21 04 80 	movabs $0x80042189a4,%rdi
  800420b361:	00 00 00 
  800420b364:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b369:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b370:	00 00 00 
  800420b373:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420b375:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b379:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b380:	48 89 c6             	mov    %rax,%rsi
  800420b383:	48 bf b3 89 21 04 80 	movabs $0x80042189b3,%rdi
  800420b38a:	00 00 00 
  800420b38d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b392:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b399:	00 00 00 
  800420b39c:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420b39e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3a2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b3a9:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b3ad:	0f 85 9c 00 00 00    	jne    800420b44f <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420b3b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3b7:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b3be:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b3c1:	48 85 c0             	test   %rax,%rax
  800420b3c4:	74 0c                	je     800420b3d2 <print_trapframe+0x191>
  800420b3c6:	48 b9 c1 89 21 04 80 	movabs $0x80042189c1,%rcx
  800420b3cd:	00 00 00 
  800420b3d0:	eb 0a                	jmp    800420b3dc <print_trapframe+0x19b>
  800420b3d2:	48 b9 cc 89 21 04 80 	movabs $0x80042189cc,%rcx
  800420b3d9:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420b3dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b3e0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b3e7:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b3ea:	48 85 c0             	test   %rax,%rax
  800420b3ed:	74 0c                	je     800420b3fb <print_trapframe+0x1ba>
  800420b3ef:	48 ba d8 89 21 04 80 	movabs $0x80042189d8,%rdx
  800420b3f6:	00 00 00 
  800420b3f9:	eb 0a                	jmp    800420b405 <print_trapframe+0x1c4>
  800420b3fb:	48 ba de 89 21 04 80 	movabs $0x80042189de,%rdx
  800420b402:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420b405:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b409:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b410:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b413:	48 85 c0             	test   %rax,%rax
  800420b416:	74 0c                	je     800420b424 <print_trapframe+0x1e3>
  800420b418:	48 b8 e3 89 21 04 80 	movabs $0x80042189e3,%rax
  800420b41f:	00 00 00 
  800420b422:	eb 0a                	jmp    800420b42e <print_trapframe+0x1ed>
  800420b424:	48 b8 e8 89 21 04 80 	movabs $0x80042189e8,%rax
  800420b42b:	00 00 00 
  800420b42e:	48 89 c6             	mov    %rax,%rsi
  800420b431:	48 bf ef 89 21 04 80 	movabs $0x80042189ef,%rdi
  800420b438:	00 00 00 
  800420b43b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b440:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  800420b447:	00 00 00 
  800420b44a:	41 ff d0             	callq  *%r8
  800420b44d:	eb 1b                	jmp    800420b46a <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420b44f:	48 bf fe 89 21 04 80 	movabs $0x80042189fe,%rdi
  800420b456:	00 00 00 
  800420b459:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b45e:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b465:	00 00 00 
  800420b468:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420b46a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b46e:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420b475:	48 89 c6             	mov    %rax,%rsi
  800420b478:	48 bf 00 8a 21 04 80 	movabs $0x8004218a00,%rdi
  800420b47f:	00 00 00 
  800420b482:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b487:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b48e:	00 00 00 
  800420b491:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420b493:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b497:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b49e:	0f b7 c0             	movzwl %ax,%eax
  800420b4a1:	89 c6                	mov    %eax,%esi
  800420b4a3:	48 bf 0f 8a 21 04 80 	movabs $0x8004218a0f,%rdi
  800420b4aa:	00 00 00 
  800420b4ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4b2:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b4b9:	00 00 00 
  800420b4bc:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420b4be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4c2:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420b4c9:	48 89 c6             	mov    %rax,%rsi
  800420b4cc:	48 bf 22 8a 21 04 80 	movabs $0x8004218a22,%rdi
  800420b4d3:	00 00 00 
  800420b4d6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4db:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b4e2:	00 00 00 
  800420b4e5:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420b4e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b4eb:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b4f2:	0f b7 c0             	movzwl %ax,%eax
  800420b4f5:	83 e0 03             	and    $0x3,%eax
  800420b4f8:	85 c0                	test   %eax,%eax
  800420b4fa:	74 54                	je     800420b550 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420b4fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b500:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b507:	48 89 c6             	mov    %rax,%rsi
  800420b50a:	48 bf 31 8a 21 04 80 	movabs $0x8004218a31,%rdi
  800420b511:	00 00 00 
  800420b514:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b519:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b520:	00 00 00 
  800420b523:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420b525:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b529:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420b530:	0f b7 c0             	movzwl %ax,%eax
  800420b533:	89 c6                	mov    %eax,%esi
  800420b535:	48 bf 40 8a 21 04 80 	movabs $0x8004218a40,%rdi
  800420b53c:	00 00 00 
  800420b53f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b544:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b54b:	00 00 00 
  800420b54e:	ff d2                	callq  *%rdx
	}
}
  800420b550:	c9                   	leaveq 
  800420b551:	c3                   	retq   

000000800420b552 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420b552:	55                   	push   %rbp
  800420b553:	48 89 e5             	mov    %rsp,%rbp
  800420b556:	48 83 ec 10          	sub    $0x10,%rsp
  800420b55a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420b55e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b562:	48 8b 00             	mov    (%rax),%rax
  800420b565:	48 89 c6             	mov    %rax,%rsi
  800420b568:	48 bf 53 8a 21 04 80 	movabs $0x8004218a53,%rdi
  800420b56f:	00 00 00 
  800420b572:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b577:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b57e:	00 00 00 
  800420b581:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420b583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b587:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b58b:	48 89 c6             	mov    %rax,%rsi
  800420b58e:	48 bf 62 8a 21 04 80 	movabs $0x8004218a62,%rdi
  800420b595:	00 00 00 
  800420b598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b59d:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b5a4:	00 00 00 
  800420b5a7:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420b5a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b5ad:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b5b1:	48 89 c6             	mov    %rax,%rsi
  800420b5b4:	48 bf 71 8a 21 04 80 	movabs $0x8004218a71,%rdi
  800420b5bb:	00 00 00 
  800420b5be:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5c3:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b5ca:	00 00 00 
  800420b5cd:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420b5cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b5d3:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b5d7:	48 89 c6             	mov    %rax,%rsi
  800420b5da:	48 bf 80 8a 21 04 80 	movabs $0x8004218a80,%rdi
  800420b5e1:	00 00 00 
  800420b5e4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b5e9:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b5f0:	00 00 00 
  800420b5f3:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420b5f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b5f9:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420b5fd:	48 89 c6             	mov    %rax,%rsi
  800420b600:	48 bf 8f 8a 21 04 80 	movabs $0x8004218a8f,%rdi
  800420b607:	00 00 00 
  800420b60a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b60f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b616:	00 00 00 
  800420b619:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420b61b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b61f:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420b623:	48 89 c6             	mov    %rax,%rsi
  800420b626:	48 bf 9e 8a 21 04 80 	movabs $0x8004218a9e,%rdi
  800420b62d:	00 00 00 
  800420b630:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b635:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b63c:	00 00 00 
  800420b63f:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420b641:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b645:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420b649:	48 89 c6             	mov    %rax,%rsi
  800420b64c:	48 bf ad 8a 21 04 80 	movabs $0x8004218aad,%rdi
  800420b653:	00 00 00 
  800420b656:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b65b:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b662:	00 00 00 
  800420b665:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420b667:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b66b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b66f:	48 89 c6             	mov    %rax,%rsi
  800420b672:	48 bf bb 8a 21 04 80 	movabs $0x8004218abb,%rdi
  800420b679:	00 00 00 
  800420b67c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b681:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b688:	00 00 00 
  800420b68b:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420b68d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b691:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b695:	48 89 c6             	mov    %rax,%rsi
  800420b698:	48 bf c9 8a 21 04 80 	movabs $0x8004218ac9,%rdi
  800420b69f:	00 00 00 
  800420b6a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6a7:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b6ae:	00 00 00 
  800420b6b1:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420b6b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6b7:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b6bb:	48 89 c6             	mov    %rax,%rsi
  800420b6be:	48 bf d8 8a 21 04 80 	movabs $0x8004218ad8,%rdi
  800420b6c5:	00 00 00 
  800420b6c8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6cd:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b6d4:	00 00 00 
  800420b6d7:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420b6d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b6dd:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420b6e1:	48 89 c6             	mov    %rax,%rsi
  800420b6e4:	48 bf e7 8a 21 04 80 	movabs $0x8004218ae7,%rdi
  800420b6eb:	00 00 00 
  800420b6ee:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b6f3:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b6fa:	00 00 00 
  800420b6fd:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420b6ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b703:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b707:	48 89 c6             	mov    %rax,%rsi
  800420b70a:	48 bf f6 8a 21 04 80 	movabs $0x8004218af6,%rdi
  800420b711:	00 00 00 
  800420b714:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b719:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b720:	00 00 00 
  800420b723:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420b725:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b729:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b72d:	48 89 c6             	mov    %rax,%rsi
  800420b730:	48 bf 05 8b 21 04 80 	movabs $0x8004218b05,%rdi
  800420b737:	00 00 00 
  800420b73a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b73f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b746:	00 00 00 
  800420b749:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420b74b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b74f:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b753:	48 89 c6             	mov    %rax,%rsi
  800420b756:	48 bf 14 8b 21 04 80 	movabs $0x8004218b14,%rdi
  800420b75d:	00 00 00 
  800420b760:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b765:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b76c:	00 00 00 
  800420b76f:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b771:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b775:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b779:	48 89 c6             	mov    %rax,%rsi
  800420b77c:	48 bf 23 8b 21 04 80 	movabs $0x8004218b23,%rdi
  800420b783:	00 00 00 
  800420b786:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b78b:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b792:	00 00 00 
  800420b795:	ff d2                	callq  *%rdx
}
  800420b797:	c9                   	leaveq 
  800420b798:	c3                   	retq   

000000800420b799 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b799:	55                   	push   %rbp
  800420b79a:	48 89 e5             	mov    %rsp,%rbp
  800420b79d:	48 83 ec 10          	sub    $0x10,%rsp
  800420b7a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.


	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b7a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7a9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b7b0:	48 83 f8 27          	cmp    $0x27,%rax
  800420b7b4:	75 33                	jne    800420b7e9 <trap_dispatch+0x50>
		cprintf("Spurious interrupt on irq 7\n");
  800420b7b6:	48 bf 32 8b 21 04 80 	movabs $0x8004218b32,%rdi
  800420b7bd:	00 00 00 
  800420b7c0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b7c5:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420b7cc:	00 00 00 
  800420b7cf:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b7d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7d5:	48 89 c7             	mov    %rax,%rdi
  800420b7d8:	48 b8 41 b2 20 04 80 	movabs $0x800420b241,%rax
  800420b7df:	00 00 00 
  800420b7e2:	ff d0                	callq  *%rax
		return;
  800420b7e4:	e9 94 01 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>
	// LAB 5: Your code here.


	// Handle processor exceptions.
	// LAB 3: Your code here.
	switch (tf->tf_trapno)
  800420b7e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b7ed:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b7f4:	48 83 f8 30          	cmp    $0x30,%rax
  800420b7f8:	0f 87 f1 00 00 00    	ja     800420b8ef <trap_dispatch+0x156>
  800420b7fe:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b805:	00 
  800420b806:	48 b8 78 8b 21 04 80 	movabs $0x8004218b78,%rax
  800420b80d:	00 00 00 
  800420b810:	48 01 d0             	add    %rdx,%rax
  800420b813:	48 8b 00             	mov    (%rax),%rax
  800420b816:	ff e0                	jmpq   *%rax
	{
		case T_PGFLT:
		page_fault_handler(tf);
  800420b818:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b81c:	48 89 c7             	mov    %rax,%rdi
  800420b81f:	48 b8 dc bc 20 04 80 	movabs $0x800420bcdc,%rax
  800420b826:	00 00 00 
  800420b829:	ff d0                	callq  *%rax
		break;
  800420b82b:	e9 4d 01 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>

		case T_BRKPT:
		monitor(tf);
  800420b830:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b834:	48 89 c7             	mov    %rax,%rdi
  800420b837:	48 b8 e7 24 20 04 80 	movabs $0x80042024e7,%rax
  800420b83e:	00 00 00 
  800420b841:	ff d0                	callq  *%rax
		break;
  800420b843:	e9 35 01 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>

		case T_DEBUG: 
		monitor(tf);
  800420b848:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b84c:	48 89 c7             	mov    %rax,%rdi
  800420b84f:	48 b8 e7 24 20 04 80 	movabs $0x80042024e7,%rax
  800420b856:	00 00 00 
  800420b859:	ff d0                	callq  *%rax
		break;
  800420b85b:	e9 1d 01 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>

		case T_SYSCALL:
		tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
  800420b860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b864:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420b868:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b86c:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420b870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b874:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420b878:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b87c:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420b880:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b884:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420b888:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b88c:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b890:	4d 89 c1             	mov    %r8,%r9
  800420b893:	49 89 f8             	mov    %rdi,%r8
  800420b896:	48 89 c7             	mov    %rax,%rdi
  800420b899:	48 b8 08 d1 20 04 80 	movabs $0x800420d108,%rax
  800420b8a0:	00 00 00 
  800420b8a3:	ff d0                	callq  *%rax
  800420b8a5:	48 89 c2             	mov    %rax,%rdx
  800420b8a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8ac:	48 89 50 70          	mov    %rdx,0x70(%rax)
		break;
  800420b8b0:	e9 c8 00 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>

		case IRQ_OFFSET+IRQ_TIMER:
		lapic_eoi();
  800420b8b5:	48 b8 8f 5e 21 04 80 	movabs $0x8004215e8f,%rax
  800420b8bc:	00 00 00 
  800420b8bf:	ff d0                	callq  *%rax
		sched_yield();
  800420b8c1:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  800420b8c8:	00 00 00 
  800420b8cb:	ff d0                	callq  *%rax
		break;

		case IRQ_OFFSET+IRQ_KBD:
		kbd_intr();
  800420b8cd:	48 b8 39 11 20 04 80 	movabs $0x8004201139,%rax
  800420b8d4:	00 00 00 
  800420b8d7:	ff d0                	callq  *%rax
		break;
  800420b8d9:	e9 9f 00 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>

		case IRQ_OFFSET+IRQ_SERIAL:
		serial_intr();
  800420b8de:	48 b8 bc 08 20 04 80 	movabs $0x80042008bc,%rax
  800420b8e5:	00 00 00 
  800420b8e8:	ff d0                	callq  *%rax
		break;
  800420b8ea:	e9 8e 00 00 00       	jmpq   800420b97d <trap_dispatch+0x1e4>
		
		default:
	// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
  800420b8ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b8f3:	48 89 c7             	mov    %rax,%rdi
  800420b8f6:	48 b8 41 b2 20 04 80 	movabs $0x800420b241,%rax
  800420b8fd:	00 00 00 
  800420b900:	ff d0                	callq  *%rax
		if (tf->tf_cs == GD_KT)
  800420b902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b906:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b90d:	66 83 f8 08          	cmp    $0x8,%ax
  800420b911:	75 2a                	jne    800420b93d <trap_dispatch+0x1a4>
			panic("unhandled trap in kernel");
  800420b913:	48 ba 4f 8b 21 04 80 	movabs $0x8004218b4f,%rdx
  800420b91a:	00 00 00 
  800420b91d:	be 41 01 00 00       	mov    $0x141,%esi
  800420b922:	48 bf 68 8b 21 04 80 	movabs $0x8004218b68,%rdi
  800420b929:	00 00 00 
  800420b92c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b931:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420b938:	00 00 00 
  800420b93b:	ff d1                	callq  *%rcx
		else {
			env_destroy(curenv);
  800420b93d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420b944:	00 00 00 
  800420b947:	ff d0                	callq  *%rax
  800420b949:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420b950:	00 00 00 
  800420b953:	48 98                	cltq   
  800420b955:	48 c1 e0 03          	shl    $0x3,%rax
  800420b959:	48 89 c1             	mov    %rax,%rcx
  800420b95c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b960:	48 01 c8             	add    %rcx,%rax
  800420b963:	48 01 d0             	add    %rdx,%rax
  800420b966:	48 83 c0 08          	add    $0x8,%rax
  800420b96a:	48 8b 00             	mov    (%rax),%rax
  800420b96d:	48 89 c7             	mov    %rax,%rdi
  800420b970:	48 b8 48 90 20 04 80 	movabs $0x8004209048,%rax
  800420b977:	00 00 00 
  800420b97a:	ff d0                	callq  *%rax
			return;
  800420b97c:	90                   	nop

		}

	}
}
  800420b97d:	c9                   	leaveq 
  800420b97e:	c3                   	retq   

000000800420b97f <trap>:

void
trap(struct Trapframe *tf)
{
  800420b97f:	55                   	push   %rbp
  800420b980:	48 89 e5             	mov    %rsp,%rbp
  800420b983:	48 83 ec 20          	sub    $0x20,%rsp
  800420b987:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420b98b:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420b98c:	48 b8 50 57 37 04 80 	movabs $0x8004375750,%rax
  800420b993:	00 00 00 
  800420b996:	48 8b 00             	mov    (%rax),%rax
  800420b999:	48 85 c0             	test   %rax,%rax
  800420b99c:	74 01                	je     800420b99f <trap+0x20>
		asm volatile("hlt");
  800420b99e:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420b99f:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420b9a6:	00 00 00 
  800420b9a9:	ff d0                	callq  *%rax
  800420b9ab:	48 98                	cltq   
  800420b9ad:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9b1:	48 89 c2             	mov    %rax,%rdx
  800420b9b4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9b8:	48 01 d0             	add    %rdx,%rax
  800420b9bb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420b9c2:	00 00 00 
  800420b9c5:	48 01 d0             	add    %rdx,%rax
  800420b9c8:	48 83 c0 04          	add    $0x4,%rax
  800420b9cc:	be 01 00 00 00       	mov    $0x1,%esi
  800420b9d1:	48 89 c7             	mov    %rax,%rdi
  800420b9d4:	48 b8 57 98 20 04 80 	movabs $0x8004209857,%rax
  800420b9db:	00 00 00 
  800420b9de:	ff d0                	callq  *%rax
  800420b9e0:	83 f8 02             	cmp    $0x2,%eax
  800420b9e3:	75 0c                	jne    800420b9f1 <trap+0x72>
		lock_kernel();
  800420b9e5:	48 b8 7c 98 20 04 80 	movabs $0x800420987c,%rax
  800420b9ec:	00 00 00 
  800420b9ef:	ff d0                	callq  *%rax

    static __inline uint64_t
read_eflags(void)
{
    uint64_t rflags;
    __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420b9f1:	9c                   	pushfq 
  800420b9f2:	58                   	pop    %rax
  800420b9f3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return rflags;
  800420b9f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420b9fb:	25 00 02 00 00       	and    $0x200,%eax
  800420ba00:	48 85 c0             	test   %rax,%rax
  800420ba03:	74 35                	je     800420ba3a <trap+0xbb>
  800420ba05:	48 b9 00 8d 21 04 80 	movabs $0x8004218d00,%rcx
  800420ba0c:	00 00 00 
  800420ba0f:	48 ba 19 8d 21 04 80 	movabs $0x8004218d19,%rdx
  800420ba16:	00 00 00 
  800420ba19:	be 5f 01 00 00       	mov    $0x15f,%esi
  800420ba1e:	48 bf 68 8b 21 04 80 	movabs $0x8004218b68,%rdi
  800420ba25:	00 00 00 
  800420ba28:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ba2d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420ba34:	00 00 00 
  800420ba37:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420ba3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ba3e:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ba45:	0f b7 c0             	movzwl %ax,%eax
  800420ba48:	83 e0 03             	and    $0x3,%eax
  800420ba4b:	83 f8 03             	cmp    $0x3,%eax
  800420ba4e:	0f 85 a9 01 00 00    	jne    800420bbfd <trap+0x27e>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.

		lock_kernel();
  800420ba54:	48 b8 7c 98 20 04 80 	movabs $0x800420987c,%rax
  800420ba5b:	00 00 00 
  800420ba5e:	ff d0                	callq  *%rax

		assert(curenv);
  800420ba60:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ba67:	00 00 00 
  800420ba6a:	ff d0                	callq  *%rax
  800420ba6c:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420ba73:	00 00 00 
  800420ba76:	48 98                	cltq   
  800420ba78:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba7c:	48 89 c1             	mov    %rax,%rcx
  800420ba7f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ba83:	48 01 c8             	add    %rcx,%rax
  800420ba86:	48 01 d0             	add    %rdx,%rax
  800420ba89:	48 83 c0 08          	add    $0x8,%rax
  800420ba8d:	48 8b 00             	mov    (%rax),%rax
  800420ba90:	48 85 c0             	test   %rax,%rax
  800420ba93:	75 35                	jne    800420baca <trap+0x14b>
  800420ba95:	48 b9 2e 8d 21 04 80 	movabs $0x8004218d2e,%rcx
  800420ba9c:	00 00 00 
  800420ba9f:	48 ba 19 8d 21 04 80 	movabs $0x8004218d19,%rdx
  800420baa6:	00 00 00 
  800420baa9:	be 69 01 00 00       	mov    $0x169,%esi
  800420baae:	48 bf 68 8b 21 04 80 	movabs $0x8004218b68,%rdi
  800420bab5:	00 00 00 
  800420bab8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420babd:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420bac4:	00 00 00 
  800420bac7:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420baca:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bad1:	00 00 00 
  800420bad4:	ff d0                	callq  *%rax
  800420bad6:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420badd:	00 00 00 
  800420bae0:	48 98                	cltq   
  800420bae2:	48 c1 e0 03          	shl    $0x3,%rax
  800420bae6:	48 89 c1             	mov    %rax,%rcx
  800420bae9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420baed:	48 01 c8             	add    %rcx,%rax
  800420baf0:	48 01 d0             	add    %rdx,%rax
  800420baf3:	48 83 c0 08          	add    $0x8,%rax
  800420baf7:	48 8b 00             	mov    (%rax),%rax
  800420bafa:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bb00:	83 f8 01             	cmp    $0x1,%eax
  800420bb03:	75 7f                	jne    800420bb84 <trap+0x205>
			env_free(curenv);
  800420bb05:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bb0c:	00 00 00 
  800420bb0f:	ff d0                	callq  *%rax
  800420bb11:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bb18:	00 00 00 
  800420bb1b:	48 98                	cltq   
  800420bb1d:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb21:	48 89 c1             	mov    %rax,%rcx
  800420bb24:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bb28:	48 01 c8             	add    %rcx,%rax
  800420bb2b:	48 01 d0             	add    %rdx,%rax
  800420bb2e:	48 83 c0 08          	add    $0x8,%rax
  800420bb32:	48 8b 00             	mov    (%rax),%rax
  800420bb35:	48 89 c7             	mov    %rax,%rdi
  800420bb38:	48 b8 bc 8b 20 04 80 	movabs $0x8004208bbc,%rax
  800420bb3f:	00 00 00 
  800420bb42:	ff d0                	callq  *%rax
			curenv = NULL;
  800420bb44:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bb4b:	00 00 00 
  800420bb4e:	ff d0                	callq  *%rax
  800420bb50:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bb57:	00 00 00 
  800420bb5a:	48 98                	cltq   
  800420bb5c:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb60:	48 89 c1             	mov    %rax,%rcx
  800420bb63:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bb67:	48 01 c8             	add    %rcx,%rax
  800420bb6a:	48 01 d0             	add    %rdx,%rax
  800420bb6d:	48 83 c0 08          	add    $0x8,%rax
  800420bb71:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420bb78:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  800420bb7f:	00 00 00 
  800420bb82:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420bb84:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bb8b:	00 00 00 
  800420bb8e:	ff d0                	callq  *%rax
  800420bb90:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bb97:	00 00 00 
  800420bb9a:	48 98                	cltq   
  800420bb9c:	48 c1 e0 03          	shl    $0x3,%rax
  800420bba0:	48 89 c1             	mov    %rax,%rcx
  800420bba3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bba7:	48 01 c8             	add    %rcx,%rax
  800420bbaa:	48 01 d0             	add    %rdx,%rax
  800420bbad:	48 83 c0 08          	add    $0x8,%rax
  800420bbb1:	48 8b 10             	mov    (%rax),%rdx
  800420bbb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bbb8:	48 89 c6             	mov    %rax,%rsi
  800420bbbb:	b8 18 00 00 00       	mov    $0x18,%eax
  800420bbc0:	48 89 d7             	mov    %rdx,%rdi
  800420bbc3:	48 89 c1             	mov    %rax,%rcx
  800420bbc6:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420bbc9:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bbd0:	00 00 00 
  800420bbd3:	ff d0                	callq  *%rax
  800420bbd5:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bbdc:	00 00 00 
  800420bbdf:	48 98                	cltq   
  800420bbe1:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbe5:	48 89 c1             	mov    %rax,%rcx
  800420bbe8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bbec:	48 01 c8             	add    %rcx,%rax
  800420bbef:	48 01 d0             	add    %rdx,%rax
  800420bbf2:	48 83 c0 08          	add    $0x8,%rax
  800420bbf6:	48 8b 00             	mov    (%rax),%rax
  800420bbf9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420bbfd:	48 b8 90 52 37 04 80 	movabs $0x8004375290,%rax
  800420bc04:	00 00 00 
  800420bc07:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420bc0b:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420bc0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bc12:	48 89 c7             	mov    %rax,%rdi
  800420bc15:	48 b8 99 b7 20 04 80 	movabs $0x800420b799,%rax
  800420bc1c:	00 00 00 
  800420bc1f:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420bc21:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bc28:	00 00 00 
  800420bc2b:	ff d0                	callq  *%rax
  800420bc2d:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bc34:	00 00 00 
  800420bc37:	48 98                	cltq   
  800420bc39:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc3d:	48 89 c1             	mov    %rax,%rcx
  800420bc40:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bc44:	48 01 c8             	add    %rcx,%rax
  800420bc47:	48 01 d0             	add    %rdx,%rax
  800420bc4a:	48 83 c0 08          	add    $0x8,%rax
  800420bc4e:	48 8b 00             	mov    (%rax),%rax
  800420bc51:	48 85 c0             	test   %rax,%rax
  800420bc54:	74 7a                	je     800420bcd0 <trap+0x351>
  800420bc56:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bc5d:	00 00 00 
  800420bc60:	ff d0                	callq  *%rax
  800420bc62:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bc69:	00 00 00 
  800420bc6c:	48 98                	cltq   
  800420bc6e:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc72:	48 89 c1             	mov    %rax,%rcx
  800420bc75:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bc79:	48 01 c8             	add    %rcx,%rax
  800420bc7c:	48 01 d0             	add    %rdx,%rax
  800420bc7f:	48 83 c0 08          	add    $0x8,%rax
  800420bc83:	48 8b 00             	mov    (%rax),%rax
  800420bc86:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bc8c:	83 f8 03             	cmp    $0x3,%eax
  800420bc8f:	75 3f                	jne    800420bcd0 <trap+0x351>
		env_run(curenv);
  800420bc91:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bc98:	00 00 00 
  800420bc9b:	ff d0                	callq  *%rax
  800420bc9d:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bca4:	00 00 00 
  800420bca7:	48 98                	cltq   
  800420bca9:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcad:	48 89 c1             	mov    %rax,%rcx
  800420bcb0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bcb4:	48 01 c8             	add    %rcx,%rax
  800420bcb7:	48 01 d0             	add    %rdx,%rax
  800420bcba:	48 83 c0 08          	add    $0x8,%rax
  800420bcbe:	48 8b 00             	mov    (%rax),%rax
  800420bcc1:	48 89 c7             	mov    %rax,%rdi
  800420bcc4:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  800420bccb:	00 00 00 
  800420bcce:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420bcd0:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  800420bcd7:	00 00 00 
  800420bcda:	ff d0                	callq  *%rax

000000800420bcdc <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420bcdc:	55                   	push   %rbp
  800420bcdd:	48 89 e5             	mov    %rsp,%rbp
  800420bce0:	53                   	push   %rbx
  800420bce1:	48 83 ec 38          	sub    $0x38,%rsp
  800420bce5:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bce9:	0f 20 d0             	mov    %cr2,%rax
  800420bcec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    return val;
  800420bcf0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420bcf4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// Handle kernel-mode page faults.

	// LAB 3: Your code here.


	if (!(tf->tf_cs&3))
  800420bcf8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bcfc:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bd03:	0f b7 c0             	movzwl %ax,%eax
  800420bd06:	83 e0 03             	and    $0x3,%eax
  800420bd09:	85 c0                	test   %eax,%eax
  800420bd0b:	75 2a                	jne    800420bd37 <page_fault_handler+0x5b>
		panic ("kernel mode pauge fault happened!");
  800420bd0d:	48 ba 38 8d 21 04 80 	movabs $0x8004218d38,%rdx
  800420bd14:	00 00 00 
  800420bd17:	be 99 01 00 00       	mov    $0x199,%esi
  800420bd1c:	48 bf 68 8b 21 04 80 	movabs $0x8004218b68,%rdi
  800420bd23:	00 00 00 
  800420bd26:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bd2b:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420bd32:	00 00 00 
  800420bd35:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.

	if (curenv->env_pgfault_upcall){
  800420bd37:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bd3e:	00 00 00 
  800420bd41:	ff d0                	callq  *%rax
  800420bd43:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bd4a:	00 00 00 
  800420bd4d:	48 98                	cltq   
  800420bd4f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd53:	48 89 c1             	mov    %rax,%rcx
  800420bd56:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bd5a:	48 01 c8             	add    %rcx,%rax
  800420bd5d:	48 01 d0             	add    %rdx,%rax
  800420bd60:	48 83 c0 08          	add    $0x8,%rax
  800420bd64:	48 8b 00             	mov    (%rax),%rax
  800420bd67:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bd6e:	48 85 c0             	test   %rax,%rax
  800420bd71:	0f 84 5d 02 00 00    	je     800420bfd4 <page_fault_handler+0x2f8>
		struct UTrapframe *utf;
		utf = (struct UTrapframe *)( (tf->tf_rsp>=UXSTACKTOP-PGSIZE && tf->tf_rsp<UXSTACKTOP)?tf->tf_rsp-sizeof(struct UTrapframe)-8:UXSTACKTOP-sizeof(struct UTrapframe) );
  800420bd77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bd7b:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bd82:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420bd87:	48 39 c2             	cmp    %rax,%rdx
  800420bd8a:	76 28                	jbe    800420bdb4 <page_fault_handler+0xd8>
  800420bd8c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bd90:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bd97:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420bd9c:	48 39 c2             	cmp    %rax,%rdx
  800420bd9f:	77 13                	ja     800420bdb4 <page_fault_handler+0xd8>
  800420bda1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bda5:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420bdac:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420bdb2:	eb 05                	jmp    800420bdb9 <page_fault_handler+0xdd>
  800420bdb4:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420bdb9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		user_mem_assert(curenv, (void*)utf, sizeof(struct UTrapframe),  PTE_P|PTE_U|PTE_W);
  800420bdbd:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bdc4:	00 00 00 
  800420bdc7:	ff d0                	callq  *%rax
  800420bdc9:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bdd0:	00 00 00 
  800420bdd3:	48 98                	cltq   
  800420bdd5:	48 c1 e0 03          	shl    $0x3,%rax
  800420bdd9:	48 89 c1             	mov    %rax,%rcx
  800420bddc:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bde0:	48 01 c8             	add    %rcx,%rax
  800420bde3:	48 01 d0             	add    %rdx,%rax
  800420bde6:	48 83 c0 08          	add    $0x8,%rax
  800420bdea:	48 8b 00             	mov    (%rax),%rax
  800420bded:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420bdf1:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420bdf6:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420bdfb:	48 89 c7             	mov    %rax,%rdi
  800420bdfe:	48 b8 c5 47 20 04 80 	movabs $0x80042047c5,%rax
  800420be05:	00 00 00 
  800420be08:	ff d0                	callq  *%rax
		utf->utf_eflags = tf->tf_eflags;
  800420be0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be0e:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420be15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420be19:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_rip = tf->tf_rip;
  800420be20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be24:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420be2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420be2f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_err = tf->tf_err;
  800420be36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420be3a:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420be41:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420be45:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420be49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420be4d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420be51:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420be54:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420be58:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420be5c:	48 8b 0a             	mov    (%rdx),%rcx
  800420be5f:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420be63:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420be67:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420be6b:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420be6f:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420be73:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420be77:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420be7b:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420be7f:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420be83:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420be87:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420be8b:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420be8f:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420be93:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420be97:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420be9b:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420be9f:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420bea3:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420bea7:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420beab:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420beaf:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420beb3:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420beb7:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420bebb:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420bebf:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420bec3:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420bec7:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420becb:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420becf:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420bed6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420beda:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bee1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bee5:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		curenv->env_tf.tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420beec:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bef3:	00 00 00 
  800420bef6:	ff d0                	callq  *%rax
  800420bef8:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420beff:	00 00 00 
  800420bf02:	48 98                	cltq   
  800420bf04:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf08:	48 89 c1             	mov    %rax,%rcx
  800420bf0b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bf0f:	48 01 c8             	add    %rcx,%rax
  800420bf12:	48 01 d0             	add    %rdx,%rax
  800420bf15:	48 83 c0 08          	add    $0x8,%rax
  800420bf19:	48 8b 18             	mov    (%rax),%rbx
  800420bf1c:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bf23:	00 00 00 
  800420bf26:	ff d0                	callq  *%rax
  800420bf28:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bf2f:	00 00 00 
  800420bf32:	48 98                	cltq   
  800420bf34:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf38:	48 89 c1             	mov    %rax,%rcx
  800420bf3b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bf3f:	48 01 c8             	add    %rcx,%rax
  800420bf42:	48 01 d0             	add    %rdx,%rax
  800420bf45:	48 83 c0 08          	add    $0x8,%rax
  800420bf49:	48 8b 00             	mov    (%rax),%rax
  800420bf4c:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bf53:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		curenv->env_tf.tf_rsp = (uintptr_t)utf;
  800420bf5a:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bf61:	00 00 00 
  800420bf64:	ff d0                	callq  *%rax
  800420bf66:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bf6d:	00 00 00 
  800420bf70:	48 98                	cltq   
  800420bf72:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf76:	48 89 c1             	mov    %rax,%rcx
  800420bf79:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bf7d:	48 01 c8             	add    %rcx,%rax
  800420bf80:	48 01 d0             	add    %rdx,%rax
  800420bf83:	48 83 c0 08          	add    $0x8,%rax
  800420bf87:	48 8b 00             	mov    (%rax),%rax
  800420bf8a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bf8e:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv);
  800420bf95:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bf9c:	00 00 00 
  800420bf9f:	ff d0                	callq  *%rax
  800420bfa1:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bfa8:	00 00 00 
  800420bfab:	48 98                	cltq   
  800420bfad:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfb1:	48 89 c1             	mov    %rax,%rcx
  800420bfb4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bfb8:	48 01 c8             	add    %rcx,%rax
  800420bfbb:	48 01 d0             	add    %rdx,%rax
  800420bfbe:	48 83 c0 08          	add    $0x8,%rax
  800420bfc2:	48 8b 00             	mov    (%rax),%rax
  800420bfc5:	48 89 c7             	mov    %rax,%rdi
  800420bfc8:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  800420bfcf:	00 00 00 
  800420bfd2:	ff d0                	callq  *%rax
		return;
	}

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420bfd4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420bfd8:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420bfdf:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420bfe6:	00 00 00 
  800420bfe9:	ff d0                	callq  *%rax
  800420bfeb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420bff2:	00 00 00 
  800420bff5:	48 98                	cltq   
  800420bff7:	48 c1 e0 03          	shl    $0x3,%rax
  800420bffb:	48 89 c1             	mov    %rax,%rcx
  800420bffe:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c002:	48 01 c8             	add    %rcx,%rax
  800420c005:	48 01 d0             	add    %rdx,%rax
  800420c008:	48 83 c0 08          	add    $0x8,%rax
  800420c00c:	48 8b 00             	mov    (%rax),%rax
		env_run(curenv);
		return;
	}

	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420c00f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c015:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c019:	48 89 d9             	mov    %rbx,%rcx
  800420c01c:	89 c6                	mov    %eax,%esi
  800420c01e:	48 bf 60 8d 21 04 80 	movabs $0x8004218d60,%rdi
  800420c025:	00 00 00 
  800420c028:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c02d:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  800420c034:	00 00 00 
  800420c037:	41 ff d0             	callq  *%r8
		curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420c03a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c03e:	48 89 c7             	mov    %rax,%rdi
  800420c041:	48 b8 41 b2 20 04 80 	movabs $0x800420b241,%rax
  800420c048:	00 00 00 
  800420c04b:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420c04d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c054:	00 00 00 
  800420c057:	ff d0                	callq  *%rax
  800420c059:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c060:	00 00 00 
  800420c063:	48 98                	cltq   
  800420c065:	48 c1 e0 03          	shl    $0x3,%rax
  800420c069:	48 89 c1             	mov    %rax,%rcx
  800420c06c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c070:	48 01 c8             	add    %rcx,%rax
  800420c073:	48 01 d0             	add    %rdx,%rax
  800420c076:	48 83 c0 08          	add    $0x8,%rax
  800420c07a:	48 8b 00             	mov    (%rax),%rax
  800420c07d:	48 89 c7             	mov    %rax,%rdi
  800420c080:	48 b8 48 90 20 04 80 	movabs $0x8004209048,%rax
  800420c087:	00 00 00 
  800420c08a:	ff d0                	callq  *%rax
}
  800420c08c:	48 83 c4 38          	add    $0x38,%rsp
  800420c090:	5b                   	pop    %rbx
  800420c091:	5d                   	pop    %rbp
  800420c092:	c3                   	retq   
  800420c093:	90                   	nop

000000800420c094 <entry0>:
.data
.align 2
.global entries
entries:
.text
TRAPHANDLER_NOEC(entry0, 0)
  800420c094:	6a 00                	pushq  $0x0
  800420c096:	6a 00                	pushq  $0x0
  800420c098:	e9 78 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c09d:	90                   	nop

000000800420c09e <entry1>:
TRAPHANDLER_NOEC(entry1, 1)
  800420c09e:	6a 00                	pushq  $0x0
  800420c0a0:	6a 01                	pushq  $0x1
  800420c0a2:	e9 6e f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0a7:	90                   	nop

000000800420c0a8 <entry2>:
TRAPHANDLER_NOEC(entry2, 2)
  800420c0a8:	6a 00                	pushq  $0x0
  800420c0aa:	6a 02                	pushq  $0x2
  800420c0ac:	e9 64 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0b1:	90                   	nop

000000800420c0b2 <entry3>:
TRAPHANDLER_NOEC(entry3, 3)
  800420c0b2:	6a 00                	pushq  $0x0
  800420c0b4:	6a 03                	pushq  $0x3
  800420c0b6:	e9 5a f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0bb:	90                   	nop

000000800420c0bc <entry4>:
TRAPHANDLER_NOEC(entry4, 4)
  800420c0bc:	6a 00                	pushq  $0x0
  800420c0be:	6a 04                	pushq  $0x4
  800420c0c0:	e9 50 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0c5:	90                   	nop

000000800420c0c6 <entry5>:
TRAPHANDLER_NOEC(entry5, 5)
  800420c0c6:	6a 00                	pushq  $0x0
  800420c0c8:	6a 05                	pushq  $0x5
  800420c0ca:	e9 46 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0cf:	90                   	nop

000000800420c0d0 <entry6>:
TRAPHANDLER_NOEC(entry6, 6)
  800420c0d0:	6a 00                	pushq  $0x0
  800420c0d2:	6a 06                	pushq  $0x6
  800420c0d4:	e9 3c f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0d9:	90                   	nop

000000800420c0da <entry7>:
TRAPHANDLER_NOEC(entry7, 7)
  800420c0da:	6a 00                	pushq  $0x0
  800420c0dc:	6a 07                	pushq  $0x7
  800420c0de:	e9 32 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0e3:	90                   	nop

000000800420c0e4 <entry8>:
TRAPHANDLER(entry8, 8)
  800420c0e4:	6a 08                	pushq  $0x8
  800420c0e6:	e9 2a f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0eb:	90                   	nop

000000800420c0ec <entry10>:
TRAPHANDLER_NULL()
TRAPHANDLER(entry10, 10)
  800420c0ec:	6a 0a                	pushq  $0xa
  800420c0ee:	e9 22 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0f3:	90                   	nop

000000800420c0f4 <entry11>:
TRAPHANDLER(entry11, 11)
  800420c0f4:	6a 0b                	pushq  $0xb
  800420c0f6:	e9 1a f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c0fb:	90                   	nop

000000800420c0fc <entry12>:
TRAPHANDLER(entry12, 12)
  800420c0fc:	6a 0c                	pushq  $0xc
  800420c0fe:	e9 12 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c103:	90                   	nop

000000800420c104 <entry13>:
TRAPHANDLER(entry13, 13)
  800420c104:	6a 0d                	pushq  $0xd
  800420c106:	e9 0a f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c10b:	90                   	nop

000000800420c10c <entry14>:
TRAPHANDLER(entry14, 14)
  800420c10c:	6a 0e                	pushq  $0xe
  800420c10e:	e9 02 f7 01 00       	jmpq   800422b815 <_alltraps>
  800420c113:	90                   	nop

000000800420c114 <entry16>:
TRAPHANDLER_NULL()
TRAPHANDLER_NOEC(entry16, 16)
  800420c114:	6a 00                	pushq  $0x0
  800420c116:	6a 10                	pushq  $0x10
  800420c118:	e9 f8 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c11d:	90                   	nop

000000800420c11e <entry17>:
TRAPHANDLER(entry17, 17)
  800420c11e:	6a 11                	pushq  $0x11
  800420c120:	e9 f0 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c125:	90                   	nop

000000800420c126 <entry18>:
TRAPHANDLER_NOEC(entry18, 18)
  800420c126:	6a 00                	pushq  $0x0
  800420c128:	6a 12                	pushq  $0x12
  800420c12a:	e9 e6 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c12f:	90                   	nop

000000800420c130 <entry19>:
TRAPHANDLER_NOEC(entry19, 19)
  800420c130:	6a 00                	pushq  $0x0
  800420c132:	6a 13                	pushq  $0x13
  800420c134:	e9 dc f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c139:	90                   	nop

000000800420c13a <routine_mchk>:
TRAPHANDLER_NOEC48(entry48, 48)

/*lab4 partc*/
TRAPHANDLER_NOEC(routine_mchk, T_MCHK)
  800420c13a:	6a 00                	pushq  $0x0
  800420c13c:	6a 12                	pushq  $0x12
  800420c13e:	e9 d2 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c143:	90                   	nop

000000800420c144 <routine_simderr>:
TRAPHANDLER_NOEC(routine_simderr, T_SIMDERR)
  800420c144:	6a 00                	pushq  $0x0
  800420c146:	6a 13                	pushq  $0x13
  800420c148:	e9 c8 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c14d:	90                   	nop

000000800420c14e <routine_syscall>:
TRAPHANDLER_NOEC(routine_syscall, T_SYSCALL)
  800420c14e:	6a 00                	pushq  $0x0
  800420c150:	6a 30                	pushq  $0x30
  800420c152:	e9 be f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c157:	90                   	nop

000000800420c158 <entry32>:

TRAPHANDLER_NOEC(entry32, IRQ_OFFSET + 0);
  800420c158:	6a 00                	pushq  $0x0
  800420c15a:	6a 20                	pushq  $0x20
  800420c15c:	e9 b4 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c161:	90                   	nop

000000800420c162 <entry33>:
TRAPHANDLER_NOEC(entry33, IRQ_OFFSET + 1);
  800420c162:	6a 00                	pushq  $0x0
  800420c164:	6a 21                	pushq  $0x21
  800420c166:	e9 aa f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c16b:	90                   	nop

000000800420c16c <entry34>:
TRAPHANDLER_NOEC(entry34, IRQ_OFFSET + 2);
  800420c16c:	6a 00                	pushq  $0x0
  800420c16e:	6a 22                	pushq  $0x22
  800420c170:	e9 a0 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c175:	90                   	nop

000000800420c176 <entry35>:
TRAPHANDLER_NOEC(entry35, IRQ_OFFSET + 3);
  800420c176:	6a 00                	pushq  $0x0
  800420c178:	6a 23                	pushq  $0x23
  800420c17a:	e9 96 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c17f:	90                   	nop

000000800420c180 <entry36>:
TRAPHANDLER_NOEC(entry36, IRQ_OFFSET + 4);
  800420c180:	6a 00                	pushq  $0x0
  800420c182:	6a 24                	pushq  $0x24
  800420c184:	e9 8c f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c189:	90                   	nop

000000800420c18a <entry37>:
TRAPHANDLER_NOEC(entry37, IRQ_OFFSET + 5);
  800420c18a:	6a 00                	pushq  $0x0
  800420c18c:	6a 25                	pushq  $0x25
  800420c18e:	e9 82 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c193:	90                   	nop

000000800420c194 <entry38>:
TRAPHANDLER_NOEC(entry38, IRQ_OFFSET + 6);
  800420c194:	6a 00                	pushq  $0x0
  800420c196:	6a 26                	pushq  $0x26
  800420c198:	e9 78 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c19d:	90                   	nop

000000800420c19e <entry39>:
TRAPHANDLER_NOEC(entry39, IRQ_OFFSET + 7);
  800420c19e:	6a 00                	pushq  $0x0
  800420c1a0:	6a 27                	pushq  $0x27
  800420c1a2:	e9 6e f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1a7:	90                   	nop

000000800420c1a8 <entry40>:
TRAPHANDLER_NOEC(entry40, IRQ_OFFSET + 8);
  800420c1a8:	6a 00                	pushq  $0x0
  800420c1aa:	6a 28                	pushq  $0x28
  800420c1ac:	e9 64 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1b1:	90                   	nop

000000800420c1b2 <entry41>:
TRAPHANDLER_NOEC(entry41, IRQ_OFFSET + 9);
  800420c1b2:	6a 00                	pushq  $0x0
  800420c1b4:	6a 29                	pushq  $0x29
  800420c1b6:	e9 5a f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1bb:	90                   	nop

000000800420c1bc <entry42>:
TRAPHANDLER_NOEC(entry42, IRQ_OFFSET + 10);
  800420c1bc:	6a 00                	pushq  $0x0
  800420c1be:	6a 2a                	pushq  $0x2a
  800420c1c0:	e9 50 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1c5:	90                   	nop

000000800420c1c6 <entry43>:
TRAPHANDLER_NOEC(entry43, IRQ_OFFSET + 11);
  800420c1c6:	6a 00                	pushq  $0x0
  800420c1c8:	6a 2b                	pushq  $0x2b
  800420c1ca:	e9 46 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1cf:	90                   	nop

000000800420c1d0 <entry44>:
TRAPHANDLER_NOEC(entry44, IRQ_OFFSET + 12);
  800420c1d0:	6a 00                	pushq  $0x0
  800420c1d2:	6a 2c                	pushq  $0x2c
  800420c1d4:	e9 3c f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1d9:	90                   	nop

000000800420c1da <entry45>:
TRAPHANDLER_NOEC(entry45, IRQ_OFFSET + 13);
  800420c1da:	6a 00                	pushq  $0x0
  800420c1dc:	6a 2d                	pushq  $0x2d
  800420c1de:	e9 32 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1e3:	90                   	nop

000000800420c1e4 <entry46>:
TRAPHANDLER_NOEC(entry46, IRQ_OFFSET + 14);
  800420c1e4:	6a 00                	pushq  $0x0
  800420c1e6:	6a 2e                	pushq  $0x2e
  800420c1e8:	e9 28 f6 01 00       	jmpq   800422b815 <_alltraps>
  800420c1ed:	90                   	nop

000000800420c1ee <entry47>:
TRAPHANDLER_NOEC(entry47, IRQ_OFFSET + 15);
  800420c1ee:	6a 00                	pushq  $0x0
  800420c1f0:	6a 2f                	pushq  $0x2f
  800420c1f2:	e9 1e f6 01 00       	jmpq   800422b815 <_alltraps>

000000800420c1f7 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420c1f7:	55                   	push   %rbp
  800420c1f8:	48 89 e5             	mov    %rsp,%rbp
  800420c1fb:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420c1ff:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c203:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420c206:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c20a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c20d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420c211:	f0 87 02             	lock xchg %eax,(%rdx)
  800420c214:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420c217:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c21a:	c9                   	leaveq 
  800420c21b:	c3                   	retq   

000000800420c21c <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420c21c:	55                   	push   %rbp
  800420c21d:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420c220:	48 bf 60 b9 22 04 80 	movabs $0x800422b960,%rdi
  800420c227:	00 00 00 
  800420c22a:	48 b8 bc 62 21 04 80 	movabs $0x80042162bc,%rax
  800420c231:	00 00 00 
  800420c234:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420c236:	f3 90                	pause  
}
  800420c238:	5d                   	pop    %rbp
  800420c239:	c3                   	retq   

000000800420c23a <sched_yield>:
#endif

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420c23a:	55                   	push   %rbp
  800420c23b:	48 89 e5             	mov    %rsp,%rbp
  800420c23e:	48 83 ec 10          	sub    $0x10,%rsp
 //      if (curenv && curenv->env_status == ENV_RUNNING) {
 //       env_run(curenv);
 //    }


	int i=curenv?ENVX(thiscpu->cpu_env->env_id):0;
  800420c242:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c249:	00 00 00 
  800420c24c:	ff d0                	callq  *%rax
  800420c24e:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c255:	00 00 00 
  800420c258:	48 98                	cltq   
  800420c25a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c25e:	48 89 c1             	mov    %rax,%rcx
  800420c261:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c265:	48 01 c8             	add    %rcx,%rax
  800420c268:	48 01 d0             	add    %rdx,%rax
  800420c26b:	48 83 c0 08          	add    $0x8,%rax
  800420c26f:	48 8b 00             	mov    (%rax),%rax
  800420c272:	48 85 c0             	test   %rax,%rax
  800420c275:	74 3d                	je     800420c2b4 <sched_yield+0x7a>
  800420c277:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c27e:	00 00 00 
  800420c281:	ff d0                	callq  *%rax
  800420c283:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c28a:	00 00 00 
  800420c28d:	48 98                	cltq   
  800420c28f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c293:	48 89 c1             	mov    %rax,%rcx
  800420c296:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c29a:	48 01 c8             	add    %rcx,%rax
  800420c29d:	48 01 d0             	add    %rdx,%rax
  800420c2a0:	48 83 c0 08          	add    $0x8,%rax
  800420c2a4:	48 8b 00             	mov    (%rax),%rax
  800420c2a7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c2ad:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c2b2:	eb 05                	jmp    800420c2b9 <sched_yield+0x7f>
  800420c2b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2b9:	89 45 fc             	mov    %eax,-0x4(%rbp)
	int j=i;
  800420c2bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2bf:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (true) {
		if(envs[i].env_status == ENV_RUNNABLE)  
  800420c2c2:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420c2c9:	00 00 00 
  800420c2cc:	48 8b 10             	mov    (%rax),%rdx
  800420c2cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2d2:	48 98                	cltq   
  800420c2d4:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420c2db:	48 01 d0             	add    %rdx,%rax
  800420c2de:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c2e4:	83 f8 02             	cmp    $0x2,%eax
  800420c2e7:	75 2b                	jne    800420c314 <sched_yield+0xda>
		{  
			env_run(&envs[i]);  
  800420c2e9:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420c2f0:	00 00 00 
  800420c2f3:	48 8b 10             	mov    (%rax),%rdx
  800420c2f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c2f9:	48 98                	cltq   
  800420c2fb:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420c302:	48 01 d0             	add    %rdx,%rax
  800420c305:	48 89 c7             	mov    %rax,%rdi
  800420c308:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  800420c30f:	00 00 00 
  800420c312:	ff d0                	callq  *%rax
			return;  
		}
		i=(i+1)%NENV;
  800420c314:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c317:	8d 50 01             	lea    0x1(%rax),%edx
  800420c31a:	89 d0                	mov    %edx,%eax
  800420c31c:	c1 f8 1f             	sar    $0x1f,%eax
  800420c31f:	c1 e8 16             	shr    $0x16,%eax
  800420c322:	01 c2                	add    %eax,%edx
  800420c324:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420c32a:	29 c2                	sub    %eax,%edx
  800420c32c:	89 d0                	mov    %edx,%eax
  800420c32e:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (i==j)
  800420c331:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c334:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800420c337:	75 3e                	jne    800420c377 <sched_yield+0x13d>
			break;
  800420c339:	90                   	nop
	}
	if (thiscpu->cpu_env->env_status==ENV_RUNNING)
  800420c33a:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c341:	00 00 00 
  800420c344:	ff d0                	callq  *%rax
  800420c346:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c34d:	00 00 00 
  800420c350:	48 98                	cltq   
  800420c352:	48 c1 e0 03          	shl    $0x3,%rax
  800420c356:	48 89 c1             	mov    %rax,%rcx
  800420c359:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c35d:	48 01 c8             	add    %rcx,%rax
  800420c360:	48 01 d0             	add    %rdx,%rax
  800420c363:	48 83 c0 08          	add    $0x8,%rax
  800420c367:	48 8b 00             	mov    (%rax),%rax
  800420c36a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c370:	83 f8 03             	cmp    $0x3,%eax
  800420c373:	75 46                	jne    800420c3bb <sched_yield+0x181>
  800420c375:	eb 05                	jmp    800420c37c <sched_yield+0x142>
			return;  
		}
		i=(i+1)%NENV;
		if (i==j)
			break;
	}
  800420c377:	e9 46 ff ff ff       	jmpq   800420c2c2 <sched_yield+0x88>
	if (thiscpu->cpu_env->env_status==ENV_RUNNING)
	{
		env_run(thiscpu->cpu_env);
  800420c37c:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c383:	00 00 00 
  800420c386:	ff d0                	callq  *%rax
  800420c388:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c38f:	00 00 00 
  800420c392:	48 98                	cltq   
  800420c394:	48 c1 e0 03          	shl    $0x3,%rax
  800420c398:	48 89 c1             	mov    %rax,%rcx
  800420c39b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c39f:	48 01 c8             	add    %rcx,%rax
  800420c3a2:	48 01 d0             	add    %rdx,%rax
  800420c3a5:	48 83 c0 08          	add    $0x8,%rax
  800420c3a9:	48 8b 00             	mov    (%rax),%rax
  800420c3ac:	48 89 c7             	mov    %rax,%rdi
  800420c3af:	48 b8 13 92 20 04 80 	movabs $0x8004209213,%rax
  800420c3b6:	00 00 00 
  800420c3b9:	ff d0                	callq  *%rax
	}



	// sched_halt never returns
	sched_halt();
  800420c3bb:	48 b8 c9 c3 20 04 80 	movabs $0x800420c3c9,%rax
  800420c3c2:	00 00 00 
  800420c3c5:	ff d0                	callq  *%rax
}
  800420c3c7:	c9                   	leaveq 
  800420c3c8:	c3                   	retq   

000000800420c3c9 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420c3c9:	55                   	push   %rbp
  800420c3ca:	48 89 e5             	mov    %rsp,%rbp
  800420c3cd:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c3d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c3d8:	eb 79                	jmp    800420c453 <sched_halt+0x8a>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c3da:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420c3e1:	00 00 00 
  800420c3e4:	48 8b 10             	mov    (%rax),%rdx
  800420c3e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c3ea:	48 98                	cltq   
  800420c3ec:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420c3f3:	48 01 d0             	add    %rdx,%rax
  800420c3f6:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c3fc:	83 f8 02             	cmp    $0x2,%eax
  800420c3ff:	74 5f                	je     800420c460 <sched_halt+0x97>

			envs[i].env_status == ENV_RUNNING ||
  800420c401:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420c408:	00 00 00 
  800420c40b:	48 8b 10             	mov    (%rax),%rdx
  800420c40e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c411:	48 98                	cltq   
  800420c413:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420c41a:	48 01 d0             	add    %rdx,%rax
  800420c41d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c423:	83 f8 03             	cmp    $0x3,%eax
  800420c426:	74 38                	je     800420c460 <sched_halt+0x97>

			envs[i].env_status == ENV_RUNNING ||
			envs[i].env_status == ENV_DYING))
  800420c428:	48 b8 58 42 37 04 80 	movabs $0x8004374258,%rax
  800420c42f:	00 00 00 
  800420c432:	48 8b 10             	mov    (%rax),%rdx
  800420c435:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c438:	48 98                	cltq   
  800420c43a:	48 69 c0 70 01 00 00 	imul   $0x170,%rax,%rax
  800420c441:	48 01 d0             	add    %rdx,%rax
  800420c444:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||

			envs[i].env_status == ENV_RUNNING ||
  800420c44a:	83 f8 01             	cmp    $0x1,%eax
  800420c44d:	74 11                	je     800420c460 <sched_halt+0x97>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c44f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c453:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420c45a:	0f 8e 7a ff ff ff    	jle    800420c3da <sched_halt+0x11>
			envs[i].env_status == ENV_RUNNING ||
			envs[i].env_status == ENV_DYING))

			break;
	}
	if (i == NENV) {
  800420c460:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420c467:	75 2e                	jne    800420c497 <sched_halt+0xce>
		cprintf("No runnable environments in the system!\n");
  800420c469:	48 bf 80 8f 21 04 80 	movabs $0x8004218f80,%rdi
  800420c470:	00 00 00 
  800420c473:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c478:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420c47f:	00 00 00 
  800420c482:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420c484:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c489:	48 b8 e7 24 20 04 80 	movabs $0x80042024e7,%rax
  800420c490:	00 00 00 
  800420c493:	ff d0                	callq  *%rax
  800420c495:	eb ed                	jmp    800420c484 <sched_halt+0xbb>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420c497:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c49e:	00 00 00 
  800420c4a1:	ff d0                	callq  *%rax
  800420c4a3:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c4aa:	00 00 00 
  800420c4ad:	48 98                	cltq   
  800420c4af:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4b3:	48 89 c1             	mov    %rax,%rcx
  800420c4b6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c4ba:	48 01 c8             	add    %rcx,%rax
  800420c4bd:	48 01 d0             	add    %rdx,%rax
  800420c4c0:	48 83 c0 08          	add    $0x8,%rax
  800420c4c4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420c4cb:	48 b8 70 57 37 04 80 	movabs $0x8004375770,%rax
  800420c4d2:	00 00 00 
  800420c4d5:	48 8b 00             	mov    (%rax),%rax
  800420c4d8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c4dc:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420c4e3:	00 00 00 
  800420c4e6:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420c4ea:	77 32                	ja     800420c51e <sched_halt+0x155>
  800420c4ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c4f0:	48 89 c1             	mov    %rax,%rcx
  800420c4f3:	48 ba b0 8f 21 04 80 	movabs $0x8004218fb0,%rdx
  800420c4fa:	00 00 00 
  800420c4fd:	be 8a 00 00 00       	mov    $0x8a,%esi
  800420c502:	48 bf d4 8f 21 04 80 	movabs $0x8004218fd4,%rdi
  800420c509:	00 00 00 
  800420c50c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c511:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420c518:	00 00 00 
  800420c51b:	41 ff d0             	callq  *%r8
  800420c51e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420c525:	ff ff ff 
  800420c528:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c52c:	48 01 d0             	add    %rdx,%rax
  800420c52f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420c533:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c537:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420c53a:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c541:	00 00 00 
  800420c544:	ff d0                	callq  *%rax
  800420c546:	48 98                	cltq   
  800420c548:	48 c1 e0 03          	shl    $0x3,%rax
  800420c54c:	48 89 c2             	mov    %rax,%rdx
  800420c54f:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c553:	48 01 d0             	add    %rdx,%rax
  800420c556:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c55d:	00 00 00 
  800420c560:	48 01 d0             	add    %rdx,%rax
  800420c563:	48 83 c0 04          	add    $0x4,%rax
  800420c567:	be 02 00 00 00       	mov    $0x2,%esi
  800420c56c:	48 89 c7             	mov    %rax,%rdi
  800420c56f:	48 b8 f7 c1 20 04 80 	movabs $0x800420c1f7,%rax
  800420c576:	00 00 00 
  800420c579:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420c57b:	48 b8 1c c2 20 04 80 	movabs $0x800420c21c,%rax
  800420c582:	00 00 00 
  800420c585:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420c587:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c58e:	00 00 00 
  800420c591:	ff d0                	callq  *%rax
  800420c593:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c59a:	00 00 00 
  800420c59d:	48 98                	cltq   
  800420c59f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5a3:	48 89 c1             	mov    %rax,%rcx
  800420c5a6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c5aa:	48 01 c8             	add    %rcx,%rax
  800420c5ad:	48 01 d0             	add    %rdx,%rax
  800420c5b0:	48 83 c0 10          	add    $0x10,%rax
  800420c5b4:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420c5b8:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420c5bf:	48 89 c4             	mov    %rax,%rsp
  800420c5c2:	6a 00                	pushq  $0x0
  800420c5c4:	6a 00                	pushq  $0x0
  800420c5c6:	fb                   	sti    
  800420c5c7:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420c5c8:	c9                   	leaveq 
  800420c5c9:	c3                   	retq   

000000800420c5ca <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420c5ca:	55                   	push   %rbp
  800420c5cb:	48 89 e5             	mov    %rsp,%rbp
  800420c5ce:	48 83 ec 10          	sub    $0x10,%rsp
  800420c5d2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c5d6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

// Check that the user has permission to read memory [s, s+len).
// Destroy the environment if not.

// LAB 3: Your code here.
	user_mem_assert (curenv, s, len, PTE_U);
  800420c5da:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c5e1:	00 00 00 
  800420c5e4:	ff d0                	callq  *%rax
  800420c5e6:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c5ed:	00 00 00 
  800420c5f0:	48 98                	cltq   
  800420c5f2:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5f6:	48 89 c1             	mov    %rax,%rcx
  800420c5f9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c5fd:	48 01 c8             	add    %rcx,%rax
  800420c600:	48 01 d0             	add    %rdx,%rax
  800420c603:	48 83 c0 08          	add    $0x8,%rax
  800420c607:	48 8b 00             	mov    (%rax),%rax
  800420c60a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c60e:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420c612:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420c617:	48 89 c7             	mov    %rax,%rdi
  800420c61a:	48 b8 c5 47 20 04 80 	movabs $0x80042047c5,%rax
  800420c621:	00 00 00 
  800420c624:	ff d0                	callq  *%rax
// Print the string supplied by the user.

	cprintf("%.*s", len, s);
  800420c626:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c62a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c62e:	48 89 c6             	mov    %rax,%rsi
  800420c631:	48 bf e8 8f 21 04 80 	movabs $0x8004218fe8,%rdi
  800420c638:	00 00 00 
  800420c63b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c640:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800420c647:	00 00 00 
  800420c64a:	ff d1                	callq  *%rcx
}
  800420c64c:	c9                   	leaveq 
  800420c64d:	c3                   	retq   

000000800420c64e <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420c64e:	55                   	push   %rbp
  800420c64f:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420c652:	48 b8 13 12 20 04 80 	movabs $0x8004201213,%rax
  800420c659:	00 00 00 
  800420c65c:	ff d0                	callq  *%rax
}
  800420c65e:	5d                   	pop    %rbp
  800420c65f:	c3                   	retq   

000000800420c660 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420c660:	55                   	push   %rbp
  800420c661:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420c664:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c66b:	00 00 00 
  800420c66e:	ff d0                	callq  *%rax
  800420c670:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c677:	00 00 00 
  800420c67a:	48 98                	cltq   
  800420c67c:	48 c1 e0 03          	shl    $0x3,%rax
  800420c680:	48 89 c1             	mov    %rax,%rcx
  800420c683:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c687:	48 01 c8             	add    %rcx,%rax
  800420c68a:	48 01 d0             	add    %rdx,%rax
  800420c68d:	48 83 c0 08          	add    $0x8,%rax
  800420c691:	48 8b 00             	mov    (%rax),%rax
  800420c694:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420c69a:	5d                   	pop    %rbp
  800420c69b:	c3                   	retq   

000000800420c69c <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420c69c:	55                   	push   %rbp
  800420c69d:	48 89 e5             	mov    %rsp,%rbp
  800420c6a0:	48 83 ec 20          	sub    $0x20,%rsp
  800420c6a4:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420c6a7:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c6ab:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c6ae:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c6b3:	48 89 ce             	mov    %rcx,%rsi
  800420c6b6:	89 c7                	mov    %eax,%edi
  800420c6b8:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420c6bf:	00 00 00 
  800420c6c2:	ff d0                	callq  *%rax
  800420c6c4:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c6c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c6cb:	79 05                	jns    800420c6d2 <sys_env_destroy+0x36>
		return r;
  800420c6cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c6d0:	eb 18                	jmp    800420c6ea <sys_env_destroy+0x4e>
	// if (e == curenv)
	// 	cprintf("[%08x] exiting gracefully\n", curenv->env_id);
	// else
	// 	cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);

	env_destroy(e);
  800420c6d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c6d6:	48 89 c7             	mov    %rax,%rdi
  800420c6d9:	48 b8 48 90 20 04 80 	movabs $0x8004209048,%rax
  800420c6e0:	00 00 00 
  800420c6e3:	ff d0                	callq  *%rax
	return 0;
  800420c6e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c6ea:	c9                   	leaveq 
  800420c6eb:	c3                   	retq   

000000800420c6ec <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c6ec:	55                   	push   %rbp
  800420c6ed:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c6f0:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  800420c6f7:	00 00 00 
  800420c6fa:	ff d0                	callq  *%rax

000000800420c6fc <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c6fc:	55                   	push   %rbp
  800420c6fd:	48 89 e5             	mov    %rsp,%rbp
  800420c700:	53                   	push   %rbx
  800420c701:	48 83 ec 18          	sub    $0x18,%rsp
// will appear to return 0.

// LAB 4: Your code here.
	struct Env* env;
	int r;
	if ((r=env_alloc(&env,curenv->env_id))<0)
  800420c705:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c70c:	00 00 00 
  800420c70f:	ff d0                	callq  *%rax
  800420c711:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c718:	00 00 00 
  800420c71b:	48 98                	cltq   
  800420c71d:	48 c1 e0 03          	shl    $0x3,%rax
  800420c721:	48 89 c1             	mov    %rax,%rcx
  800420c724:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c728:	48 01 c8             	add    %rcx,%rax
  800420c72b:	48 01 d0             	add    %rdx,%rax
  800420c72e:	48 83 c0 08          	add    $0x8,%rax
  800420c732:	48 8b 00             	mov    (%rax),%rax
  800420c735:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c73b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c73f:	89 d6                	mov    %edx,%esi
  800420c741:	48 89 c7             	mov    %rax,%rdi
  800420c744:	48 b8 a6 86 20 04 80 	movabs $0x80042086a6,%rax
  800420c74b:	00 00 00 
  800420c74e:	ff d0                	callq  *%rax
  800420c750:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c753:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c757:	79 05                	jns    800420c75e <sys_exofork+0x62>
		return r;
  800420c759:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c75c:	eb 6c                	jmp    800420c7ca <sys_exofork+0xce>
	env->env_status=ENV_NOT_RUNNABLE;
  800420c75e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c762:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c769:	00 00 00 
	env->env_tf=curenv->env_tf;
  800420c76c:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c770:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420c777:	00 00 00 
  800420c77a:	ff d0                	callq  *%rax
  800420c77c:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420c783:	00 00 00 
  800420c786:	48 98                	cltq   
  800420c788:	48 c1 e0 03          	shl    $0x3,%rax
  800420c78c:	48 89 c1             	mov    %rax,%rcx
  800420c78f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c793:	48 01 c8             	add    %rcx,%rax
  800420c796:	48 01 d0             	add    %rdx,%rax
  800420c799:	48 83 c0 08          	add    $0x8,%rax
  800420c79d:	48 8b 00             	mov    (%rax),%rax
  800420c7a0:	48 89 da             	mov    %rbx,%rdx
  800420c7a3:	48 89 c6             	mov    %rax,%rsi
  800420c7a6:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c7ab:	48 89 d7             	mov    %rdx,%rdi
  800420c7ae:	48 89 c1             	mov    %rax,%rcx
  800420c7b1:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	env->env_tf.tf_regs.reg_rax=0;
  800420c7b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7b8:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c7bf:	00 
	return env->env_id;
  800420c7c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7c4:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	panic("sys_exofork not implemented");
}
  800420c7ca:	48 83 c4 18          	add    $0x18,%rsp
  800420c7ce:	5b                   	pop    %rbx
  800420c7cf:	5d                   	pop    %rbp
  800420c7d0:	c3                   	retq   

000000800420c7d1 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420c7d1:	55                   	push   %rbp
  800420c7d2:	48 89 e5             	mov    %rsp,%rbp
  800420c7d5:	48 83 ec 20          	sub    $0x20,%rsp
  800420c7d9:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c7dc:	89 75 e8             	mov    %esi,-0x18(%rbp)
// envid's status.

// LAB 4: Your code here.
	struct Env *env;
	int r;
	if (!(status==ENV_RUNNABLE || status==ENV_NOT_RUNNABLE))
  800420c7df:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420c7e3:	74 0d                	je     800420c7f2 <sys_env_set_status+0x21>
  800420c7e5:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420c7e9:	74 07                	je     800420c7f2 <sys_env_set_status+0x21>
		return -E_INVAL;
  800420c7eb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c7f0:	eb 3d                	jmp    800420c82f <sys_env_set_status+0x5e>
	if ((r=envid2env(envid,&env,1))<0){
  800420c7f2:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c7f6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c7f9:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c7fe:	48 89 ce             	mov    %rcx,%rsi
  800420c801:	89 c7                	mov    %eax,%edi
  800420c803:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420c80a:	00 00 00 
  800420c80d:	ff d0                	callq  *%rax
  800420c80f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c812:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c816:	79 05                	jns    800420c81d <sys_env_set_status+0x4c>
		return r;
  800420c818:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c81b:	eb 12                	jmp    800420c82f <sys_env_set_status+0x5e>
	}
	env->env_status=status;
  800420c81d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c821:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420c824:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420c82a:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("sys_env_set_status not implemented");
}
  800420c82f:	c9                   	leaveq 
  800420c830:	c3                   	retq   

000000800420c831 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420c831:	55                   	push   %rbp
  800420c832:	48 89 e5             	mov    %rsp,%rbp
  800420c835:	48 83 ec 20          	sub    $0x20,%rsp
  800420c839:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c83c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

// LAB 4: Your code here.
	struct Env *env;
	int r;
	if ((r=envid2env(envid,&env,1))<0){
  800420c840:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c844:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c847:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c84c:	48 89 ce             	mov    %rcx,%rsi
  800420c84f:	89 c7                	mov    %eax,%edi
  800420c851:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420c858:	00 00 00 
  800420c85b:	ff d0                	callq  *%rax
  800420c85d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c860:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c864:	79 05                	jns    800420c86b <sys_env_set_pgfault_upcall+0x3a>
		return r;
  800420c866:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c869:	eb 14                	jmp    800420c87f <sys_env_set_pgfault_upcall+0x4e>
	}
	env->env_pgfault_upcall=func;
  800420c86b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c86f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c873:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420c87a:	b8 00 00 00 00       	mov    $0x0,%eax

	panic("sys_env_set_pgfault_upcall not implemented");
}
  800420c87f:	c9                   	leaveq 
  800420c880:	c3                   	retq   

000000800420c881 <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420c881:	55                   	push   %rbp
  800420c882:	48 89 e5             	mov    %rsp,%rbp
  800420c885:	48 83 ec 40          	sub    $0x40,%rsp
  800420c889:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420c88c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420c890:	89 55 c8             	mov    %edx,-0x38(%rbp)
//   parameters for correctness.
//   If page_insert() fails, remember to free the page you
//   allocated!

// LAB 4: Your code here.
	if (!(perm&PTE_U) || !(perm&PTE_P))
  800420c893:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420c896:	83 e0 04             	and    $0x4,%eax
  800420c899:	85 c0                	test   %eax,%eax
  800420c89b:	74 0a                	je     800420c8a7 <sys_page_alloc+0x26>
  800420c89d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420c8a0:	83 e0 01             	and    $0x1,%eax
  800420c8a3:	85 c0                	test   %eax,%eax
  800420c8a5:	75 0a                	jne    800420c8b1 <sys_page_alloc+0x30>
		return -E_INVAL;
  800420c8a7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c8ac:	e9 04 01 00 00       	jmpq   800420c9b5 <sys_page_alloc+0x134>
	if (perm&(~PTE_SYSCALL))
  800420c8b1:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420c8b4:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c8b9:	85 c0                	test   %eax,%eax
  800420c8bb:	74 0a                	je     800420c8c7 <sys_page_alloc+0x46>
		return -E_INVAL;
  800420c8bd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c8c2:	e9 ee 00 00 00       	jmpq   800420c9b5 <sys_page_alloc+0x134>
	if ((uint64_t)va>UTOP || va!=ROUNDUP(va,PGSIZE))
  800420c8c7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420c8cb:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420c8d2:	00 00 00 
  800420c8d5:	48 39 c2             	cmp    %rax,%rdx
  800420c8d8:	77 3b                	ja     800420c915 <sys_page_alloc+0x94>
  800420c8da:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  800420c8e1:	00 
  800420c8e2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420c8e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c8ea:	48 01 d0             	add    %rdx,%rax
  800420c8ed:	48 83 e8 01          	sub    $0x1,%rax
  800420c8f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c8f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c8f9:	ba 00 00 00 00       	mov    $0x0,%edx
  800420c8fe:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420c902:	48 89 d0             	mov    %rdx,%rax
  800420c905:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c909:	48 29 c2             	sub    %rax,%rdx
  800420c90c:	48 89 d0             	mov    %rdx,%rax
  800420c90f:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420c913:	74 0a                	je     800420c91f <sys_page_alloc+0x9e>
		return -E_INVAL;
  800420c915:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c91a:	e9 96 00 00 00       	jmpq   800420c9b5 <sys_page_alloc+0x134>
	struct Env *env;
	int r;
	if ((r=envid2env(envid,&env,1))<0){
  800420c91f:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420c923:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420c926:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c92b:	48 89 ce             	mov    %rcx,%rsi
  800420c92e:	89 c7                	mov    %eax,%edi
  800420c930:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420c937:	00 00 00 
  800420c93a:	ff d0                	callq  *%rax
  800420c93c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c93f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c943:	79 05                	jns    800420c94a <sys_page_alloc+0xc9>
		return r;
  800420c945:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c948:	eb 6b                	jmp    800420c9b5 <sys_page_alloc+0x134>
	}
	struct PageInfo *newPage;
	if ((newPage=page_alloc(ALLOC_ZERO))==NULL)
  800420c94a:	bf 01 00 00 00       	mov    $0x1,%edi
  800420c94f:	48 b8 ff 3a 20 04 80 	movabs $0x8004203aff,%rax
  800420c956:	00 00 00 
  800420c959:	ff d0                	callq  *%rax
  800420c95b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420c95f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420c964:	75 07                	jne    800420c96d <sys_page_alloc+0xec>
		return -E_NO_MEM;
  800420c966:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c96b:	eb 48                	jmp    800420c9b5 <sys_page_alloc+0x134>
	if (page_insert(env->env_pml4e, newPage, va, perm) < 0) {
  800420c96d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c971:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c978:	8b 4d c8             	mov    -0x38(%rbp),%ecx
  800420c97b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420c97f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420c983:	48 89 c7             	mov    %rax,%rdi
  800420c986:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  800420c98d:	00 00 00 
  800420c990:	ff d0                	callq  *%rax
  800420c992:	85 c0                	test   %eax,%eax
  800420c994:	79 1a                	jns    800420c9b0 <sys_page_alloc+0x12f>
		page_free(newPage);
  800420c996:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c99a:	48 89 c7             	mov    %rax,%rdi
  800420c99d:	48 b8 c3 3b 20 04 80 	movabs $0x8004203bc3,%rax
  800420c9a4:	00 00 00 
  800420c9a7:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  800420c9a9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c9ae:	eb 05                	jmp    800420c9b5 <sys_page_alloc+0x134>
	}
	return 0;
  800420c9b0:	b8 00 00 00 00       	mov    $0x0,%eax

	panic("sys_page_alloc not implemented");
}
  800420c9b5:	c9                   	leaveq 
  800420c9b6:	c3                   	retq   

000000800420c9b7 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	envid_t dstenvid, void *dstva, int perm)
{
  800420c9b7:	55                   	push   %rbp
  800420c9b8:	48 89 e5             	mov    %rsp,%rbp
  800420c9bb:	48 83 ec 40          	sub    $0x40,%rsp
  800420c9bf:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c9c2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c9c6:	89 55 d8             	mov    %edx,-0x28(%rbp)
  800420c9c9:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800420c9cd:	44 89 45 c4          	mov    %r8d,-0x3c(%rbp)
//   parameters for correctness.
//   Use the third argument to page_lookup() to
//   check the current permissions on the page.

// LAB 4: Your code here.
	if((uintptr_t)srcva >= UTOP || ((uintptr_t)srcva)%PGSIZE!=0 || (uintptr_t)dstva >= UTOP || ((uintptr_t)dstva)%PGSIZE!=0)
  800420c9d1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c9d5:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c9dc:	00 00 00 
  800420c9df:	48 39 c2             	cmp    %rax,%rdx
  800420c9e2:	77 2f                	ja     800420ca13 <sys_page_map+0x5c>
  800420c9e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c9e8:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c9ed:	48 85 c0             	test   %rax,%rax
  800420c9f0:	75 21                	jne    800420ca13 <sys_page_map+0x5c>
  800420c9f2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420c9f6:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c9fd:	00 00 00 
  800420ca00:	48 39 c2             	cmp    %rax,%rdx
  800420ca03:	77 0e                	ja     800420ca13 <sys_page_map+0x5c>
  800420ca05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca09:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ca0e:	48 85 c0             	test   %rax,%rax
  800420ca11:	74 0a                	je     800420ca1d <sys_page_map+0x66>
		return -E_INVAL;
  800420ca13:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ca18:	e9 08 01 00 00       	jmpq   800420cb25 <sys_page_map+0x16e>


	if(!(perm & PTE_P) || !(perm & PTE_U))
  800420ca1d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420ca20:	83 e0 01             	and    $0x1,%eax
  800420ca23:	85 c0                	test   %eax,%eax
  800420ca25:	74 0a                	je     800420ca31 <sys_page_map+0x7a>
  800420ca27:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420ca2a:	83 e0 04             	and    $0x4,%eax
  800420ca2d:	85 c0                	test   %eax,%eax
  800420ca2f:	75 0a                	jne    800420ca3b <sys_page_map+0x84>
		return -E_INVAL;
  800420ca31:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ca36:	e9 ea 00 00 00       	jmpq   800420cb25 <sys_page_map+0x16e>

	struct Env *env_src, *env_dst;

	if(envid2env(srcenvid, &env_src, 0) < 0)
  800420ca3b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420ca3f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ca42:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ca47:	48 89 ce             	mov    %rcx,%rsi
  800420ca4a:	89 c7                	mov    %eax,%edi
  800420ca4c:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420ca53:	00 00 00 
  800420ca56:	ff d0                	callq  *%rax
  800420ca58:	85 c0                	test   %eax,%eax
  800420ca5a:	79 0a                	jns    800420ca66 <sys_page_map+0xaf>
		return -E_BAD_ENV;
  800420ca5c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420ca61:	e9 bf 00 00 00       	jmpq   800420cb25 <sys_page_map+0x16e>

	if(envid2env(dstenvid, &env_dst, 0) < 0)
  800420ca66:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420ca6a:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420ca6d:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ca72:	48 89 ce             	mov    %rcx,%rsi
  800420ca75:	89 c7                	mov    %eax,%edi
  800420ca77:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420ca7e:	00 00 00 
  800420ca81:	ff d0                	callq  *%rax
  800420ca83:	85 c0                	test   %eax,%eax
  800420ca85:	79 0a                	jns    800420ca91 <sys_page_map+0xda>
		return -E_BAD_ENV;
  800420ca87:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420ca8c:	e9 94 00 00 00       	jmpq   800420cb25 <sys_page_map+0x16e>

	struct PageInfo *p = NULL;
  800420ca91:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ca98:	00 
	pte_t *pte;	
	p = page_lookup(env_src->env_pml4e, (void *)srcva, &pte);
  800420ca99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca9d:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420caa4:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  800420caa8:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420caac:	48 89 ce             	mov    %rcx,%rsi
  800420caaf:	48 89 c7             	mov    %rax,%rdi
  800420cab2:	48 b8 b5 43 20 04 80 	movabs $0x80042043b5,%rax
  800420cab9:	00 00 00 
  800420cabc:	ff d0                	callq  *%rax
  800420cabe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(p == NULL)
  800420cac2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420cac7:	75 07                	jne    800420cad0 <sys_page_map+0x119>
		return -E_NO_MEM;
  800420cac9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420cace:	eb 55                	jmp    800420cb25 <sys_page_map+0x16e>

	if((perm & PTE_W) && (!((*pte) & PTE_W)))
  800420cad0:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420cad3:	83 e0 02             	and    $0x2,%eax
  800420cad6:	85 c0                	test   %eax,%eax
  800420cad8:	74 16                	je     800420caf0 <sys_page_map+0x139>
  800420cada:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cade:	48 8b 00             	mov    (%rax),%rax
  800420cae1:	83 e0 02             	and    $0x2,%eax
  800420cae4:	48 85 c0             	test   %rax,%rax
  800420cae7:	75 07                	jne    800420caf0 <sys_page_map+0x139>
	{
		return -E_INVAL;
  800420cae9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420caee:	eb 35                	jmp    800420cb25 <sys_page_map+0x16e>
	}

	if(page_insert(env_dst->env_pml4e, p, dstva,perm) < 0)
  800420caf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420caf4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cafb:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
  800420cafe:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420cb02:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420cb06:	48 89 c7             	mov    %rax,%rdi
  800420cb09:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  800420cb10:	00 00 00 
  800420cb13:	ff d0                	callq  *%rax
  800420cb15:	85 c0                	test   %eax,%eax
  800420cb17:	79 07                	jns    800420cb20 <sys_page_map+0x169>
		return -E_NO_MEM;
  800420cb19:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420cb1e:	eb 05                	jmp    800420cb25 <sys_page_map+0x16e>
	return 0;
  800420cb20:	b8 00 00 00 00       	mov    $0x0,%eax

	panic("sys_page_map not implemented");
}
  800420cb25:	c9                   	leaveq 
  800420cb26:	c3                   	retq   

000000800420cb27 <sys_page_unmap>:

//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420cb27:	55                   	push   %rbp
  800420cb28:	48 89 e5             	mov    %rsp,%rbp
  800420cb2b:	48 83 ec 30          	sub    $0x30,%rsp
  800420cb2f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420cb32:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
// Hint: This function is a wrapper around page_remove().

// LAB 4: Your code here.
	struct Env *env;
	int r;
	if ((r=envid2env(envid,&env,1))<0){
  800420cb36:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420cb3a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cb3d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cb42:	48 89 ce             	mov    %rcx,%rsi
  800420cb45:	89 c7                	mov    %eax,%edi
  800420cb47:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420cb4e:	00 00 00 
  800420cb51:	ff d0                	callq  *%rax
  800420cb53:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420cb56:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cb5a:	79 05                	jns    800420cb61 <sys_page_unmap+0x3a>
		return r;
  800420cb5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420cb5f:	eb 7b                	jmp    800420cbdc <sys_page_unmap+0xb5>
	}
	if ((uint64_t)va>UTOP || va!=ROUNDUP(va,PGSIZE))
  800420cb61:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cb65:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420cb6c:	00 00 00 
  800420cb6f:	48 39 c2             	cmp    %rax,%rdx
  800420cb72:	77 3b                	ja     800420cbaf <sys_page_unmap+0x88>
  800420cb74:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  800420cb7b:	00 
  800420cb7c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cb80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb84:	48 01 d0             	add    %rdx,%rax
  800420cb87:	48 83 e8 01          	sub    $0x1,%rax
  800420cb8b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cb8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb93:	ba 00 00 00 00       	mov    $0x0,%edx
  800420cb98:	48 f7 75 f0          	divq   -0x10(%rbp)
  800420cb9c:	48 89 d0             	mov    %rdx,%rax
  800420cb9f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cba3:	48 29 c2             	sub    %rax,%rdx
  800420cba6:	48 89 d0             	mov    %rdx,%rax
  800420cba9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420cbad:	74 07                	je     800420cbb6 <sys_page_unmap+0x8f>
		return -E_INVAL;
  800420cbaf:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cbb4:	eb 26                	jmp    800420cbdc <sys_page_unmap+0xb5>
	page_remove(env->env_pml4e,va);
  800420cbb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cbba:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cbc1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cbc5:	48 89 d6             	mov    %rdx,%rsi
  800420cbc8:	48 89 c7             	mov    %rax,%rdi
  800420cbcb:	48 b8 24 44 20 04 80 	movabs $0x8004204424,%rax
  800420cbd2:	00 00 00 
  800420cbd5:	ff d0                	callq  *%rax
	return 0;
  800420cbd7:	b8 00 00 00 00       	mov    $0x0,%eax

	panic("sys_page_unmap not implemented");
}
  800420cbdc:	c9                   	leaveq 
  800420cbdd:	c3                   	retq   

000000800420cbde <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420cbde:	55                   	push   %rbp
  800420cbdf:	48 89 e5             	mov    %rsp,%rbp
  800420cbe2:	53                   	push   %rbx
  800420cbe3:	48 83 ec 48          	sub    $0x48,%rsp
  800420cbe7:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420cbea:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420cbed:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420cbf1:	89 4d bc             	mov    %ecx,-0x44(%rbp)


// LAB 4: Your code here.
	struct Env *env;
	if (envid2env(envid,&env,0)<0)
  800420cbf4:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420cbf8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420cbfb:	ba 00 00 00 00       	mov    $0x0,%edx
  800420cc00:	48 89 ce             	mov    %rcx,%rsi
  800420cc03:	89 c7                	mov    %eax,%edi
  800420cc05:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420cc0c:	00 00 00 
  800420cc0f:	ff d0                	callq  *%rax
  800420cc11:	85 c0                	test   %eax,%eax
  800420cc13:	79 0a                	jns    800420cc1f <sys_ipc_try_send+0x41>
		return -E_BAD_ENV;
  800420cc15:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420cc1a:	e9 09 02 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
	if (env->env_ipc_from!=0 || !env->env_ipc_recving)
  800420cc1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cc23:	8b 80 0c 01 00 00    	mov    0x10c(%rax),%eax
  800420cc29:	85 c0                	test   %eax,%eax
  800420cc2b:	75 12                	jne    800420cc3f <sys_ipc_try_send+0x61>
  800420cc2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cc31:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420cc38:	83 f0 01             	xor    $0x1,%eax
  800420cc3b:	84 c0                	test   %al,%al
  800420cc3d:	74 0a                	je     800420cc49 <sys_ipc_try_send+0x6b>
		return -E_IPC_NOT_RECV;
  800420cc3f:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420cc44:	e9 df 01 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
	if (srcva<(void *)UTOP && ROUNDDOWN(srcva, PGSIZE)!=srcva)
  800420cc49:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cc50:	00 00 00 
  800420cc53:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420cc57:	77 22                	ja     800420cc7b <sys_ipc_try_send+0x9d>
  800420cc59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420cc5d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cc61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc65:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420cc6b:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420cc6f:	74 0a                	je     800420cc7b <sys_ipc_try_send+0x9d>
		return -E_INVAL;
  800420cc71:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cc76:	e9 ad 01 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
	if (srcva<(void *)UTOP && ((uint64_t)env->env_ipc_dstva < UTOP)){
  800420cc7b:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cc82:	00 00 00 
  800420cc85:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420cc89:	0f 87 22 01 00 00    	ja     800420cdb1 <sys_ipc_try_send+0x1d3>
  800420cc8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cc93:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420cc9a:	48 89 c2             	mov    %rax,%rdx
  800420cc9d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cca4:	00 00 00 
  800420cca7:	48 39 c2             	cmp    %rax,%rdx
  800420ccaa:	0f 87 01 01 00 00    	ja     800420cdb1 <sys_ipc_try_send+0x1d3>
		env->env_ipc_perm = perm;
  800420ccb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ccb4:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420ccb7:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
		if (!(perm&PTE_U) || !(perm&PTE_P))
  800420ccbd:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420ccc0:	83 e0 04             	and    $0x4,%eax
  800420ccc3:	85 c0                	test   %eax,%eax
  800420ccc5:	74 0a                	je     800420ccd1 <sys_ipc_try_send+0xf3>
  800420ccc7:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420ccca:	83 e0 01             	and    $0x1,%eax
  800420cccd:	85 c0                	test   %eax,%eax
  800420cccf:	75 0a                	jne    800420ccdb <sys_ipc_try_send+0xfd>
			return -E_INVAL;
  800420ccd1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ccd6:	e9 4d 01 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
		if (perm&(~PTE_SYSCALL))
  800420ccdb:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420ccde:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420cce3:	85 c0                	test   %eax,%eax
  800420cce5:	74 0a                	je     800420ccf1 <sys_ipc_try_send+0x113>
			return -E_INVAL;
  800420cce7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ccec:	e9 37 01 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
		pte_t *pte;
		struct PageInfo *page;
		if (!(page=page_lookup(curenv->env_pml4e,srcva,&pte)))
  800420ccf1:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ccf8:	00 00 00 
  800420ccfb:	ff d0                	callq  *%rax
  800420ccfd:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cd04:	00 00 00 
  800420cd07:	48 98                	cltq   
  800420cd09:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd0d:	48 89 c1             	mov    %rax,%rcx
  800420cd10:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cd14:	48 01 c8             	add    %rcx,%rax
  800420cd17:	48 01 d0             	add    %rdx,%rax
  800420cd1a:	48 83 c0 08          	add    $0x8,%rax
  800420cd1e:	48 8b 00             	mov    (%rax),%rax
  800420cd21:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cd28:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420cd2c:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cd30:	48 89 ce             	mov    %rcx,%rsi
  800420cd33:	48 89 c7             	mov    %rax,%rdi
  800420cd36:	48 b8 b5 43 20 04 80 	movabs $0x80042043b5,%rax
  800420cd3d:	00 00 00 
  800420cd40:	ff d0                	callq  *%rax
  800420cd42:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420cd46:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420cd4b:	75 0a                	jne    800420cd57 <sys_ipc_try_send+0x179>
			return -E_INVAL;
  800420cd4d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd52:	e9 d1 00 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
		if (perm&PTE_W && !(*pte&PTE_W))
  800420cd57:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420cd5a:	83 e0 02             	and    $0x2,%eax
  800420cd5d:	85 c0                	test   %eax,%eax
  800420cd5f:	74 19                	je     800420cd7a <sys_ipc_try_send+0x19c>
  800420cd61:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cd65:	48 8b 00             	mov    (%rax),%rax
  800420cd68:	83 e0 02             	and    $0x2,%eax
  800420cd6b:	48 85 c0             	test   %rax,%rax
  800420cd6e:	75 0a                	jne    800420cd7a <sys_ipc_try_send+0x19c>
			return -E_INVAL;
  800420cd70:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd75:	e9 ae 00 00 00       	jmpq   800420ce28 <sys_ipc_try_send+0x24a>
		if (page_insert(env->env_pml4e, page,env->env_ipc_dstva, perm)<0)
  800420cd7a:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420cd7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cd81:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420cd88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cd8c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cd93:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420cd97:	48 89 c7             	mov    %rax,%rdi
  800420cd9a:	48 b8 88 42 20 04 80 	movabs $0x8004204288,%rax
  800420cda1:	00 00 00 
  800420cda4:	ff d0                	callq  *%rax
  800420cda6:	85 c0                	test   %eax,%eax
  800420cda8:	79 07                	jns    800420cdb1 <sys_ipc_try_send+0x1d3>
			return -E_NO_MEM;
  800420cdaa:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420cdaf:	eb 77                	jmp    800420ce28 <sys_ipc_try_send+0x24a>
	}
	env->env_status = ENV_RUNNABLE;
  800420cdb1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdb5:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420cdbc:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420cdbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdc3:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420cdca:	00 

	env->env_ipc_from = curenv->env_id;
  800420cdcb:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420cdcf:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420cdd6:	00 00 00 
  800420cdd9:	ff d0                	callq  *%rax
  800420cddb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cde2:	00 00 00 
  800420cde5:	48 98                	cltq   
  800420cde7:	48 c1 e0 03          	shl    $0x3,%rax
  800420cdeb:	48 89 c1             	mov    %rax,%rcx
  800420cdee:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cdf2:	48 01 c8             	add    %rcx,%rax
  800420cdf5:	48 01 d0             	add    %rdx,%rax
  800420cdf8:	48 83 c0 08          	add    $0x8,%rax
  800420cdfc:	48 8b 00             	mov    (%rax),%rax
  800420cdff:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420ce05:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	env->env_ipc_recving = 0;
  800420ce0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce0f:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	env->env_ipc_value = value; 
  800420ce16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce1a:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420ce1d:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)

	return 0;
  800420ce23:	b8 00 00 00 00       	mov    $0x0,%eax



//panic("sys_ipc_try_send not implemented");

}
  800420ce28:	48 83 c4 48          	add    $0x48,%rsp
  800420ce2c:	5b                   	pop    %rbx
  800420ce2d:	5d                   	pop    %rbp
  800420ce2e:	c3                   	retq   

000000800420ce2f <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420ce2f:	55                   	push   %rbp
  800420ce30:	48 89 e5             	mov    %rsp,%rbp
  800420ce33:	48 83 ec 20          	sub    $0x20,%rsp
  800420ce37:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

// LAB 4: Your code here.
	if (dstva<(void *)UTOP)
  800420ce3b:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ce42:	00 00 00 
  800420ce45:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420ce49:	77 22                	ja     800420ce6d <sys_ipc_recv+0x3e>
		if (ROUNDDOWN(dstva, PGSIZE)!=dstva)
  800420ce4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ce53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ce57:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420ce5d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420ce61:	74 0a                	je     800420ce6d <sys_ipc_recv+0x3e>
			return -E_INVAL;
  800420ce63:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ce68:	e9 64 01 00 00       	jmpq   800420cfd1 <sys_ipc_recv+0x1a2>
		curenv->env_tf.tf_regs.reg_rax =  0;
  800420ce6d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ce74:	00 00 00 
  800420ce77:	ff d0                	callq  *%rax
  800420ce79:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420ce80:	00 00 00 
  800420ce83:	48 98                	cltq   
  800420ce85:	48 c1 e0 03          	shl    $0x3,%rax
  800420ce89:	48 89 c1             	mov    %rax,%rcx
  800420ce8c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ce90:	48 01 c8             	add    %rcx,%rax
  800420ce93:	48 01 d0             	add    %rdx,%rax
  800420ce96:	48 83 c0 08          	add    $0x8,%rax
  800420ce9a:	48 8b 00             	mov    (%rax),%rax
  800420ce9d:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420cea4:	00 
		curenv->env_ipc_dstva = dstva;
  800420cea5:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420ceac:	00 00 00 
  800420ceaf:	ff d0                	callq  *%rax
  800420ceb1:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420ceb8:	00 00 00 
  800420cebb:	48 98                	cltq   
  800420cebd:	48 c1 e0 03          	shl    $0x3,%rax
  800420cec1:	48 89 c1             	mov    %rax,%rcx
  800420cec4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cec8:	48 01 c8             	add    %rcx,%rax
  800420cecb:	48 01 d0             	add    %rdx,%rax
  800420cece:	48 83 c0 08          	add    $0x8,%rax
  800420ced2:	48 8b 00             	mov    (%rax),%rax
  800420ced5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ced9:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
		curenv->env_ipc_from = 0;
  800420cee0:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420cee7:	00 00 00 
  800420ceea:	ff d0                	callq  *%rax
  800420ceec:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cef3:	00 00 00 
  800420cef6:	48 98                	cltq   
  800420cef8:	48 c1 e0 03          	shl    $0x3,%rax
  800420cefc:	48 89 c1             	mov    %rax,%rcx
  800420ceff:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf03:	48 01 c8             	add    %rcx,%rax
  800420cf06:	48 01 d0             	add    %rdx,%rax
  800420cf09:	48 83 c0 08          	add    $0x8,%rax
  800420cf0d:	48 8b 00             	mov    (%rax),%rax
  800420cf10:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420cf17:	00 00 00 
		curenv->env_ipc_recving = 1;
  800420cf1a:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420cf21:	00 00 00 
  800420cf24:	ff d0                	callq  *%rax
  800420cf26:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cf2d:	00 00 00 
  800420cf30:	48 98                	cltq   
  800420cf32:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf36:	48 89 c1             	mov    %rax,%rcx
  800420cf39:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf3d:	48 01 c8             	add    %rcx,%rax
  800420cf40:	48 01 d0             	add    %rdx,%rax
  800420cf43:	48 83 c0 08          	add    $0x8,%rax
  800420cf47:	48 8b 00             	mov    (%rax),%rax
  800420cf4a:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
		curenv->env_ipc_perm = 0;
  800420cf51:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420cf58:	00 00 00 
  800420cf5b:	ff d0                	callq  *%rax
  800420cf5d:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cf64:	00 00 00 
  800420cf67:	48 98                	cltq   
  800420cf69:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf6d:	48 89 c1             	mov    %rax,%rcx
  800420cf70:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf74:	48 01 c8             	add    %rcx,%rax
  800420cf77:	48 01 d0             	add    %rdx,%rax
  800420cf7a:	48 83 c0 08          	add    $0x8,%rax
  800420cf7e:	48 8b 00             	mov    (%rax),%rax
  800420cf81:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420cf88:	00 00 00 

		curenv->env_status = ENV_NOT_RUNNABLE;
  800420cf8b:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420cf92:	00 00 00 
  800420cf95:	ff d0                	callq  *%rax
  800420cf97:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420cf9e:	00 00 00 
  800420cfa1:	48 98                	cltq   
  800420cfa3:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfa7:	48 89 c1             	mov    %rax,%rcx
  800420cfaa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cfae:	48 01 c8             	add    %rcx,%rax
  800420cfb1:	48 01 d0             	add    %rdx,%rax
  800420cfb4:	48 83 c0 08          	add    $0x8,%rax
  800420cfb8:	48 8b 00             	mov    (%rax),%rax
  800420cfbb:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420cfc2:	00 00 00 

		sched_yield();
  800420cfc5:	48 b8 3a c2 20 04 80 	movabs $0x800420c23a,%rax
  800420cfcc:	00 00 00 
  800420cfcf:	ff d0                	callq  *%rax

		return 0;
}
  800420cfd1:	c9                   	leaveq 
  800420cfd2:	c3                   	retq   

000000800420cfd3 <sys_time_msec>:
// Return the current time.
static int
sys_time_msec(void)
{
  800420cfd3:	55                   	push   %rbp
  800420cfd4:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	panic("sys_time_msec not implemented");
  800420cfd7:	48 ba ed 8f 21 04 80 	movabs $0x8004218fed,%rdx
  800420cfde:	00 00 00 
  800420cfe1:	be a7 01 00 00       	mov    $0x1a7,%esi
  800420cfe6:	48 bf 0b 90 21 04 80 	movabs $0x800421900b,%rdi
  800420cfed:	00 00 00 
  800420cff0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cff5:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420cffc:	00 00 00 
  800420cfff:	ff d1                	callq  *%rcx

000000800420d001 <sys_set_priority>:
#endif //!VMM_GUEST



static void 
sys_set_priority(envid_t envid,int priority){
  800420d001:	55                   	push   %rbp
  800420d002:	48 89 e5             	mov    %rsp,%rbp
  800420d005:	48 83 ec 20          	sub    $0x20,%rsp
  800420d009:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d00c:	89 75 e8             	mov    %esi,-0x18(%rbp)
		struct Env *env;
		if (envid2env(envid,&env,1)<0)
  800420d00f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d013:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d016:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d01b:	48 89 ce             	mov    %rcx,%rsi
  800420d01e:	89 c7                	mov    %eax,%edi
  800420d020:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420d027:	00 00 00 
  800420d02a:	ff d0                	callq  *%rax
  800420d02c:	85 c0                	test   %eax,%eax
  800420d02e:	79 2a                	jns    800420d05a <sys_set_priority+0x59>
			panic("sys_set_priority: envid2env()\n");
  800420d030:	48 ba 20 90 21 04 80 	movabs $0x8004219020,%rdx
  800420d037:	00 00 00 
  800420d03a:	be f5 01 00 00       	mov    $0x1f5,%esi
  800420d03f:	48 bf 0b 90 21 04 80 	movabs $0x800421900b,%rdi
  800420d046:	00 00 00 
  800420d049:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d04e:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  800420d055:	00 00 00 
  800420d058:	ff d1                	callq  *%rcx
		env->env_priority=priority;
  800420d05a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d05e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d061:	89 90 68 01 00 00    	mov    %edx,0x168(%rax)
		return;
  800420d067:	90                   	nop
}
  800420d068:	c9                   	leaveq 
  800420d069:	c3                   	retq   

000000800420d06a <sys_env_set_trapframe>:

static int
 sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
 {
  800420d06a:	55                   	push   %rbp
  800420d06b:	48 89 e5             	mov    %rsp,%rbp
  800420d06e:	48 83 ec 20          	sub    $0x20,%rsp
  800420d072:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d075:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 struct Env *env;
 if (envid2env (envid, &env, 1) < 0)
  800420d079:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d07d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d080:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d085:	48 89 ce             	mov    %rcx,%rsi
  800420d088:	89 c7                	mov    %eax,%edi
  800420d08a:	48 b8 eb 82 20 04 80 	movabs $0x80042082eb,%rax
  800420d091:	00 00 00 
  800420d094:	ff d0                	callq  *%rax
  800420d096:	85 c0                	test   %eax,%eax
  800420d098:	79 07                	jns    800420d0a1 <sys_env_set_trapframe+0x37>
 return -E_BAD_ENV;
  800420d09a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d09f:	eb 65                	jmp    800420d106 <sys_env_set_trapframe+0x9c>

user_mem_assert (env, tf, sizeof (struct Trapframe), PTE_U);
  800420d0a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0a5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d0a9:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d0ae:	ba c0 00 00 00       	mov    $0xc0,%edx
  800420d0b3:	48 89 c7             	mov    %rax,%rdi
  800420d0b6:	48 b8 c5 47 20 04 80 	movabs $0x80042047c5,%rax
  800420d0bd:	00 00 00 
  800420d0c0:	ff d0                	callq  *%rax

 env->env_tf.tf_cs = GD_UT | 3;
  800420d0c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0c6:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  800420d0cd:	1b 00 
 env->env_tf.tf_eflags |= FL_IF;
  800420d0cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d0d3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d0d7:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420d0de:	80 ce 02             	or     $0x2,%dh
  800420d0e1:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
 env->env_tf = *tf;
  800420d0e8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d0ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d0f0:	48 89 c6             	mov    %rax,%rsi
  800420d0f3:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d0f8:	48 89 d7             	mov    %rdx,%rdi
  800420d0fb:	48 89 c1             	mov    %rax,%rcx
  800420d0fe:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
 return 0;
  800420d101:	b8 00 00 00 00       	mov    $0x0,%eax
 }
  800420d106:	c9                   	leaveq 
  800420d107:	c3                   	retq   

000000800420d108 <syscall>:

// Dispatches to the correct kernel function, passing the arguments.
	int64_t
	syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
	{
  800420d108:	55                   	push   %rbp
  800420d109:	48 89 e5             	mov    %rsp,%rbp
  800420d10c:	48 83 ec 30          	sub    $0x30,%rsp
  800420d110:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d114:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420d118:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d11c:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420d120:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420d124:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
// Call the function corresponding to the 'syscallno' parameter.
// Return any appropriate return value.
// LAB 3: Your code here.
// panic("syscall not implemented");

		switch (syscallno) {
  800420d128:	48 83 7d f8 11       	cmpq   $0x11,-0x8(%rbp)
  800420d12d:	0f 87 d9 01 00 00    	ja     800420d30c <syscall+0x204>
  800420d133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d137:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420d13e:	00 
  800420d13f:	48 b8 40 90 21 04 80 	movabs $0x8004219040,%rax
  800420d146:	00 00 00 
  800420d149:	48 01 d0             	add    %rdx,%rax
  800420d14c:	48 8b 00             	mov    (%rax),%rax
  800420d14f:	ff e0                	jmpq   *%rax
			case SYS_cgetc:
			return sys_cgetc();
  800420d151:	48 b8 4e c6 20 04 80 	movabs $0x800420c64e,%rax
  800420d158:	00 00 00 
  800420d15b:	ff d0                	callq  *%rax
  800420d15d:	48 98                	cltq   
  800420d15f:	e9 af 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_getenvid:
			return sys_getenvid();
  800420d164:	48 b8 60 c6 20 04 80 	movabs $0x800420c660,%rax
  800420d16b:	00 00 00 
  800420d16e:	ff d0                	callq  *%rax
  800420d170:	48 98                	cltq   
  800420d172:	e9 9c 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_env_destroy:
			return sys_env_destroy((envid_t)a1);
  800420d177:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d17b:	89 c7                	mov    %eax,%edi
  800420d17d:	48 b8 9c c6 20 04 80 	movabs $0x800420c69c,%rax
  800420d184:	00 00 00 
  800420d187:	ff d0                	callq  *%rax
  800420d189:	48 98                	cltq   
  800420d18b:	e9 83 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_cputs:
			sys_cputs((const char *)a1, (size_t)a2);
  800420d190:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d194:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d198:	48 89 d6             	mov    %rdx,%rsi
  800420d19b:	48 89 c7             	mov    %rax,%rdi
  800420d19e:	48 b8 ca c5 20 04 80 	movabs $0x800420c5ca,%rax
  800420d1a5:	00 00 00 
  800420d1a8:	ff d0                	callq  *%rax
			return 0;
  800420d1aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d1af:	e9 5f 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_set_priority:
			sys_set_priority((envid_t)a1,(int)a2);
  800420d1b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1b8:	89 c2                	mov    %eax,%edx
  800420d1ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1be:	89 d6                	mov    %edx,%esi
  800420d1c0:	89 c7                	mov    %eax,%edi
  800420d1c2:	48 b8 01 d0 20 04 80 	movabs $0x800420d001,%rax
  800420d1c9:	00 00 00 
  800420d1cc:	ff d0                	callq  *%rax
			return 0;
  800420d1ce:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d1d3:	e9 3b 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_exofork:
			return sys_exofork();
  800420d1d8:	48 b8 fc c6 20 04 80 	movabs $0x800420c6fc,%rax
  800420d1df:	00 00 00 
  800420d1e2:	ff d0                	callq  *%rax
  800420d1e4:	48 98                	cltq   
  800420d1e6:	e9 28 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_env_set_status:
			return sys_env_set_status((envid_t) a1, (int)a2);
  800420d1eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d1ef:	89 c2                	mov    %eax,%edx
  800420d1f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1f5:	89 d6                	mov    %edx,%esi
  800420d1f7:	89 c7                	mov    %eax,%edi
  800420d1f9:	48 b8 d1 c7 20 04 80 	movabs $0x800420c7d1,%rax
  800420d200:	00 00 00 
  800420d203:	ff d0                	callq  *%rax
  800420d205:	48 98                	cltq   
  800420d207:	e9 07 01 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall((envid_t)a1,(void *)a2);
  800420d20c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d210:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d214:	48 89 d6             	mov    %rdx,%rsi
  800420d217:	89 c7                	mov    %eax,%edi
  800420d219:	48 b8 31 c8 20 04 80 	movabs $0x800420c831,%rax
  800420d220:	00 00 00 
  800420d223:	ff d0                	callq  *%rax
  800420d225:	48 98                	cltq   
  800420d227:	e9 e7 00 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_page_alloc :
			return sys_page_alloc((envid_t) a1, (void*)a2, (int)a3);
  800420d22c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d230:	89 c2                	mov    %eax,%edx
  800420d232:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d236:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d23a:	48 89 ce             	mov    %rcx,%rsi
  800420d23d:	89 c7                	mov    %eax,%edi
  800420d23f:	48 b8 81 c8 20 04 80 	movabs $0x800420c881,%rax
  800420d246:	00 00 00 
  800420d249:	ff d0                	callq  *%rax
  800420d24b:	48 98                	cltq   
  800420d24d:	e9 c1 00 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_page_map :
			return sys_page_map((envid_t) a1, (void*) a2, (envid_t) a3, (void*) a4, (int) a5);
  800420d252:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d256:	89 c7                	mov    %eax,%edi
  800420d258:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420d25c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d260:	89 c2                	mov    %eax,%edx
  800420d262:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d266:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d26a:	41 89 f8             	mov    %edi,%r8d
  800420d26d:	89 c7                	mov    %eax,%edi
  800420d26f:	48 b8 b7 c9 20 04 80 	movabs $0x800420c9b7,%rax
  800420d276:	00 00 00 
  800420d279:	ff d0                	callq  *%rax
  800420d27b:	48 98                	cltq   
  800420d27d:	e9 91 00 00 00       	jmpq   800420d313 <syscall+0x20b>
			case SYS_page_unmap :
			return sys_page_unmap((envid_t) a1, (void*) a2);
  800420d282:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d286:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d28a:	48 89 d6             	mov    %rdx,%rsi
  800420d28d:	89 c7                	mov    %eax,%edi
  800420d28f:	48 b8 27 cb 20 04 80 	movabs $0x800420cb27,%rax
  800420d296:	00 00 00 
  800420d299:	ff d0                	callq  *%rax
  800420d29b:	48 98                	cltq   
  800420d29d:	eb 74                	jmp    800420d313 <syscall+0x20b>
			case SYS_yield:
			sys_yield();
  800420d29f:	48 b8 ec c6 20 04 80 	movabs $0x800420c6ec,%rax
  800420d2a6:	00 00 00 
  800420d2a9:	ff d0                	callq  *%rax
			return 0;
  800420d2ab:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d2b0:	eb 61                	jmp    800420d313 <syscall+0x20b>
			case SYS_ipc_try_send:
			return sys_ipc_try_send((envid_t)a1,(uint32_t)a2,(void *)a3,(unsigned)a4);
  800420d2b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d2b6:	89 c1                	mov    %eax,%ecx
  800420d2b8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d2bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2c0:	89 c6                	mov    %eax,%esi
  800420d2c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2c6:	89 c7                	mov    %eax,%edi
  800420d2c8:	48 b8 de cb 20 04 80 	movabs $0x800420cbde,%rax
  800420d2cf:	00 00 00 
  800420d2d2:	ff d0                	callq  *%rax
  800420d2d4:	48 98                	cltq   
  800420d2d6:	eb 3b                	jmp    800420d313 <syscall+0x20b>
			case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
  800420d2d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2dc:	48 89 c7             	mov    %rax,%rdi
  800420d2df:	48 b8 2f ce 20 04 80 	movabs $0x800420ce2f,%rax
  800420d2e6:	00 00 00 
  800420d2e9:	ff d0                	callq  *%rax
  800420d2eb:	48 98                	cltq   
  800420d2ed:	eb 24                	jmp    800420d313 <syscall+0x20b>
		return 0;
#endif


			case SYS_env_set_trapframe:
			return sys_env_set_trapframe((envid_t)a1, (struct Trapframe*)a2);
  800420d2ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d2f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2f7:	48 89 d6             	mov    %rdx,%rsi
  800420d2fa:	89 c7                	mov    %eax,%edi
  800420d2fc:	48 b8 6a d0 20 04 80 	movabs $0x800420d06a,%rax
  800420d303:	00 00 00 
  800420d306:	ff d0                	callq  *%rax
  800420d308:	48 98                	cltq   
  800420d30a:	eb 07                	jmp    800420d313 <syscall+0x20b>
			default:
			return -E_NO_SYS;
  800420d30c:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
		}

	}
  800420d313:	c9                   	leaveq 
  800420d314:	c3                   	retq   

000000800420d315 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420d315:	55                   	push   %rbp
  800420d316:	48 89 e5             	mov    %rsp,%rbp
  800420d319:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420d320:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420d327:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420d32e:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420d335:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d33c:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420d343:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420d347:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d34e:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d355:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420d359:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420d360:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d367:	48 89 d1             	mov    %rdx,%rcx
  800420d36a:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d36f:	48 89 ce             	mov    %rcx,%rsi
  800420d372:	48 89 c7             	mov    %rax,%rdi
  800420d375:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  800420d37c:	00 00 00 
  800420d37f:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420d381:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420d388:	00 
	uint64_t ret_offset=0;
  800420d389:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d390:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420d391:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d398:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d39c:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420d3a0:	74 0a                	je     800420d3ac <list_func_die+0x97>
		return 0;
  800420d3a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d3a7:	e9 cd 06 00 00       	jmpq   800420da79 <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420d3ac:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d3b3:	ba 38 00 00 00       	mov    $0x38,%edx
  800420d3b8:	be 00 00 00 00       	mov    $0x0,%esi
  800420d3bd:	48 89 c7             	mov    %rax,%rdi
  800420d3c0:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  800420d3c7:	00 00 00 
  800420d3ca:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420d3cc:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d3d3:	be 11 00 00 00       	mov    $0x11,%esi
  800420d3d8:	48 89 c7             	mov    %rax,%rdi
  800420d3db:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d3e2:	00 00 00 
  800420d3e5:	ff d0                	callq  *%rax
  800420d3e7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420d3eb:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d3f2:	be 12 00 00 00       	mov    $0x12,%esi
  800420d3f7:	48 89 c7             	mov    %rax,%rdi
  800420d3fa:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d401:	00 00 00 
  800420d404:	ff d0                	callq  *%rax
  800420d406:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420d40a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420d40f:	0f 84 5f 06 00 00    	je     800420da74 <list_func_die+0x75f>
  800420d415:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d419:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d41d:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d424:	0f 83 4a 06 00 00    	jae    800420da74 <list_func_die+0x75f>
  800420d42a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d42f:	0f 84 3f 06 00 00    	je     800420da74 <list_func_die+0x75f>
  800420d435:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d439:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d43d:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d444:	0f 86 2a 06 00 00    	jbe    800420da74 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420d44a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d451:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d458:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d45f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d466:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420d469:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d470:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d477:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d47e:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420d482:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d489:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420d490:	48 89 c7             	mov    %rax,%rdi
  800420d493:	48 b8 4b eb 20 04 80 	movabs $0x800420eb4b,%rax
  800420d49a:	00 00 00 
  800420d49d:	ff d0                	callq  *%rax
  800420d49f:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420d4a6:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420d4a9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d4ad:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d4b1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d4b8:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420d4bc:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d4c3:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d4ca:	48 85 c0             	test   %rax,%rax
  800420d4cd:	75 35                	jne    800420d504 <list_func_die+0x1ef>
  800420d4cf:	48 b9 00 94 21 04 80 	movabs $0x8004219400,%rcx
  800420d4d6:	00 00 00 
  800420d4d9:	48 ba 0c 94 21 04 80 	movabs $0x800421940c,%rdx
  800420d4e0:	00 00 00 
  800420d4e3:	be 92 00 00 00       	mov    $0x92,%esi
  800420d4e8:	48 bf 21 94 21 04 80 	movabs $0x8004219421,%rdi
  800420d4ef:	00 00 00 
  800420d4f2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d4f7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420d4fe:	00 00 00 
  800420d501:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420d504:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d50b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d512:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420d519:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420d520:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d525:	48 89 c7             	mov    %rax,%rdi
  800420d528:	48 b8 bb 43 21 04 80 	movabs $0x80042143bb,%rax
  800420d52f:	00 00 00 
  800420d532:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420d534:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d53b:	89 c2                	mov    %eax,%edx
  800420d53d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d544:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420d547:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d54e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420d555:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420d55c:	00 00 00 
  800420d55f:	48 8b 00             	mov    (%rax),%rax
  800420d562:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d569:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d570:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d574:	48 89 c7             	mov    %rax,%rdi
  800420d577:	48 b8 5c 10 21 04 80 	movabs $0x800421105c,%rax
  800420d57e:	00 00 00 
  800420d581:	ff d0                	callq  *%rax
  800420d583:	83 f8 04             	cmp    $0x4,%eax
  800420d586:	0f 84 e1 04 00 00    	je     800420da6d <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420d58c:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d593:	48 83 f8 05          	cmp    $0x5,%rax
  800420d597:	74 05                	je     800420d59e <list_func_die+0x289>
				goto last;
  800420d599:	e9 cf 04 00 00       	jmpq   800420da6d <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d59e:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d5a5:	be 49 00 00 00       	mov    $0x49,%esi
  800420d5aa:	48 89 c7             	mov    %rax,%rdi
  800420d5ad:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d5b4:	00 00 00 
  800420d5b7:	ff d0                	callq  *%rax
  800420d5b9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420d5bd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d5c2:	0f 84 d7 00 00 00    	je     800420d69f <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d5c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d5cc:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d5d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d5d4:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d5d8:	48 01 d0             	add    %rdx,%rax
  800420d5db:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420d5df:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420d5e6:	00 00 00 
  800420d5e9:	48 8b 08             	mov    (%rax),%rcx
  800420d5ec:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d5f3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d5f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d5fb:	48 8b 38             	mov    (%rax),%rdi
  800420d5fe:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d602:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d606:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d60b:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d60f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d614:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d618:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d61d:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d621:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d626:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d62a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d62f:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d633:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d638:	48 89 cf             	mov    %rcx,%rdi
  800420d63b:	48 b8 82 0c 21 04 80 	movabs $0x8004210c82,%rax
  800420d642:	00 00 00 
  800420d645:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d647:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d64e:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d653:	48 89 c7             	mov    %rax,%rdi
  800420d656:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d65d:	00 00 00 
  800420d660:	ff d0                	callq  *%rax
  800420d662:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420d666:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d66b:	74 0e                	je     800420d67b <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420d66d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d671:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d675:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d679:	eb 24                	jmp    800420d69f <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420d67b:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d682:	be 49 00 00 00       	mov    $0x49,%esi
  800420d687:	48 89 c7             	mov    %rax,%rdi
  800420d68a:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d691:	00 00 00 
  800420d694:	ff d0                	callq  *%rax
  800420d696:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420d69a:	e9 1e ff ff ff       	jmpq   800420d5bd <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420d69f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d6a6:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d6a7:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d6ae:	be 02 00 00 00       	mov    $0x2,%esi
  800420d6b3:	48 89 c7             	mov    %rax,%rdi
  800420d6b6:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d6bd:	00 00 00 
  800420d6c0:	ff d0                	callq  *%rax
  800420d6c2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420d6c6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6cb:	0f 84 a2 00 00 00    	je     800420d773 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d6d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6d5:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d6d9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d6dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6e1:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d6e5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420d6e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6ed:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d6f1:	48 83 f8 03          	cmp    $0x3,%rax
  800420d6f5:	72 7c                	jb     800420d773 <list_func_die+0x45e>
  800420d6f7:	48 83 f8 04          	cmp    $0x4,%rax
  800420d6fb:	76 06                	jbe    800420d703 <list_func_die+0x3ee>
  800420d6fd:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d701:	75 70                	jne    800420d773 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420d703:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d70a:	00 
						atom = *(loc_ptr++);
  800420d70b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d70f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d713:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420d717:	0f b6 00             	movzbl (%rax),%eax
  800420d71a:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420d71d:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420d722:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420d726:	75 4a                	jne    800420d772 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420d728:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d72c:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420d733:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420d73a:	48 89 c7             	mov    %rax,%rdi
  800420d73d:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  800420d744:	00 00 00 
  800420d747:	ff d0                	callq  *%rax
  800420d749:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420d74d:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d754:	48 89 c2             	mov    %rax,%rdx
  800420d757:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d75b:	48 29 c2             	sub    %rax,%rdx
  800420d75e:	48 89 d0             	mov    %rdx,%rax
  800420d761:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420d765:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d76c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420d770:	eb 00                	jmp    800420d772 <list_func_die+0x45d>
  800420d772:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d773:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d77a:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d77d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d781:	89 c2                	mov    %eax,%edx
  800420d783:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d78a:	48 63 c9             	movslq %ecx,%rcx
  800420d78d:	48 83 c1 08          	add    $0x8,%rcx
  800420d791:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420d795:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d79c:	8b 50 28             	mov    0x28(%rax),%edx
  800420d79f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d7a6:	48 63 d2             	movslq %edx,%rdx
  800420d7a9:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d7ad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d7b1:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420d7b6:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d7bd:	8b 40 28             	mov    0x28(%rax),%eax
  800420d7c0:	8d 50 01             	lea    0x1(%rax),%edx
  800420d7c3:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d7ca:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d7cd:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d7d4:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d7db:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d7e0:	48 89 ce             	mov    %rcx,%rsi
  800420d7e3:	48 89 c7             	mov    %rax,%rdi
  800420d7e6:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  800420d7ed:	00 00 00 
  800420d7f0:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d7f2:	e9 40 02 00 00       	jmpq   800420da37 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420d7f7:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d7fe:	48 83 f8 05          	cmp    $0x5,%rax
  800420d802:	74 05                	je     800420d809 <list_func_die+0x4f4>
					break;
  800420d804:	e9 64 02 00 00       	jmpq   800420da6d <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d809:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d810:	be 49 00 00 00       	mov    $0x49,%esi
  800420d815:	48 89 c7             	mov    %rax,%rdi
  800420d818:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d81f:	00 00 00 
  800420d822:	ff d0                	callq  *%rax
  800420d824:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420d828:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d82d:	0f 84 b1 00 00 00    	je     800420d8e4 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d833:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d837:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d83b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d83f:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d843:	48 01 d0             	add    %rdx,%rax
  800420d846:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420d84a:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420d851:	00 00 00 
  800420d854:	48 8b 08             	mov    (%rax),%rcx
  800420d857:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d85e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d862:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d866:	48 8b 38             	mov    (%rax),%rdi
  800420d869:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d86d:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d871:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d876:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d87a:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d87f:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d883:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d888:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d88c:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d891:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d895:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d89a:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d89e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d8a3:	48 89 cf             	mov    %rcx,%rdi
  800420d8a6:	48 b8 82 0c 21 04 80 	movabs $0x8004210c82,%rax
  800420d8ad:	00 00 00 
  800420d8b0:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d8b2:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d8b9:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d8be:	48 89 c7             	mov    %rax,%rdi
  800420d8c1:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d8c8:	00 00 00 
  800420d8cb:	ff d0                	callq  *%rax
  800420d8cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420d8d1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d8d6:	74 0c                	je     800420d8e4 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420d8d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8dc:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d8e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420d8e4:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d8eb:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d8ec:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d8f3:	be 02 00 00 00       	mov    $0x2,%esi
  800420d8f8:	48 89 c7             	mov    %rax,%rdi
  800420d8fb:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  800420d902:	00 00 00 
  800420d905:	ff d0                	callq  *%rax
  800420d907:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420d90b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d910:	0f 84 a2 00 00 00    	je     800420d9b8 <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d916:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d91a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d91e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d922:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d926:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d92a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420d92e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d932:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d936:	48 83 f8 03          	cmp    $0x3,%rax
  800420d93a:	72 7c                	jb     800420d9b8 <list_func_die+0x6a3>
  800420d93c:	48 83 f8 04          	cmp    $0x4,%rax
  800420d940:	76 06                	jbe    800420d948 <list_func_die+0x633>
  800420d942:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d946:	75 70                	jne    800420d9b8 <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420d948:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d94f:	00 
							atom = *(loc_ptr++);
  800420d950:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d954:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d958:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420d95c:	0f b6 00             	movzbl (%rax),%eax
  800420d95f:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420d962:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420d967:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420d96b:	75 4a                	jne    800420d9b7 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420d96d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d971:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420d978:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420d97f:	48 89 c7             	mov    %rax,%rdi
  800420d982:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  800420d989:	00 00 00 
  800420d98c:	ff d0                	callq  *%rax
  800420d98e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420d992:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d999:	48 89 c2             	mov    %rax,%rdx
  800420d99c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d9a0:	48 29 c2             	sub    %rax,%rdx
  800420d9a3:	48 89 d0             	mov    %rdx,%rax
  800420d9a6:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420d9aa:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d9b1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420d9b5:	eb 00                	jmp    800420d9b7 <list_func_die+0x6a2>
  800420d9b7:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d9b8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9bf:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d9c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9c6:	89 c2                	mov    %eax,%edx
  800420d9c8:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9cf:	48 63 c9             	movslq %ecx,%rcx
  800420d9d2:	48 83 c1 08          	add    $0x8,%rcx
  800420d9d6:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420d9da:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9e1:	8b 50 28             	mov    0x28(%rax),%edx
  800420d9e4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d9eb:	48 63 d2             	movslq %edx,%rdx
  800420d9ee:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d9f2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d9f6:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420d9fb:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420da02:	8b 40 28             	mov    0x28(%rax),%eax
  800420da05:	8d 50 01             	lea    0x1(%rax),%edx
  800420da08:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420da0f:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420da12:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420da19:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420da20:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420da25:	48 89 ce             	mov    %rcx,%rsi
  800420da28:	48 89 c7             	mov    %rax,%rdi
  800420da2b:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  800420da32:	00 00 00 
  800420da35:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420da37:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420da3e:	00 00 00 
  800420da41:	48 8b 00             	mov    (%rax),%rax
  800420da44:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420da48:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420da4f:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420da56:	48 89 c7             	mov    %rax,%rdi
  800420da59:	48 b8 18 0e 21 04 80 	movabs $0x8004210e18,%rax
  800420da60:	00 00 00 
  800420da63:	ff d0                	callq  *%rax
  800420da65:	85 c0                	test   %eax,%eax
  800420da67:	0f 84 8a fd ff ff    	je     800420d7f7 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420da6d:	b8 01 00 00 00       	mov    $0x1,%eax
  800420da72:	eb 05                	jmp    800420da79 <list_func_die+0x764>
	}

	return 0;
  800420da74:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420da79:	c9                   	leaveq 
  800420da7a:	c3                   	retq   

000000800420da7b <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420da7b:	55                   	push   %rbp
  800420da7c:	48 89 e5             	mov    %rsp,%rbp
  800420da7f:	53                   	push   %rbx
  800420da80:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420da87:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420da8e:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420da95:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420da9c:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420da9d:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420daa4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420daa8:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420daaf:	48 bb 2f 94 21 04 80 	movabs $0x800421942f,%rbx
  800420dab6:	00 00 00 
  800420dab9:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420dabc:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dac3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420daca:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dad1:	48 bb 2f 94 21 04 80 	movabs $0x800421942f,%rbx
  800420dad8:	00 00 00 
  800420dadb:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420dadf:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dae6:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420daed:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420daf4:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dafb:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420daff:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420db06:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420db0d:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420db14:	00 00 00 
  800420db17:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420db1e:	76 13                	jbe    800420db33 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420db20:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420db27:	00 00 00 
  800420db2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420db2e:	e9 04 01 00 00       	jmpq   800420dc37 <debuginfo_rip+0x1bc>
	} else {
		if(curenv != lastenv) {
  800420db33:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420db3a:	00 00 00 
  800420db3d:	ff d0                	callq  *%rax
  800420db3f:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420db46:	00 00 00 
  800420db49:	48 98                	cltq   
  800420db4b:	48 c1 e0 03          	shl    $0x3,%rax
  800420db4f:	48 89 c1             	mov    %rax,%rcx
  800420db52:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db56:	48 01 c8             	add    %rcx,%rax
  800420db59:	48 01 d0             	add    %rdx,%rax
  800420db5c:	48 83 c0 08          	add    $0x8,%rax
  800420db60:	48 8b 10             	mov    (%rax),%rdx
  800420db63:	48 b8 98 52 37 04 80 	movabs $0x8004375298,%rax
  800420db6a:	00 00 00 
  800420db6d:	48 8b 00             	mov    (%rax),%rax
  800420db70:	48 39 c2             	cmp    %rax,%rdx
  800420db73:	0f 84 83 00 00 00    	je     800420dbfc <debuginfo_rip+0x181>
			find_debug_sections((uintptr_t)curenv->elf);
  800420db79:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420db80:	00 00 00 
  800420db83:	ff d0                	callq  *%rax
  800420db85:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420db8c:	00 00 00 
  800420db8f:	48 98                	cltq   
  800420db91:	48 c1 e0 03          	shl    $0x3,%rax
  800420db95:	48 89 c1             	mov    %rax,%rcx
  800420db98:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db9c:	48 01 c8             	add    %rcx,%rax
  800420db9f:	48 01 d0             	add    %rdx,%rax
  800420dba2:	48 83 c0 08          	add    $0x8,%rax
  800420dba6:	48 8b 00             	mov    (%rax),%rax
  800420dba9:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420dbb0:	48 89 c7             	mov    %rax,%rdi
  800420dbb3:	48 b8 b6 45 21 04 80 	movabs $0x80042145b6,%rax
  800420dbba:	00 00 00 
  800420dbbd:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420dbbf:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420dbc6:	00 00 00 
  800420dbc9:	ff d0                	callq  *%rax
  800420dbcb:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420dbd2:	00 00 00 
  800420dbd5:	48 98                	cltq   
  800420dbd7:	48 c1 e0 03          	shl    $0x3,%rax
  800420dbdb:	48 89 c1             	mov    %rax,%rcx
  800420dbde:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dbe2:	48 01 c8             	add    %rcx,%rax
  800420dbe5:	48 01 d0             	add    %rdx,%rax
  800420dbe8:	48 83 c0 08          	add    $0x8,%rax
  800420dbec:	48 8b 10             	mov    (%rax),%rdx
  800420dbef:	48 b8 98 52 37 04 80 	movabs $0x8004375298,%rax
  800420dbf6:	00 00 00 
  800420dbf9:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420dbfc:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800420dc03:	00 00 00 
  800420dc06:	ff d0                	callq  *%rax
  800420dc08:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  800420dc0f:	00 00 00 
  800420dc12:	48 98                	cltq   
  800420dc14:	48 c1 e0 03          	shl    $0x3,%rax
  800420dc18:	48 89 c1             	mov    %rax,%rcx
  800420dc1b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dc1f:	48 01 c8             	add    %rcx,%rax
  800420dc22:	48 01 d0             	add    %rdx,%rax
  800420dc25:	48 83 c0 08          	add    $0x8,%rax
  800420dc29:	48 8b 00             	mov    (%rax),%rax
  800420dc2c:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420dc33:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420dc37:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dc3e:	00 00 00 
  800420dc41:	48 8b 00             	mov    (%rax),%rax
  800420dc44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dc48:	48 89 d6             	mov    %rdx,%rsi
  800420dc4b:	48 89 c7             	mov    %rax,%rdi
  800420dc4e:	48 b8 90 fc 20 04 80 	movabs $0x800420fc90,%rax
  800420dc55:	00 00 00 
  800420dc58:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420dc5a:	48 bf 39 94 21 04 80 	movabs $0x8004219439,%rdi
  800420dc61:	00 00 00 
  800420dc64:	48 b8 36 45 21 04 80 	movabs $0x8004214536,%rax
  800420dc6b:	00 00 00 
  800420dc6e:	ff d0                	callq  *%rax
  800420dc70:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420dc74:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dc7b:	00 00 00 
  800420dc7e:	48 8b 00             	mov    (%rax),%rax
  800420dc81:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dc85:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420dc89:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420dc8d:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dc94:	00 00 00 
  800420dc97:	48 8b 00             	mov    (%rax),%rax
  800420dc9a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420dc9e:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420dca2:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420dca6:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dcad:	00 00 00 
  800420dcb0:	48 8b 00             	mov    (%rax),%rax
  800420dcb3:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420dcb7:	48 85 c0             	test   %rax,%rax
  800420dcba:	75 35                	jne    800420dcf1 <debuginfo_rip+0x276>
  800420dcbc:	48 b9 45 94 21 04 80 	movabs $0x8004219445,%rcx
  800420dcc3:	00 00 00 
  800420dcc6:	48 ba 0c 94 21 04 80 	movabs $0x800421940c,%rdx
  800420dccd:	00 00 00 
  800420dcd0:	be 38 01 00 00       	mov    $0x138,%esi
  800420dcd5:	48 bf 21 94 21 04 80 	movabs $0x8004219421,%rdi
  800420dcdc:	00 00 00 
  800420dcdf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dce4:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420dceb:	00 00 00 
  800420dcee:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420dcf1:	e9 6f 01 00 00       	jmpq   800420de65 <debuginfo_rip+0x3ea>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420dcf6:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dcfd:	00 00 00 
  800420dd00:	48 8b 00             	mov    (%rax),%rax
  800420dd03:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420dd07:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420dd0e:	be 00 00 00 00       	mov    $0x0,%esi
  800420dd13:	48 89 c7             	mov    %rax,%rdi
  800420dd16:	48 b8 18 0e 21 04 80 	movabs $0x8004210e18,%rax
  800420dd1d:	00 00 00 
  800420dd20:	ff d0                	callq  *%rax
  800420dd22:	83 f8 04             	cmp    $0x4,%eax
  800420dd25:	75 05                	jne    800420dd2c <debuginfo_rip+0x2b1>
		{
			continue;
  800420dd27:	e9 39 01 00 00       	jmpq   800420de65 <debuginfo_rip+0x3ea>
		}	
		cudie.cu_header = &cu;
  800420dd2c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dd30:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420dd37:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420dd3e:	00 00 00 00 
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420dd42:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dd49:	00 00 00 
  800420dd4c:	48 8b 00             	mov    (%rax),%rax
  800420dd4f:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420dd56:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420dd5d:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420dd61:	48 89 c7             	mov    %rax,%rdi
  800420dd64:	48 b8 5c 10 21 04 80 	movabs $0x800421105c,%rax
  800420dd6b:	00 00 00 
  800420dd6e:	ff d0                	callq  *%rax
  800420dd70:	83 f8 04             	cmp    $0x4,%eax
  800420dd73:	75 05                	jne    800420dd7a <debuginfo_rip+0x2ff>
		{
			continue;
  800420dd75:	e9 eb 00 00 00       	jmpq   800420de65 <debuginfo_rip+0x3ea>
		}	
		die.cu_header = &cu;
  800420dd7a:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420dd7e:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420dd85:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420dd8c:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420dd93:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420dd9a:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420dda1:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420dda8:	48 89 ce             	mov    %rcx,%rsi
  800420ddab:	48 89 c7             	mov    %rax,%rdi
  800420ddae:	48 b8 15 d3 20 04 80 	movabs $0x800420d315,%rax
  800420ddb5:	00 00 00 
  800420ddb8:	ff d0                	callq  *%rax
  800420ddba:	85 c0                	test   %eax,%eax
  800420ddbc:	74 30                	je     800420ddee <debuginfo_rip+0x373>
				goto find_done;
  800420ddbe:	90                   	nop
    
	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420ddbf:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420ddc6:	00 00 00 
  800420ddc9:	48 8b 00             	mov    (%rax),%rax
  800420ddcc:	be 00 00 00 00       	mov    $0x0,%esi
  800420ddd1:	48 89 c7             	mov    %rax,%rdi
  800420ddd4:	48 b8 43 37 21 04 80 	movabs $0x8004213743,%rax
  800420dddb:	00 00 00 
  800420ddde:	ff d0                	callq  *%rax
  800420dde0:	83 f8 01             	cmp    $0x1,%eax
  800420dde3:	0f 85 bb 00 00 00    	jne    800420dea4 <debuginfo_rip+0x429>
  800420dde9:	e9 ac 00 00 00       	jmpq   800420de9a <debuginfo_rip+0x41f>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ddee:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420ddf5:	00 00 00 
  800420ddf8:	48 8b 00             	mov    (%rax),%rax
  800420ddfb:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420ddff:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420de06:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420de0d:	48 89 c7             	mov    %rax,%rdi
  800420de10:	48 b8 18 0e 21 04 80 	movabs $0x8004210e18,%rax
  800420de17:	00 00 00 
  800420de1a:	ff d0                	callq  *%rax
  800420de1c:	85 c0                	test   %eax,%eax
  800420de1e:	79 02                	jns    800420de22 <debuginfo_rip+0x3a7>
				break; 
  800420de20:	eb 43                	jmp    800420de65 <debuginfo_rip+0x3ea>
			die = die2;
  800420de22:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420de29:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420de30:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420de35:	48 89 ce             	mov    %rcx,%rsi
  800420de38:	48 89 c7             	mov    %rax,%rdi
  800420de3b:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  800420de42:	00 00 00 
  800420de45:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420de47:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420de4b:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420de52:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420de59:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420de60:	e9 2e ff ff ff       	jmpq   800420dd93 <debuginfo_rip+0x318>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420de65:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420de6c:	00 00 00 
  800420de6f:	48 8b 00             	mov    (%rax),%rax
  800420de72:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420de76:	48 89 d6             	mov    %rdx,%rsi
  800420de79:	48 89 c7             	mov    %rax,%rdi
  800420de7c:	48 b8 72 fd 20 04 80 	movabs $0x800420fd72,%rax
  800420de83:	00 00 00 
  800420de86:	ff d0                	callq  *%rax
  800420de88:	85 c0                	test   %eax,%eax
  800420de8a:	0f 84 66 fe ff ff    	je     800420dcf6 <debuginfo_rip+0x27b>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420de90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420de95:	e9 a0 00 00 00       	jmpq   800420df3a <debuginfo_rip+0x4bf>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420de9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420de9f:	e9 96 00 00 00       	jmpq   800420df3a <debuginfo_rip+0x4bf>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420dea4:	48 b8 90 b8 22 04 80 	movabs $0x800422b890,%rax
  800420deab:	00 00 00 
  800420deae:	48 8b 08             	mov    (%rax),%rcx
  800420deb1:	48 b8 88 b8 22 04 80 	movabs $0x800422b888,%rax
  800420deb8:	00 00 00 
  800420debb:	48 8b 10             	mov    (%rax),%rdx
  800420debe:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420dec5:	00 00 00 
  800420dec8:	48 8b 00             	mov    (%rax),%rax
  800420decb:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420ded2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ded8:	48 89 c7             	mov    %rax,%rdi
  800420dedb:	48 b8 9d 12 21 04 80 	movabs $0x800421129d,%rax
  800420dee2:	00 00 00 
  800420dee5:	ff d0                	callq  *%rax
  800420dee7:	85 c0                	test   %eax,%eax
  800420dee9:	75 4a                	jne    800420df35 <debuginfo_rip+0x4ba>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr, &info->reg_table,
  800420deeb:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420def2:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420def9:	48 b8 88 b8 22 04 80 	movabs $0x800422b888,%rax
  800420df00:	00 00 00 
  800420df03:	48 8b 30             	mov    (%rax),%rsi
  800420df06:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800420df0d:	00 00 00 
  800420df10:	48 8b 00             	mov    (%rax),%rax
  800420df13:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420df1a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420df20:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420df26:	48 89 c7             	mov    %rax,%rdi
  800420df29:	48 b8 be 25 21 04 80 	movabs $0x80042125be,%rax
  800420df30:	00 00 00 
  800420df33:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420df35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420df3a:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420df41:	5b                   	pop    %rbx
  800420df42:	5d                   	pop    %rbp
  800420df43:	c3                   	retq   

000000800420df44 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420df44:	55                   	push   %rbp
  800420df45:	48 89 e5             	mov    %rsp,%rbp
  800420df48:	53                   	push   %rbx
  800420df49:	48 83 ec 38          	sub    $0x38,%rsp
  800420df4d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420df51:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420df55:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420df59:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420df5c:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420df60:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420df64:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420df67:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420df6b:	77 3b                	ja     800420dfa8 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420df6d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420df70:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420df74:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420df77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420df7b:	ba 00 00 00 00       	mov    $0x0,%edx
  800420df80:	48 f7 f3             	div    %rbx
  800420df83:	48 89 c2             	mov    %rax,%rdx
  800420df86:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420df89:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420df8c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420df90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df94:	41 89 f9             	mov    %edi,%r9d
  800420df97:	48 89 c7             	mov    %rax,%rdi
  800420df9a:	48 b8 44 df 20 04 80 	movabs $0x800420df44,%rax
  800420dfa1:	00 00 00 
  800420dfa4:	ff d0                	callq  *%rax
  800420dfa6:	eb 1e                	jmp    800420dfc6 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420dfa8:	eb 12                	jmp    800420dfbc <printnum+0x78>
			putch(padc, putdat);
  800420dfaa:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420dfae:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420dfb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfb5:	48 89 ce             	mov    %rcx,%rsi
  800420dfb8:	89 d7                	mov    %edx,%edi
  800420dfba:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420dfbc:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420dfc0:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420dfc4:	7f e4                	jg     800420dfaa <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420dfc6:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420dfc9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dfcd:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dfd2:	48 f7 f1             	div    %rcx
  800420dfd5:	48 89 d0             	mov    %rdx,%rax
  800420dfd8:	48 ba 50 96 21 04 80 	movabs $0x8004219650,%rdx
  800420dfdf:	00 00 00 
  800420dfe2:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420dfe6:	0f be d0             	movsbl %al,%edx
  800420dfe9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420dfed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dff1:	48 89 ce             	mov    %rcx,%rsi
  800420dff4:	89 d7                	mov    %edx,%edi
  800420dff6:	ff d0                	callq  *%rax
}
  800420dff8:	48 83 c4 38          	add    $0x38,%rsp
  800420dffc:	5b                   	pop    %rbx
  800420dffd:	5d                   	pop    %rbp
  800420dffe:	c3                   	retq   

000000800420dfff <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420dfff:	55                   	push   %rbp
  800420e000:	48 89 e5             	mov    %rsp,%rbp
  800420e003:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420e007:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e00b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420e00e:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420e012:	7e 52                	jle    800420e066 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420e014:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e018:	8b 00                	mov    (%rax),%eax
  800420e01a:	83 f8 30             	cmp    $0x30,%eax
  800420e01d:	73 24                	jae    800420e043 <getuint+0x44>
  800420e01f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e023:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e027:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e02b:	8b 00                	mov    (%rax),%eax
  800420e02d:	89 c0                	mov    %eax,%eax
  800420e02f:	48 01 d0             	add    %rdx,%rax
  800420e032:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e036:	8b 12                	mov    (%rdx),%edx
  800420e038:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e03b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e03f:	89 0a                	mov    %ecx,(%rdx)
  800420e041:	eb 17                	jmp    800420e05a <getuint+0x5b>
  800420e043:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e047:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e04b:	48 89 d0             	mov    %rdx,%rax
  800420e04e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e052:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e056:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e05a:	48 8b 00             	mov    (%rax),%rax
  800420e05d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e061:	e9 a3 00 00 00       	jmpq   800420e109 <getuint+0x10a>
	else if (lflag)
  800420e066:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e06a:	74 4f                	je     800420e0bb <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420e06c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e070:	8b 00                	mov    (%rax),%eax
  800420e072:	83 f8 30             	cmp    $0x30,%eax
  800420e075:	73 24                	jae    800420e09b <getuint+0x9c>
  800420e077:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e07b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e07f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e083:	8b 00                	mov    (%rax),%eax
  800420e085:	89 c0                	mov    %eax,%eax
  800420e087:	48 01 d0             	add    %rdx,%rax
  800420e08a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e08e:	8b 12                	mov    (%rdx),%edx
  800420e090:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e093:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e097:	89 0a                	mov    %ecx,(%rdx)
  800420e099:	eb 17                	jmp    800420e0b2 <getuint+0xb3>
  800420e09b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e09f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e0a3:	48 89 d0             	mov    %rdx,%rax
  800420e0a6:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e0aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0ae:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e0b2:	48 8b 00             	mov    (%rax),%rax
  800420e0b5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e0b9:	eb 4e                	jmp    800420e109 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420e0bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0bf:	8b 00                	mov    (%rax),%eax
  800420e0c1:	83 f8 30             	cmp    $0x30,%eax
  800420e0c4:	73 24                	jae    800420e0ea <getuint+0xeb>
  800420e0c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0ca:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e0ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0d2:	8b 00                	mov    (%rax),%eax
  800420e0d4:	89 c0                	mov    %eax,%eax
  800420e0d6:	48 01 d0             	add    %rdx,%rax
  800420e0d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0dd:	8b 12                	mov    (%rdx),%edx
  800420e0df:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e0e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0e6:	89 0a                	mov    %ecx,(%rdx)
  800420e0e8:	eb 17                	jmp    800420e101 <getuint+0x102>
  800420e0ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e0ee:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e0f2:	48 89 d0             	mov    %rdx,%rax
  800420e0f5:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e0f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e0fd:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e101:	8b 00                	mov    (%rax),%eax
  800420e103:	89 c0                	mov    %eax,%eax
  800420e105:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e109:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e10d:	c9                   	leaveq 
  800420e10e:	c3                   	retq   

000000800420e10f <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420e10f:	55                   	push   %rbp
  800420e110:	48 89 e5             	mov    %rsp,%rbp
  800420e113:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420e117:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e11b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420e11e:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420e122:	7e 52                	jle    800420e176 <getint+0x67>
		x=va_arg(*ap, long long);
  800420e124:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e128:	8b 00                	mov    (%rax),%eax
  800420e12a:	83 f8 30             	cmp    $0x30,%eax
  800420e12d:	73 24                	jae    800420e153 <getint+0x44>
  800420e12f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e133:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e137:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e13b:	8b 00                	mov    (%rax),%eax
  800420e13d:	89 c0                	mov    %eax,%eax
  800420e13f:	48 01 d0             	add    %rdx,%rax
  800420e142:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e146:	8b 12                	mov    (%rdx),%edx
  800420e148:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e14b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e14f:	89 0a                	mov    %ecx,(%rdx)
  800420e151:	eb 17                	jmp    800420e16a <getint+0x5b>
  800420e153:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e157:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e15b:	48 89 d0             	mov    %rdx,%rax
  800420e15e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e162:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e166:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e16a:	48 8b 00             	mov    (%rax),%rax
  800420e16d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e171:	e9 a3 00 00 00       	jmpq   800420e219 <getint+0x10a>
	else if (lflag)
  800420e176:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420e17a:	74 4f                	je     800420e1cb <getint+0xbc>
		x=va_arg(*ap, long);
  800420e17c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e180:	8b 00                	mov    (%rax),%eax
  800420e182:	83 f8 30             	cmp    $0x30,%eax
  800420e185:	73 24                	jae    800420e1ab <getint+0x9c>
  800420e187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e18b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e18f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e193:	8b 00                	mov    (%rax),%eax
  800420e195:	89 c0                	mov    %eax,%eax
  800420e197:	48 01 d0             	add    %rdx,%rax
  800420e19a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e19e:	8b 12                	mov    (%rdx),%edx
  800420e1a0:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e1a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1a7:	89 0a                	mov    %ecx,(%rdx)
  800420e1a9:	eb 17                	jmp    800420e1c2 <getint+0xb3>
  800420e1ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1af:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e1b3:	48 89 d0             	mov    %rdx,%rax
  800420e1b6:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e1ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1be:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e1c2:	48 8b 00             	mov    (%rax),%rax
  800420e1c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e1c9:	eb 4e                	jmp    800420e219 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420e1cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1cf:	8b 00                	mov    (%rax),%eax
  800420e1d1:	83 f8 30             	cmp    $0x30,%eax
  800420e1d4:	73 24                	jae    800420e1fa <getint+0xeb>
  800420e1d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1da:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e1de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1e2:	8b 00                	mov    (%rax),%eax
  800420e1e4:	89 c0                	mov    %eax,%eax
  800420e1e6:	48 01 d0             	add    %rdx,%rax
  800420e1e9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1ed:	8b 12                	mov    (%rdx),%edx
  800420e1ef:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e1f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e1f6:	89 0a                	mov    %ecx,(%rdx)
  800420e1f8:	eb 17                	jmp    800420e211 <getint+0x102>
  800420e1fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e1fe:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420e202:	48 89 d0             	mov    %rdx,%rax
  800420e205:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420e209:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e20d:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e211:	8b 00                	mov    (%rax),%eax
  800420e213:	48 98                	cltq   
  800420e215:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e219:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e21d:	c9                   	leaveq 
  800420e21e:	c3                   	retq   

000000800420e21f <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420e21f:	55                   	push   %rbp
  800420e220:	48 89 e5             	mov    %rsp,%rbp
  800420e223:	41 54                	push   %r12
  800420e225:	53                   	push   %rbx
  800420e226:	48 83 ec 60          	sub    $0x60,%rsp
  800420e22a:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420e22e:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420e232:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e236:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420e23a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e23e:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e242:	48 8b 0a             	mov    (%rdx),%rcx
  800420e245:	48 89 08             	mov    %rcx,(%rax)
  800420e248:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e24c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e250:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e254:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e258:	eb 28                	jmp    800420e282 <vprintfmt+0x63>
			if (ch == '\0'){
  800420e25a:	85 db                	test   %ebx,%ebx
  800420e25c:	75 15                	jne    800420e273 <vprintfmt+0x54>
				current_color=WHITE;
  800420e25e:	48 b8 60 57 37 04 80 	movabs $0x8004375760,%rax
  800420e265:	00 00 00 
  800420e268:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
  800420e26e:	e9 fc 04 00 00       	jmpq   800420e76f <vprintfmt+0x550>
				return;
			}
				
			putch(ch, putdat);
  800420e273:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e277:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e27b:	48 89 d6             	mov    %rdx,%rsi
  800420e27e:	89 df                	mov    %ebx,%edi
  800420e280:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e282:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e286:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e28a:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e28e:	0f b6 00             	movzbl (%rax),%eax
  800420e291:	0f b6 d8             	movzbl %al,%ebx
  800420e294:	83 fb 25             	cmp    $0x25,%ebx
  800420e297:	75 c1                	jne    800420e25a <vprintfmt+0x3b>
				
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420e299:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420e29d:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420e2a4:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420e2ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420e2b2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420e2b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e2bd:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e2c1:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e2c5:	0f b6 00             	movzbl (%rax),%eax
  800420e2c8:	0f b6 d8             	movzbl %al,%ebx
  800420e2cb:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420e2ce:	83 f8 55             	cmp    $0x55,%eax
  800420e2d1:	0f 87 64 04 00 00    	ja     800420e73b <vprintfmt+0x51c>
  800420e2d7:	89 c0                	mov    %eax,%eax
  800420e2d9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e2e0:	00 
  800420e2e1:	48 b8 78 96 21 04 80 	movabs $0x8004219678,%rax
  800420e2e8:	00 00 00 
  800420e2eb:	48 01 d0             	add    %rdx,%rax
  800420e2ee:	48 8b 00             	mov    (%rax),%rax
  800420e2f1:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420e2f3:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420e2f7:	eb c0                	jmp    800420e2b9 <vprintfmt+0x9a>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420e2f9:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420e2fd:	eb ba                	jmp    800420e2b9 <vprintfmt+0x9a>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e2ff:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420e306:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420e309:	89 d0                	mov    %edx,%eax
  800420e30b:	c1 e0 02             	shl    $0x2,%eax
  800420e30e:	01 d0                	add    %edx,%eax
  800420e310:	01 c0                	add    %eax,%eax
  800420e312:	01 d8                	add    %ebx,%eax
  800420e314:	83 e8 30             	sub    $0x30,%eax
  800420e317:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420e31a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e31e:	0f b6 00             	movzbl (%rax),%eax
  800420e321:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420e324:	83 fb 2f             	cmp    $0x2f,%ebx
  800420e327:	7e 0c                	jle    800420e335 <vprintfmt+0x116>
  800420e329:	83 fb 39             	cmp    $0x39,%ebx
  800420e32c:	7f 07                	jg     800420e335 <vprintfmt+0x116>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e32e:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420e333:	eb d1                	jmp    800420e306 <vprintfmt+0xe7>
			goto process_precision;
  800420e335:	eb 58                	jmp    800420e38f <vprintfmt+0x170>

		case '*':
			precision = va_arg(aq, int);
  800420e337:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e33a:	83 f8 30             	cmp    $0x30,%eax
  800420e33d:	73 17                	jae    800420e356 <vprintfmt+0x137>
  800420e33f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e343:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e346:	89 c0                	mov    %eax,%eax
  800420e348:	48 01 d0             	add    %rdx,%rax
  800420e34b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e34e:	83 c2 08             	add    $0x8,%edx
  800420e351:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e354:	eb 0f                	jmp    800420e365 <vprintfmt+0x146>
  800420e356:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e35a:	48 89 d0             	mov    %rdx,%rax
  800420e35d:	48 83 c2 08          	add    $0x8,%rdx
  800420e361:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e365:	8b 00                	mov    (%rax),%eax
  800420e367:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420e36a:	eb 23                	jmp    800420e38f <vprintfmt+0x170>

		case '.':
			if (width < 0)
  800420e36c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e370:	79 0c                	jns    800420e37e <vprintfmt+0x15f>
				width = 0;
  800420e372:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420e379:	e9 3b ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>
  800420e37e:	e9 36 ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>

		case '#':
			altflag = 1;
  800420e383:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420e38a:	e9 2a ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>

		process_precision:
			if (width < 0)
  800420e38f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e393:	79 12                	jns    800420e3a7 <vprintfmt+0x188>
				width = precision, precision = -1;
  800420e395:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e398:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420e39b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420e3a2:	e9 12 ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>
  800420e3a7:	e9 0d ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420e3ac:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420e3b0:	e9 04 ff ff ff       	jmpq   800420e2b9 <vprintfmt+0x9a>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420e3b5:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e3b8:	83 f8 30             	cmp    $0x30,%eax
  800420e3bb:	73 17                	jae    800420e3d4 <vprintfmt+0x1b5>
  800420e3bd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e3c1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e3c4:	89 c0                	mov    %eax,%eax
  800420e3c6:	48 01 d0             	add    %rdx,%rax
  800420e3c9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e3cc:	83 c2 08             	add    $0x8,%edx
  800420e3cf:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e3d2:	eb 0f                	jmp    800420e3e3 <vprintfmt+0x1c4>
  800420e3d4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e3d8:	48 89 d0             	mov    %rdx,%rax
  800420e3db:	48 83 c2 08          	add    $0x8,%rdx
  800420e3df:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e3e3:	8b 10                	mov    (%rax),%edx
  800420e3e5:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e3e9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e3ed:	48 89 ce             	mov    %rcx,%rsi
  800420e3f0:	89 d7                	mov    %edx,%edi
  800420e3f2:	ff d0                	callq  *%rax
			break;
  800420e3f4:	e9 70 03 00 00       	jmpq   800420e769 <vprintfmt+0x54a>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420e3f9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e3fc:	83 f8 30             	cmp    $0x30,%eax
  800420e3ff:	73 17                	jae    800420e418 <vprintfmt+0x1f9>
  800420e401:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e405:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e408:	89 c0                	mov    %eax,%eax
  800420e40a:	48 01 d0             	add    %rdx,%rax
  800420e40d:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e410:	83 c2 08             	add    $0x8,%edx
  800420e413:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e416:	eb 0f                	jmp    800420e427 <vprintfmt+0x208>
  800420e418:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e41c:	48 89 d0             	mov    %rdx,%rax
  800420e41f:	48 83 c2 08          	add    $0x8,%rdx
  800420e423:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e427:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420e429:	85 db                	test   %ebx,%ebx
  800420e42b:	79 02                	jns    800420e42f <vprintfmt+0x210>
				err = -err;
  800420e42d:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420e42f:	83 fb 15             	cmp    $0x15,%ebx
  800420e432:	7f 16                	jg     800420e44a <vprintfmt+0x22b>
  800420e434:	48 b8 a0 95 21 04 80 	movabs $0x80042195a0,%rax
  800420e43b:	00 00 00 
  800420e43e:	48 63 d3             	movslq %ebx,%rdx
  800420e441:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420e445:	4d 85 e4             	test   %r12,%r12
  800420e448:	75 2e                	jne    800420e478 <vprintfmt+0x259>
				printfmt(putch, putdat, "error %d", err);
  800420e44a:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e44e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e452:	89 d9                	mov    %ebx,%ecx
  800420e454:	48 ba 61 96 21 04 80 	movabs $0x8004219661,%rdx
  800420e45b:	00 00 00 
  800420e45e:	48 89 c7             	mov    %rax,%rdi
  800420e461:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e466:	49 b8 78 e7 20 04 80 	movabs $0x800420e778,%r8
  800420e46d:	00 00 00 
  800420e470:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420e473:	e9 f1 02 00 00       	jmpq   800420e769 <vprintfmt+0x54a>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420e478:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e47c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e480:	4c 89 e1             	mov    %r12,%rcx
  800420e483:	48 ba 6a 96 21 04 80 	movabs $0x800421966a,%rdx
  800420e48a:	00 00 00 
  800420e48d:	48 89 c7             	mov    %rax,%rdi
  800420e490:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e495:	49 b8 78 e7 20 04 80 	movabs $0x800420e778,%r8
  800420e49c:	00 00 00 
  800420e49f:	41 ff d0             	callq  *%r8
			break;
  800420e4a2:	e9 c2 02 00 00       	jmpq   800420e769 <vprintfmt+0x54a>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420e4a7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e4aa:	83 f8 30             	cmp    $0x30,%eax
  800420e4ad:	73 17                	jae    800420e4c6 <vprintfmt+0x2a7>
  800420e4af:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e4b3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e4b6:	89 c0                	mov    %eax,%eax
  800420e4b8:	48 01 d0             	add    %rdx,%rax
  800420e4bb:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e4be:	83 c2 08             	add    $0x8,%edx
  800420e4c1:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e4c4:	eb 0f                	jmp    800420e4d5 <vprintfmt+0x2b6>
  800420e4c6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e4ca:	48 89 d0             	mov    %rdx,%rax
  800420e4cd:	48 83 c2 08          	add    $0x8,%rdx
  800420e4d1:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e4d5:	4c 8b 20             	mov    (%rax),%r12
  800420e4d8:	4d 85 e4             	test   %r12,%r12
  800420e4db:	75 0a                	jne    800420e4e7 <vprintfmt+0x2c8>
				p = "(null)";
  800420e4dd:	49 bc 6d 96 21 04 80 	movabs $0x800421966d,%r12
  800420e4e4:	00 00 00 
			if (width > 0 && padc != '-')
  800420e4e7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e4eb:	7e 3f                	jle    800420e52c <vprintfmt+0x30d>
  800420e4ed:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420e4f1:	74 39                	je     800420e52c <vprintfmt+0x30d>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e4f3:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e4f6:	48 98                	cltq   
  800420e4f8:	48 89 c6             	mov    %rax,%rsi
  800420e4fb:	4c 89 e7             	mov    %r12,%rdi
  800420e4fe:	48 b8 79 eb 20 04 80 	movabs $0x800420eb79,%rax
  800420e505:	00 00 00 
  800420e508:	ff d0                	callq  *%rax
  800420e50a:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420e50d:	eb 17                	jmp    800420e526 <vprintfmt+0x307>
					putch(padc, putdat);
  800420e50f:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420e513:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e517:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e51b:	48 89 ce             	mov    %rcx,%rsi
  800420e51e:	89 d7                	mov    %edx,%edi
  800420e520:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e522:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e526:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e52a:	7f e3                	jg     800420e50f <vprintfmt+0x2f0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e52c:	eb 37                	jmp    800420e565 <vprintfmt+0x346>
				if (altflag && (ch < ' ' || ch > '~'))
  800420e52e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420e532:	74 1e                	je     800420e552 <vprintfmt+0x333>
  800420e534:	83 fb 1f             	cmp    $0x1f,%ebx
  800420e537:	7e 05                	jle    800420e53e <vprintfmt+0x31f>
  800420e539:	83 fb 7e             	cmp    $0x7e,%ebx
  800420e53c:	7e 14                	jle    800420e552 <vprintfmt+0x333>
					putch('?', putdat);
  800420e53e:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e542:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e546:	48 89 d6             	mov    %rdx,%rsi
  800420e549:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420e54e:	ff d0                	callq  *%rax
  800420e550:	eb 0f                	jmp    800420e561 <vprintfmt+0x342>
				else
					putch(ch, putdat);
  800420e552:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e556:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e55a:	48 89 d6             	mov    %rdx,%rsi
  800420e55d:	89 df                	mov    %ebx,%edi
  800420e55f:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e561:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e565:	4c 89 e0             	mov    %r12,%rax
  800420e568:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420e56c:	0f b6 00             	movzbl (%rax),%eax
  800420e56f:	0f be d8             	movsbl %al,%ebx
  800420e572:	85 db                	test   %ebx,%ebx
  800420e574:	74 10                	je     800420e586 <vprintfmt+0x367>
  800420e576:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e57a:	78 b2                	js     800420e52e <vprintfmt+0x30f>
  800420e57c:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420e580:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e584:	79 a8                	jns    800420e52e <vprintfmt+0x30f>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e586:	eb 16                	jmp    800420e59e <vprintfmt+0x37f>
				putch(' ', putdat);
  800420e588:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e58c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e590:	48 89 d6             	mov    %rdx,%rsi
  800420e593:	bf 20 00 00 00       	mov    $0x20,%edi
  800420e598:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e59a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e59e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e5a2:	7f e4                	jg     800420e588 <vprintfmt+0x369>
				putch(' ', putdat);
			break;
  800420e5a4:	e9 c0 01 00 00       	jmpq   800420e769 <vprintfmt+0x54a>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420e5a9:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e5ad:	be 03 00 00 00       	mov    $0x3,%esi
  800420e5b2:	48 89 c7             	mov    %rax,%rdi
  800420e5b5:	48 b8 0f e1 20 04 80 	movabs $0x800420e10f,%rax
  800420e5bc:	00 00 00 
  800420e5bf:	ff d0                	callq  *%rax
  800420e5c1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e5c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5c9:	48 85 c0             	test   %rax,%rax
  800420e5cc:	79 1d                	jns    800420e5eb <vprintfmt+0x3cc>
				putch('-', putdat);
  800420e5ce:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e5d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e5d6:	48 89 d6             	mov    %rdx,%rsi
  800420e5d9:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e5de:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e5e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5e4:	48 f7 d8             	neg    %rax
  800420e5e7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420e5eb:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e5f2:	e9 d5 00 00 00       	jmpq   800420e6cc <vprintfmt+0x4ad>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420e5f7:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e5fb:	be 03 00 00 00       	mov    $0x3,%esi
  800420e600:	48 89 c7             	mov    %rax,%rdi
  800420e603:	48 b8 ff df 20 04 80 	movabs $0x800420dfff,%rax
  800420e60a:	00 00 00 
  800420e60d:	ff d0                	callq  *%rax
  800420e60f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420e613:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e61a:	e9 ad 00 00 00       	jmpq   800420e6cc <vprintfmt+0x4ad>
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			// break;
			num = getuint(&aq, 3);
  800420e61f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e623:	be 03 00 00 00       	mov    $0x3,%esi
  800420e628:	48 89 c7             	mov    %rax,%rdi
  800420e62b:	48 b8 ff df 20 04 80 	movabs $0x800420dfff,%rax
  800420e632:	00 00 00 
  800420e635:	ff d0                	callq  *%rax
  800420e637:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420e63b:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420e642:	e9 85 00 00 00       	jmpq   800420e6cc <vprintfmt+0x4ad>

			// pointer
		case 'p':
			putch('0', putdat);
  800420e647:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e64b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e64f:	48 89 d6             	mov    %rdx,%rsi
  800420e652:	bf 30 00 00 00       	mov    $0x30,%edi
  800420e657:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420e659:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e65d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e661:	48 89 d6             	mov    %rdx,%rsi
  800420e664:	bf 78 00 00 00       	mov    $0x78,%edi
  800420e669:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420e66b:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e66e:	83 f8 30             	cmp    $0x30,%eax
  800420e671:	73 17                	jae    800420e68a <vprintfmt+0x46b>
  800420e673:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420e677:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e67a:	89 c0                	mov    %eax,%eax
  800420e67c:	48 01 d0             	add    %rdx,%rax
  800420e67f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e682:	83 c2 08             	add    $0x8,%edx
  800420e685:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e688:	eb 0f                	jmp    800420e699 <vprintfmt+0x47a>
				(uintptr_t) va_arg(aq, void *);
  800420e68a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e68e:	48 89 d0             	mov    %rdx,%rax
  800420e691:	48 83 c2 08          	add    $0x8,%rdx
  800420e695:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e699:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e69c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420e6a0:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420e6a7:	eb 23                	jmp    800420e6cc <vprintfmt+0x4ad>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420e6a9:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e6ad:	be 03 00 00 00       	mov    $0x3,%esi
  800420e6b2:	48 89 c7             	mov    %rax,%rdi
  800420e6b5:	48 b8 ff df 20 04 80 	movabs $0x800420dfff,%rax
  800420e6bc:	00 00 00 
  800420e6bf:	ff d0                	callq  *%rax
  800420e6c1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420e6c5:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420e6cc:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420e6d1:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420e6d4:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420e6d7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e6db:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e6df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e6e3:	45 89 c1             	mov    %r8d,%r9d
  800420e6e6:	41 89 f8             	mov    %edi,%r8d
  800420e6e9:	48 89 c7             	mov    %rax,%rdi
  800420e6ec:	48 b8 44 df 20 04 80 	movabs $0x800420df44,%rax
  800420e6f3:	00 00 00 
  800420e6f6:	ff d0                	callq  *%rax
			break;
  800420e6f8:	eb 6f                	jmp    800420e769 <vprintfmt+0x54a>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420e6fa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e6fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e702:	48 89 d6             	mov    %rdx,%rsi
  800420e705:	89 df                	mov    %ebx,%edi
  800420e707:	ff d0                	callq  *%rax
			break;
  800420e709:	eb 5e                	jmp    800420e769 <vprintfmt+0x54a>
		
		case 'C':
		    num=getuint(&aq,3);		
  800420e70b:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e70f:	be 03 00 00 00       	mov    $0x3,%esi
  800420e714:	48 89 c7             	mov    %rax,%rdi
  800420e717:	48 b8 ff df 20 04 80 	movabs $0x800420dfff,%rax
  800420e71e:	00 00 00 
  800420e721:	ff d0                	callq  *%rax
  800420e723:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			current_color=num;
  800420e727:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e72b:	89 c2                	mov    %eax,%edx
  800420e72d:	48 b8 60 57 37 04 80 	movabs $0x8004375760,%rax
  800420e734:	00 00 00 
  800420e737:	89 10                	mov    %edx,(%rax)
			break;
  800420e739:	eb 2e                	jmp    800420e769 <vprintfmt+0x54a>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420e73b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e73f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e743:	48 89 d6             	mov    %rdx,%rsi
  800420e746:	bf 25 00 00 00       	mov    $0x25,%edi
  800420e74b:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420e74d:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e752:	eb 05                	jmp    800420e759 <vprintfmt+0x53a>
  800420e754:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e759:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e75d:	48 83 e8 01          	sub    $0x1,%rax
  800420e761:	0f b6 00             	movzbl (%rax),%eax
  800420e764:	3c 25                	cmp    $0x25,%al
  800420e766:	75 ec                	jne    800420e754 <vprintfmt+0x535>
				/* do nothing */;
			break;
  800420e768:	90                   	nop
		}
	}
  800420e769:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e76a:	e9 13 fb ff ff       	jmpq   800420e282 <vprintfmt+0x63>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420e76f:	48 83 c4 60          	add    $0x60,%rsp
  800420e773:	5b                   	pop    %rbx
  800420e774:	41 5c                	pop    %r12
  800420e776:	5d                   	pop    %rbp
  800420e777:	c3                   	retq   

000000800420e778 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420e778:	55                   	push   %rbp
  800420e779:	48 89 e5             	mov    %rsp,%rbp
  800420e77c:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420e783:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420e78a:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420e791:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e798:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e79f:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e7a6:	84 c0                	test   %al,%al
  800420e7a8:	74 20                	je     800420e7ca <printfmt+0x52>
  800420e7aa:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e7ae:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e7b2:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e7b6:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e7ba:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e7be:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e7c2:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e7c6:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e7ca:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420e7d1:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420e7d8:	00 00 00 
  800420e7db:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420e7e2:	00 00 00 
  800420e7e5:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e7e9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420e7f0:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e7f7:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420e7fe:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e805:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e80c:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e813:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e81a:	48 89 c7             	mov    %rax,%rdi
  800420e81d:	48 b8 1f e2 20 04 80 	movabs $0x800420e21f,%rax
  800420e824:	00 00 00 
  800420e827:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e829:	c9                   	leaveq 
  800420e82a:	c3                   	retq   

000000800420e82b <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e82b:	55                   	push   %rbp
  800420e82c:	48 89 e5             	mov    %rsp,%rbp
  800420e82f:	48 83 ec 10          	sub    $0x10,%rsp
  800420e833:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e836:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e83a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e83e:	8b 40 10             	mov    0x10(%rax),%eax
  800420e841:	8d 50 01             	lea    0x1(%rax),%edx
  800420e844:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e848:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e84b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e84f:	48 8b 10             	mov    (%rax),%rdx
  800420e852:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e856:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e85a:	48 39 c2             	cmp    %rax,%rdx
  800420e85d:	73 17                	jae    800420e876 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e85f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e863:	48 8b 00             	mov    (%rax),%rax
  800420e866:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420e86a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e86e:	48 89 0a             	mov    %rcx,(%rdx)
  800420e871:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e874:	88 10                	mov    %dl,(%rax)
}
  800420e876:	c9                   	leaveq 
  800420e877:	c3                   	retq   

000000800420e878 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e878:	55                   	push   %rbp
  800420e879:	48 89 e5             	mov    %rsp,%rbp
  800420e87c:	48 83 ec 50          	sub    $0x50,%rsp
  800420e880:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e884:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e887:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e88b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e88f:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e893:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e897:	48 8b 0a             	mov    (%rdx),%rcx
  800420e89a:	48 89 08             	mov    %rcx,(%rax)
  800420e89d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e8a1:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e8a5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e8a9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e8ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e8b1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e8b5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e8b8:	48 98                	cltq   
  800420e8ba:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e8be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e8c2:	48 01 d0             	add    %rdx,%rax
  800420e8c5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e8c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e8d0:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e8d5:	74 06                	je     800420e8dd <vsnprintf+0x65>
  800420e8d7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e8db:	7f 07                	jg     800420e8e4 <vsnprintf+0x6c>
		return -E_INVAL;
  800420e8dd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e8e2:	eb 2f                	jmp    800420e913 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e8e4:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e8e8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e8ec:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e8f0:	48 89 c6             	mov    %rax,%rsi
  800420e8f3:	48 bf 2b e8 20 04 80 	movabs $0x800420e82b,%rdi
  800420e8fa:	00 00 00 
  800420e8fd:	48 b8 1f e2 20 04 80 	movabs $0x800420e21f,%rax
  800420e904:	00 00 00 
  800420e907:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e909:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e90d:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e910:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e913:	c9                   	leaveq 
  800420e914:	c3                   	retq   

000000800420e915 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e915:	55                   	push   %rbp
  800420e916:	48 89 e5             	mov    %rsp,%rbp
  800420e919:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e920:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e927:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e92d:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e934:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e93b:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e942:	84 c0                	test   %al,%al
  800420e944:	74 20                	je     800420e966 <snprintf+0x51>
  800420e946:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e94a:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e94e:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e952:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e956:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e95a:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e95e:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e962:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e966:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e96d:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e974:	00 00 00 
  800420e977:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e97e:	00 00 00 
  800420e981:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e985:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e98c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e993:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e99a:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e9a1:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e9a8:	48 8b 0a             	mov    (%rdx),%rcx
  800420e9ab:	48 89 08             	mov    %rcx,(%rax)
  800420e9ae:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e9b2:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e9b6:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e9ba:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e9be:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e9c5:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e9cc:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e9d2:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e9d9:	48 89 c7             	mov    %rax,%rdi
  800420e9dc:	48 b8 78 e8 20 04 80 	movabs $0x800420e878,%rax
  800420e9e3:	00 00 00 
  800420e9e6:	ff d0                	callq  *%rax
  800420e9e8:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e9ee:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e9f4:	c9                   	leaveq 
  800420e9f5:	c3                   	retq   

000000800420e9f6 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e9f6:	55                   	push   %rbp
  800420e9f7:	48 89 e5             	mov    %rsp,%rbp
  800420e9fa:	48 83 ec 20          	sub    $0x20,%rsp
  800420e9fe:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420ea02:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ea07:	74 22                	je     800420ea2b <readline+0x35>
		cprintf("%s", prompt);
  800420ea09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea0d:	48 89 c6             	mov    %rax,%rsi
  800420ea10:	48 bf 28 99 21 04 80 	movabs $0x8004219928,%rdi
  800420ea17:	00 00 00 
  800420ea1a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea1f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420ea26:	00 00 00 
  800420ea29:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420ea2b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420ea32:	bf 00 00 00 00       	mov    $0x0,%edi
  800420ea37:	48 b8 a0 13 20 04 80 	movabs $0x80042013a0,%rax
  800420ea3e:	00 00 00 
  800420ea41:	ff d0                	callq  *%rax
  800420ea43:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420ea46:	48 b8 7e 13 20 04 80 	movabs $0x800420137e,%rax
  800420ea4d:	00 00 00 
  800420ea50:	ff d0                	callq  *%rax
  800420ea52:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420ea55:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420ea59:	79 30                	jns    800420ea8b <readline+0x95>
			if (c != -E_EOF)
  800420ea5b:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420ea5f:	74 20                	je     800420ea81 <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420ea61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ea64:	89 c6                	mov    %eax,%esi
  800420ea66:	48 bf 2b 99 21 04 80 	movabs $0x800421992b,%rdi
  800420ea6d:	00 00 00 
  800420ea70:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea75:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800420ea7c:	00 00 00 
  800420ea7f:	ff d2                	callq  *%rdx
			return NULL;
  800420ea81:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea86:	e9 be 00 00 00       	jmpq   800420eb49 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420ea8b:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420ea8f:	74 06                	je     800420ea97 <readline+0xa1>
  800420ea91:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420ea95:	75 26                	jne    800420eabd <readline+0xc7>
  800420ea97:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ea9b:	7e 20                	jle    800420eabd <readline+0xc7>
			if (echoing)
  800420ea9d:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420eaa1:	74 11                	je     800420eab4 <readline+0xbe>
				cputchar('\b');
  800420eaa3:	bf 08 00 00 00       	mov    $0x8,%edi
  800420eaa8:	48 b8 60 13 20 04 80 	movabs $0x8004201360,%rax
  800420eaaf:	00 00 00 
  800420eab2:	ff d0                	callq  *%rax
			i--;
  800420eab4:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420eab8:	e9 87 00 00 00       	jmpq   800420eb44 <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420eabd:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420eac1:	7e 3f                	jle    800420eb02 <readline+0x10c>
  800420eac3:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420eaca:	7f 36                	jg     800420eb02 <readline+0x10c>
			if (echoing)
  800420eacc:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420ead0:	74 11                	je     800420eae3 <readline+0xed>
				cputchar(c);
  800420ead2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ead5:	89 c7                	mov    %eax,%edi
  800420ead7:	48 b8 60 13 20 04 80 	movabs $0x8004201360,%rax
  800420eade:	00 00 00 
  800420eae1:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420eae3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420eae6:	8d 50 01             	lea    0x1(%rax),%edx
  800420eae9:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420eaec:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420eaef:	89 d1                	mov    %edx,%ecx
  800420eaf1:	48 ba a0 52 37 04 80 	movabs $0x80043752a0,%rdx
  800420eaf8:	00 00 00 
  800420eafb:	48 98                	cltq   
  800420eafd:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420eb00:	eb 42                	jmp    800420eb44 <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420eb02:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420eb06:	74 06                	je     800420eb0e <readline+0x118>
  800420eb08:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420eb0c:	75 36                	jne    800420eb44 <readline+0x14e>
			if (echoing)
  800420eb0e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420eb12:	74 11                	je     800420eb25 <readline+0x12f>
				cputchar('\n');
  800420eb14:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420eb19:	48 b8 60 13 20 04 80 	movabs $0x8004201360,%rax
  800420eb20:	00 00 00 
  800420eb23:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420eb25:	48 ba a0 52 37 04 80 	movabs $0x80043752a0,%rdx
  800420eb2c:	00 00 00 
  800420eb2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420eb32:	48 98                	cltq   
  800420eb34:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420eb38:	48 b8 a0 52 37 04 80 	movabs $0x80043752a0,%rax
  800420eb3f:	00 00 00 
  800420eb42:	eb 05                	jmp    800420eb49 <readline+0x153>
		}
	}
  800420eb44:	e9 fd fe ff ff       	jmpq   800420ea46 <readline+0x50>
}
  800420eb49:	c9                   	leaveq 
  800420eb4a:	c3                   	retq   

000000800420eb4b <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420eb4b:	55                   	push   %rbp
  800420eb4c:	48 89 e5             	mov    %rsp,%rbp
  800420eb4f:	48 83 ec 18          	sub    $0x18,%rsp
  800420eb53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420eb57:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420eb5e:	eb 09                	jmp    800420eb69 <strlen+0x1e>
		n++;
  800420eb60:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420eb64:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eb69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb6d:	0f b6 00             	movzbl (%rax),%eax
  800420eb70:	84 c0                	test   %al,%al
  800420eb72:	75 ec                	jne    800420eb60 <strlen+0x15>
		n++;
	return n;
  800420eb74:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420eb77:	c9                   	leaveq 
  800420eb78:	c3                   	retq   

000000800420eb79 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420eb79:	55                   	push   %rbp
  800420eb7a:	48 89 e5             	mov    %rsp,%rbp
  800420eb7d:	48 83 ec 20          	sub    $0x20,%rsp
  800420eb81:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb85:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420eb89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420eb90:	eb 0e                	jmp    800420eba0 <strnlen+0x27>
		n++;
  800420eb92:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420eb96:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eb9b:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420eba0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420eba5:	74 0b                	je     800420ebb2 <strnlen+0x39>
  800420eba7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebab:	0f b6 00             	movzbl (%rax),%eax
  800420ebae:	84 c0                	test   %al,%al
  800420ebb0:	75 e0                	jne    800420eb92 <strnlen+0x19>
		n++;
	return n;
  800420ebb2:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420ebb5:	c9                   	leaveq 
  800420ebb6:	c3                   	retq   

000000800420ebb7 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420ebb7:	55                   	push   %rbp
  800420ebb8:	48 89 e5             	mov    %rsp,%rbp
  800420ebbb:	48 83 ec 20          	sub    $0x20,%rsp
  800420ebbf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ebc3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420ebc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebcb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420ebcf:	90                   	nop
  800420ebd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebd4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ebd8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ebdc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ebe0:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420ebe4:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420ebe8:	0f b6 12             	movzbl (%rdx),%edx
  800420ebeb:	88 10                	mov    %dl,(%rax)
  800420ebed:	0f b6 00             	movzbl (%rax),%eax
  800420ebf0:	84 c0                	test   %al,%al
  800420ebf2:	75 dc                	jne    800420ebd0 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420ebf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ebf8:	c9                   	leaveq 
  800420ebf9:	c3                   	retq   

000000800420ebfa <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420ebfa:	55                   	push   %rbp
  800420ebfb:	48 89 e5             	mov    %rsp,%rbp
  800420ebfe:	48 83 ec 20          	sub    $0x20,%rsp
  800420ec02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec06:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420ec0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec0e:	48 89 c7             	mov    %rax,%rdi
  800420ec11:	48 b8 4b eb 20 04 80 	movabs $0x800420eb4b,%rax
  800420ec18:	00 00 00 
  800420ec1b:	ff d0                	callq  *%rax
  800420ec1d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420ec20:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ec23:	48 63 d0             	movslq %eax,%rdx
  800420ec26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec2a:	48 01 c2             	add    %rax,%rdx
  800420ec2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec31:	48 89 c6             	mov    %rax,%rsi
  800420ec34:	48 89 d7             	mov    %rdx,%rdi
  800420ec37:	48 b8 b7 eb 20 04 80 	movabs $0x800420ebb7,%rax
  800420ec3e:	00 00 00 
  800420ec41:	ff d0                	callq  *%rax
	return dst;
  800420ec43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ec47:	c9                   	leaveq 
  800420ec48:	c3                   	retq   

000000800420ec49 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420ec49:	55                   	push   %rbp
  800420ec4a:	48 89 e5             	mov    %rsp,%rbp
  800420ec4d:	48 83 ec 28          	sub    $0x28,%rsp
  800420ec51:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec55:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ec59:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420ec5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec61:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420ec65:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ec6c:	00 
  800420ec6d:	eb 2a                	jmp    800420ec99 <strncpy+0x50>
		*dst++ = *src;
  800420ec6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec73:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ec77:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ec7b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ec7f:	0f b6 12             	movzbl (%rdx),%edx
  800420ec82:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420ec84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec88:	0f b6 00             	movzbl (%rax),%eax
  800420ec8b:	84 c0                	test   %al,%al
  800420ec8d:	74 05                	je     800420ec94 <strncpy+0x4b>
			src++;
  800420ec8f:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420ec94:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec9d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420eca1:	72 cc                	jb     800420ec6f <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420eca3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420eca7:	c9                   	leaveq 
  800420eca8:	c3                   	retq   

000000800420eca9 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420eca9:	55                   	push   %rbp
  800420ecaa:	48 89 e5             	mov    %rsp,%rbp
  800420ecad:	48 83 ec 28          	sub    $0x28,%rsp
  800420ecb1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ecb5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ecb9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420ecbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420ecc5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ecca:	74 3d                	je     800420ed09 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420eccc:	eb 1d                	jmp    800420eceb <strlcpy+0x42>
			*dst++ = *src++;
  800420ecce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecd2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ecd6:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ecda:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ecde:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420ece2:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420ece6:	0f b6 12             	movzbl (%rdx),%edx
  800420ece9:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420eceb:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420ecf0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420ecf5:	74 0b                	je     800420ed02 <strlcpy+0x59>
  800420ecf7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ecfb:	0f b6 00             	movzbl (%rax),%eax
  800420ecfe:	84 c0                	test   %al,%al
  800420ed00:	75 cc                	jne    800420ecce <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420ed02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed06:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420ed09:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed11:	48 29 c2             	sub    %rax,%rdx
  800420ed14:	48 89 d0             	mov    %rdx,%rax
}
  800420ed17:	c9                   	leaveq 
  800420ed18:	c3                   	retq   

000000800420ed19 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420ed19:	55                   	push   %rbp
  800420ed1a:	48 89 e5             	mov    %rsp,%rbp
  800420ed1d:	48 83 ec 10          	sub    $0x10,%rsp
  800420ed21:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ed25:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420ed29:	eb 0a                	jmp    800420ed35 <strcmp+0x1c>
		p++, q++;
  800420ed2b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ed30:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420ed35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed39:	0f b6 00             	movzbl (%rax),%eax
  800420ed3c:	84 c0                	test   %al,%al
  800420ed3e:	74 12                	je     800420ed52 <strcmp+0x39>
  800420ed40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed44:	0f b6 10             	movzbl (%rax),%edx
  800420ed47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed4b:	0f b6 00             	movzbl (%rax),%eax
  800420ed4e:	38 c2                	cmp    %al,%dl
  800420ed50:	74 d9                	je     800420ed2b <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ed52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed56:	0f b6 00             	movzbl (%rax),%eax
  800420ed59:	0f b6 d0             	movzbl %al,%edx
  800420ed5c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed60:	0f b6 00             	movzbl (%rax),%eax
  800420ed63:	0f b6 c0             	movzbl %al,%eax
  800420ed66:	29 c2                	sub    %eax,%edx
  800420ed68:	89 d0                	mov    %edx,%eax
}
  800420ed6a:	c9                   	leaveq 
  800420ed6b:	c3                   	retq   

000000800420ed6c <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420ed6c:	55                   	push   %rbp
  800420ed6d:	48 89 e5             	mov    %rsp,%rbp
  800420ed70:	48 83 ec 18          	sub    $0x18,%rsp
  800420ed74:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ed78:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ed7c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420ed80:	eb 0f                	jmp    800420ed91 <strncmp+0x25>
		n--, p++, q++;
  800420ed82:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420ed87:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ed8c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420ed91:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ed96:	74 1d                	je     800420edb5 <strncmp+0x49>
  800420ed98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed9c:	0f b6 00             	movzbl (%rax),%eax
  800420ed9f:	84 c0                	test   %al,%al
  800420eda1:	74 12                	je     800420edb5 <strncmp+0x49>
  800420eda3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eda7:	0f b6 10             	movzbl (%rax),%edx
  800420edaa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edae:	0f b6 00             	movzbl (%rax),%eax
  800420edb1:	38 c2                	cmp    %al,%dl
  800420edb3:	74 cd                	je     800420ed82 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420edb5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420edba:	75 07                	jne    800420edc3 <strncmp+0x57>
		return 0;
  800420edbc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420edc1:	eb 18                	jmp    800420eddb <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420edc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edc7:	0f b6 00             	movzbl (%rax),%eax
  800420edca:	0f b6 d0             	movzbl %al,%edx
  800420edcd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edd1:	0f b6 00             	movzbl (%rax),%eax
  800420edd4:	0f b6 c0             	movzbl %al,%eax
  800420edd7:	29 c2                	sub    %eax,%edx
  800420edd9:	89 d0                	mov    %edx,%eax
}
  800420eddb:	c9                   	leaveq 
  800420eddc:	c3                   	retq   

000000800420eddd <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420eddd:	55                   	push   %rbp
  800420edde:	48 89 e5             	mov    %rsp,%rbp
  800420ede1:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ede5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ede9:	89 f0                	mov    %esi,%eax
  800420edeb:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420edee:	eb 17                	jmp    800420ee07 <strchr+0x2a>
		if (*s == c)
  800420edf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edf4:	0f b6 00             	movzbl (%rax),%eax
  800420edf7:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420edfa:	75 06                	jne    800420ee02 <strchr+0x25>
			return (char *) s;
  800420edfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee00:	eb 15                	jmp    800420ee17 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420ee02:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ee07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee0b:	0f b6 00             	movzbl (%rax),%eax
  800420ee0e:	84 c0                	test   %al,%al
  800420ee10:	75 de                	jne    800420edf0 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420ee12:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ee17:	c9                   	leaveq 
  800420ee18:	c3                   	retq   

000000800420ee19 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420ee19:	55                   	push   %rbp
  800420ee1a:	48 89 e5             	mov    %rsp,%rbp
  800420ee1d:	48 83 ec 0c          	sub    $0xc,%rsp
  800420ee21:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ee25:	89 f0                	mov    %esi,%eax
  800420ee27:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ee2a:	eb 13                	jmp    800420ee3f <strfind+0x26>
		if (*s == c)
  800420ee2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee30:	0f b6 00             	movzbl (%rax),%eax
  800420ee33:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ee36:	75 02                	jne    800420ee3a <strfind+0x21>
			break;
  800420ee38:	eb 10                	jmp    800420ee4a <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420ee3a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ee3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee43:	0f b6 00             	movzbl (%rax),%eax
  800420ee46:	84 c0                	test   %al,%al
  800420ee48:	75 e2                	jne    800420ee2c <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420ee4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ee4e:	c9                   	leaveq 
  800420ee4f:	c3                   	retq   

000000800420ee50 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420ee50:	55                   	push   %rbp
  800420ee51:	48 89 e5             	mov    %rsp,%rbp
  800420ee54:	48 83 ec 18          	sub    $0x18,%rsp
  800420ee58:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ee5c:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420ee5f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420ee63:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ee68:	75 06                	jne    800420ee70 <memset+0x20>
		return v;
  800420ee6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee6e:	eb 69                	jmp    800420eed9 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420ee70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee74:	83 e0 03             	and    $0x3,%eax
  800420ee77:	48 85 c0             	test   %rax,%rax
  800420ee7a:	75 48                	jne    800420eec4 <memset+0x74>
  800420ee7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee80:	83 e0 03             	and    $0x3,%eax
  800420ee83:	48 85 c0             	test   %rax,%rax
  800420ee86:	75 3c                	jne    800420eec4 <memset+0x74>
		c &= 0xFF;
  800420ee88:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420ee8f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee92:	c1 e0 18             	shl    $0x18,%eax
  800420ee95:	89 c2                	mov    %eax,%edx
  800420ee97:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ee9a:	c1 e0 10             	shl    $0x10,%eax
  800420ee9d:	09 c2                	or     %eax,%edx
  800420ee9f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420eea2:	c1 e0 08             	shl    $0x8,%eax
  800420eea5:	09 d0                	or     %edx,%eax
  800420eea7:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420eeaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eeae:	48 c1 e8 02          	shr    $0x2,%rax
  800420eeb2:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420eeb5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420eeb9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420eebc:	48 89 d7             	mov    %rdx,%rdi
  800420eebf:	fc                   	cld    
  800420eec0:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420eec2:	eb 11                	jmp    800420eed5 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420eec4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420eec8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420eecb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420eecf:	48 89 d7             	mov    %rdx,%rdi
  800420eed2:	fc                   	cld    
  800420eed3:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420eed5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420eed9:	c9                   	leaveq 
  800420eeda:	c3                   	retq   

000000800420eedb <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420eedb:	55                   	push   %rbp
  800420eedc:	48 89 e5             	mov    %rsp,%rbp
  800420eedf:	48 83 ec 28          	sub    $0x28,%rsp
  800420eee3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eee7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eeeb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420eeef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eef3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420eef7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eefb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420eeff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef03:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ef07:	0f 83 88 00 00 00    	jae    800420ef95 <memmove+0xba>
  800420ef0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef11:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ef15:	48 01 d0             	add    %rdx,%rax
  800420ef18:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ef1c:	76 77                	jbe    800420ef95 <memmove+0xba>
		s += n;
  800420ef1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef22:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420ef26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef2a:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ef2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef32:	83 e0 03             	and    $0x3,%eax
  800420ef35:	48 85 c0             	test   %rax,%rax
  800420ef38:	75 3b                	jne    800420ef75 <memmove+0x9a>
  800420ef3a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef3e:	83 e0 03             	and    $0x3,%eax
  800420ef41:	48 85 c0             	test   %rax,%rax
  800420ef44:	75 2f                	jne    800420ef75 <memmove+0x9a>
  800420ef46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef4a:	83 e0 03             	and    $0x3,%eax
  800420ef4d:	48 85 c0             	test   %rax,%rax
  800420ef50:	75 23                	jne    800420ef75 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420ef52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef56:	48 83 e8 04          	sub    $0x4,%rax
  800420ef5a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ef5e:	48 83 ea 04          	sub    $0x4,%rdx
  800420ef62:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ef66:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420ef6a:	48 89 c7             	mov    %rax,%rdi
  800420ef6d:	48 89 d6             	mov    %rdx,%rsi
  800420ef70:	fd                   	std    
  800420ef71:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ef73:	eb 1d                	jmp    800420ef92 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420ef75:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef79:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420ef7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef81:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420ef85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef89:	48 89 d7             	mov    %rdx,%rdi
  800420ef8c:	48 89 c1             	mov    %rax,%rcx
  800420ef8f:	fd                   	std    
  800420ef90:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420ef92:	fc                   	cld    
  800420ef93:	eb 57                	jmp    800420efec <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ef95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ef99:	83 e0 03             	and    $0x3,%eax
  800420ef9c:	48 85 c0             	test   %rax,%rax
  800420ef9f:	75 36                	jne    800420efd7 <memmove+0xfc>
  800420efa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efa5:	83 e0 03             	and    $0x3,%eax
  800420efa8:	48 85 c0             	test   %rax,%rax
  800420efab:	75 2a                	jne    800420efd7 <memmove+0xfc>
  800420efad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efb1:	83 e0 03             	and    $0x3,%eax
  800420efb4:	48 85 c0             	test   %rax,%rax
  800420efb7:	75 1e                	jne    800420efd7 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420efb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efbd:	48 c1 e8 02          	shr    $0x2,%rax
  800420efc1:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420efc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efc8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420efcc:	48 89 c7             	mov    %rax,%rdi
  800420efcf:	48 89 d6             	mov    %rdx,%rsi
  800420efd2:	fc                   	cld    
  800420efd3:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420efd5:	eb 15                	jmp    800420efec <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420efd7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efdb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420efdf:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420efe3:	48 89 c7             	mov    %rax,%rdi
  800420efe6:	48 89 d6             	mov    %rdx,%rsi
  800420efe9:	fc                   	cld    
  800420efea:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420efec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420eff0:	c9                   	leaveq 
  800420eff1:	c3                   	retq   

000000800420eff2 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420eff2:	55                   	push   %rbp
  800420eff3:	48 89 e5             	mov    %rsp,%rbp
  800420eff6:	48 83 ec 18          	sub    $0x18,%rsp
  800420effa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420effe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f002:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420f006:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f00a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420f00e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f012:	48 89 ce             	mov    %rcx,%rsi
  800420f015:	48 89 c7             	mov    %rax,%rdi
  800420f018:	48 b8 db ee 20 04 80 	movabs $0x800420eedb,%rax
  800420f01f:	00 00 00 
  800420f022:	ff d0                	callq  *%rax
}
  800420f024:	c9                   	leaveq 
  800420f025:	c3                   	retq   

000000800420f026 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420f026:	55                   	push   %rbp
  800420f027:	48 89 e5             	mov    %rsp,%rbp
  800420f02a:	48 83 ec 28          	sub    $0x28,%rsp
  800420f02e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f032:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f036:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420f03a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f03e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420f042:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f046:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420f04a:	eb 36                	jmp    800420f082 <memcmp+0x5c>
		if (*s1 != *s2)
  800420f04c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f050:	0f b6 10             	movzbl (%rax),%edx
  800420f053:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f057:	0f b6 00             	movzbl (%rax),%eax
  800420f05a:	38 c2                	cmp    %al,%dl
  800420f05c:	74 1a                	je     800420f078 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420f05e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f062:	0f b6 00             	movzbl (%rax),%eax
  800420f065:	0f b6 d0             	movzbl %al,%edx
  800420f068:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f06c:	0f b6 00             	movzbl (%rax),%eax
  800420f06f:	0f b6 c0             	movzbl %al,%eax
  800420f072:	29 c2                	sub    %eax,%edx
  800420f074:	89 d0                	mov    %edx,%eax
  800420f076:	eb 20                	jmp    800420f098 <memcmp+0x72>
		s1++, s2++;
  800420f078:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f07d:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420f082:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f086:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f08a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f08e:	48 85 c0             	test   %rax,%rax
  800420f091:	75 b9                	jne    800420f04c <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420f093:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f098:	c9                   	leaveq 
  800420f099:	c3                   	retq   

000000800420f09a <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420f09a:	55                   	push   %rbp
  800420f09b:	48 89 e5             	mov    %rsp,%rbp
  800420f09e:	48 83 ec 28          	sub    $0x28,%rsp
  800420f0a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f0a6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420f0a9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420f0ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0b1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f0b5:	48 01 d0             	add    %rdx,%rax
  800420f0b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420f0bc:	eb 15                	jmp    800420f0d3 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420f0be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0c2:	0f b6 10             	movzbl (%rax),%edx
  800420f0c5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f0c8:	38 c2                	cmp    %al,%dl
  800420f0ca:	75 02                	jne    800420f0ce <memfind+0x34>
			break;
  800420f0cc:	eb 0f                	jmp    800420f0dd <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420f0ce:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f0d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0d7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420f0db:	72 e1                	jb     800420f0be <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420f0dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f0e1:	c9                   	leaveq 
  800420f0e2:	c3                   	retq   

000000800420f0e3 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420f0e3:	55                   	push   %rbp
  800420f0e4:	48 89 e5             	mov    %rsp,%rbp
  800420f0e7:	48 83 ec 34          	sub    $0x34,%rsp
  800420f0eb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f0ef:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420f0f3:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420f0f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420f0fd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f104:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420f105:	eb 05                	jmp    800420f10c <strtol+0x29>
		s++;
  800420f107:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420f10c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f110:	0f b6 00             	movzbl (%rax),%eax
  800420f113:	3c 20                	cmp    $0x20,%al
  800420f115:	74 f0                	je     800420f107 <strtol+0x24>
  800420f117:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f11b:	0f b6 00             	movzbl (%rax),%eax
  800420f11e:	3c 09                	cmp    $0x9,%al
  800420f120:	74 e5                	je     800420f107 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420f122:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f126:	0f b6 00             	movzbl (%rax),%eax
  800420f129:	3c 2b                	cmp    $0x2b,%al
  800420f12b:	75 07                	jne    800420f134 <strtol+0x51>
		s++;
  800420f12d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f132:	eb 17                	jmp    800420f14b <strtol+0x68>
	else if (*s == '-')
  800420f134:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f138:	0f b6 00             	movzbl (%rax),%eax
  800420f13b:	3c 2d                	cmp    $0x2d,%al
  800420f13d:	75 0c                	jne    800420f14b <strtol+0x68>
		s++, neg = 1;
  800420f13f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f144:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420f14b:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f14f:	74 06                	je     800420f157 <strtol+0x74>
  800420f151:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420f155:	75 28                	jne    800420f17f <strtol+0x9c>
  800420f157:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f15b:	0f b6 00             	movzbl (%rax),%eax
  800420f15e:	3c 30                	cmp    $0x30,%al
  800420f160:	75 1d                	jne    800420f17f <strtol+0x9c>
  800420f162:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f166:	48 83 c0 01          	add    $0x1,%rax
  800420f16a:	0f b6 00             	movzbl (%rax),%eax
  800420f16d:	3c 78                	cmp    $0x78,%al
  800420f16f:	75 0e                	jne    800420f17f <strtol+0x9c>
		s += 2, base = 16;
  800420f171:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420f176:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420f17d:	eb 2c                	jmp    800420f1ab <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420f17f:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f183:	75 19                	jne    800420f19e <strtol+0xbb>
  800420f185:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f189:	0f b6 00             	movzbl (%rax),%eax
  800420f18c:	3c 30                	cmp    $0x30,%al
  800420f18e:	75 0e                	jne    800420f19e <strtol+0xbb>
		s++, base = 8;
  800420f190:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f195:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420f19c:	eb 0d                	jmp    800420f1ab <strtol+0xc8>
	else if (base == 0)
  800420f19e:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420f1a2:	75 07                	jne    800420f1ab <strtol+0xc8>
		base = 10;
  800420f1a4:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420f1ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1af:	0f b6 00             	movzbl (%rax),%eax
  800420f1b2:	3c 2f                	cmp    $0x2f,%al
  800420f1b4:	7e 1d                	jle    800420f1d3 <strtol+0xf0>
  800420f1b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1ba:	0f b6 00             	movzbl (%rax),%eax
  800420f1bd:	3c 39                	cmp    $0x39,%al
  800420f1bf:	7f 12                	jg     800420f1d3 <strtol+0xf0>
			dig = *s - '0';
  800420f1c1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1c5:	0f b6 00             	movzbl (%rax),%eax
  800420f1c8:	0f be c0             	movsbl %al,%eax
  800420f1cb:	83 e8 30             	sub    $0x30,%eax
  800420f1ce:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420f1d1:	eb 4e                	jmp    800420f221 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420f1d3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1d7:	0f b6 00             	movzbl (%rax),%eax
  800420f1da:	3c 60                	cmp    $0x60,%al
  800420f1dc:	7e 1d                	jle    800420f1fb <strtol+0x118>
  800420f1de:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1e2:	0f b6 00             	movzbl (%rax),%eax
  800420f1e5:	3c 7a                	cmp    $0x7a,%al
  800420f1e7:	7f 12                	jg     800420f1fb <strtol+0x118>
			dig = *s - 'a' + 10;
  800420f1e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1ed:	0f b6 00             	movzbl (%rax),%eax
  800420f1f0:	0f be c0             	movsbl %al,%eax
  800420f1f3:	83 e8 57             	sub    $0x57,%eax
  800420f1f6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420f1f9:	eb 26                	jmp    800420f221 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420f1fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f1ff:	0f b6 00             	movzbl (%rax),%eax
  800420f202:	3c 40                	cmp    $0x40,%al
  800420f204:	7e 48                	jle    800420f24e <strtol+0x16b>
  800420f206:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f20a:	0f b6 00             	movzbl (%rax),%eax
  800420f20d:	3c 5a                	cmp    $0x5a,%al
  800420f20f:	7f 3d                	jg     800420f24e <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420f211:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f215:	0f b6 00             	movzbl (%rax),%eax
  800420f218:	0f be c0             	movsbl %al,%eax
  800420f21b:	83 e8 37             	sub    $0x37,%eax
  800420f21e:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420f221:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f224:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420f227:	7c 02                	jl     800420f22b <strtol+0x148>
			break;
  800420f229:	eb 23                	jmp    800420f24e <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420f22b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f230:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420f233:	48 98                	cltq   
  800420f235:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420f23a:	48 89 c2             	mov    %rax,%rdx
  800420f23d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f240:	48 98                	cltq   
  800420f242:	48 01 d0             	add    %rdx,%rax
  800420f245:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420f249:	e9 5d ff ff ff       	jmpq   800420f1ab <strtol+0xc8>

	if (endptr)
  800420f24e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f253:	74 0b                	je     800420f260 <strtol+0x17d>
		*endptr = (char *) s;
  800420f255:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f259:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f25d:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420f260:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f264:	74 09                	je     800420f26f <strtol+0x18c>
  800420f266:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f26a:	48 f7 d8             	neg    %rax
  800420f26d:	eb 04                	jmp    800420f273 <strtol+0x190>
  800420f26f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f273:	c9                   	leaveq 
  800420f274:	c3                   	retq   

000000800420f275 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420f275:	55                   	push   %rbp
  800420f276:	48 89 e5             	mov    %rsp,%rbp
  800420f279:	48 83 ec 30          	sub    $0x30,%rsp
  800420f27d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f281:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420f285:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f289:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f28d:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420f291:	0f b6 00             	movzbl (%rax),%eax
  800420f294:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420f297:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420f29b:	75 06                	jne    800420f2a3 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420f29d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2a1:	eb 6b                	jmp    800420f30e <strstr+0x99>

	len = strlen(str);
  800420f2a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f2a7:	48 89 c7             	mov    %rax,%rdi
  800420f2aa:	48 b8 4b eb 20 04 80 	movabs $0x800420eb4b,%rax
  800420f2b1:	00 00 00 
  800420f2b4:	ff d0                	callq  *%rax
  800420f2b6:	48 98                	cltq   
  800420f2b8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420f2bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2c0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f2c4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f2c8:	0f b6 00             	movzbl (%rax),%eax
  800420f2cb:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420f2ce:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420f2d2:	75 07                	jne    800420f2db <strstr+0x66>
				return (char *) 0;
  800420f2d4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f2d9:	eb 33                	jmp    800420f30e <strstr+0x99>
		} while (sc != c);
  800420f2db:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420f2df:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420f2e2:	75 d8                	jne    800420f2bc <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420f2e4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f2e8:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420f2ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f2f0:	48 89 ce             	mov    %rcx,%rsi
  800420f2f3:	48 89 c7             	mov    %rax,%rdi
  800420f2f6:	48 b8 6c ed 20 04 80 	movabs $0x800420ed6c,%rax
  800420f2fd:	00 00 00 
  800420f300:	ff d0                	callq  *%rax
  800420f302:	85 c0                	test   %eax,%eax
  800420f304:	75 b6                	jne    800420f2bc <strstr+0x47>

	return (char *) (in - 1);
  800420f306:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f30a:	48 83 e8 01          	sub    $0x1,%rax
}
  800420f30e:	c9                   	leaveq 
  800420f30f:	c3                   	retq   

000000800420f310 <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f310:	55                   	push   %rbp
  800420f311:	48 89 e5             	mov    %rsp,%rbp
  800420f314:	48 83 ec 24          	sub    $0x24,%rsp
  800420f318:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f31c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f320:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f323:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f327:	48 8b 10             	mov    (%rax),%rdx
  800420f32a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f32e:	48 01 d0             	add    %rdx,%rax
  800420f331:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f335:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f33c:	00 
	switch (bytes_to_read) {
  800420f33d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f340:	83 f8 02             	cmp    $0x2,%eax
  800420f343:	0f 84 ab 00 00 00    	je     800420f3f4 <_dwarf_read_lsb+0xe4>
  800420f349:	83 f8 02             	cmp    $0x2,%eax
  800420f34c:	7f 0e                	jg     800420f35c <_dwarf_read_lsb+0x4c>
  800420f34e:	83 f8 01             	cmp    $0x1,%eax
  800420f351:	0f 84 b3 00 00 00    	je     800420f40a <_dwarf_read_lsb+0xfa>
  800420f357:	e9 d9 00 00 00       	jmpq   800420f435 <_dwarf_read_lsb+0x125>
  800420f35c:	83 f8 04             	cmp    $0x4,%eax
  800420f35f:	74 65                	je     800420f3c6 <_dwarf_read_lsb+0xb6>
  800420f361:	83 f8 08             	cmp    $0x8,%eax
  800420f364:	0f 85 cb 00 00 00    	jne    800420f435 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f36a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f36e:	48 83 c0 04          	add    $0x4,%rax
  800420f372:	0f b6 00             	movzbl (%rax),%eax
  800420f375:	0f b6 c0             	movzbl %al,%eax
  800420f378:	48 c1 e0 20          	shl    $0x20,%rax
  800420f37c:	48 89 c2             	mov    %rax,%rdx
  800420f37f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f383:	48 83 c0 05          	add    $0x5,%rax
  800420f387:	0f b6 00             	movzbl (%rax),%eax
  800420f38a:	0f b6 c0             	movzbl %al,%eax
  800420f38d:	48 c1 e0 28          	shl    $0x28,%rax
  800420f391:	48 09 d0             	or     %rdx,%rax
  800420f394:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f398:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f39c:	48 83 c0 06          	add    $0x6,%rax
  800420f3a0:	0f b6 00             	movzbl (%rax),%eax
  800420f3a3:	0f b6 c0             	movzbl %al,%eax
  800420f3a6:	48 c1 e0 30          	shl    $0x30,%rax
  800420f3aa:	48 89 c2             	mov    %rax,%rdx
  800420f3ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3b1:	48 83 c0 07          	add    $0x7,%rax
  800420f3b5:	0f b6 00             	movzbl (%rax),%eax
  800420f3b8:	0f b6 c0             	movzbl %al,%eax
  800420f3bb:	48 c1 e0 38          	shl    $0x38,%rax
  800420f3bf:	48 09 d0             	or     %rdx,%rax
  800420f3c2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f3c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3ca:	48 83 c0 02          	add    $0x2,%rax
  800420f3ce:	0f b6 00             	movzbl (%rax),%eax
  800420f3d1:	0f b6 c0             	movzbl %al,%eax
  800420f3d4:	48 c1 e0 10          	shl    $0x10,%rax
  800420f3d8:	48 89 c2             	mov    %rax,%rdx
  800420f3db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3df:	48 83 c0 03          	add    $0x3,%rax
  800420f3e3:	0f b6 00             	movzbl (%rax),%eax
  800420f3e6:	0f b6 c0             	movzbl %al,%eax
  800420f3e9:	48 c1 e0 18          	shl    $0x18,%rax
  800420f3ed:	48 09 d0             	or     %rdx,%rax
  800420f3f0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f3f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3f8:	48 83 c0 01          	add    $0x1,%rax
  800420f3fc:	0f b6 00             	movzbl (%rax),%eax
  800420f3ff:	0f b6 c0             	movzbl %al,%eax
  800420f402:	48 c1 e0 08          	shl    $0x8,%rax
  800420f406:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f40a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f40e:	0f b6 00             	movzbl (%rax),%eax
  800420f411:	0f b6 c0             	movzbl %al,%eax
  800420f414:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f418:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420f419:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f41d:	48 8b 10             	mov    (%rax),%rdx
  800420f420:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f423:	48 98                	cltq   
  800420f425:	48 01 c2             	add    %rax,%rdx
  800420f428:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f42c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f42f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f433:	eb 05                	jmp    800420f43a <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f435:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420f43a:	c9                   	leaveq 
  800420f43b:	c3                   	retq   

000000800420f43c <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420f43c:	55                   	push   %rbp
  800420f43d:	48 89 e5             	mov    %rsp,%rbp
  800420f440:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f444:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f448:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f44b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f44f:	48 8b 00             	mov    (%rax),%rax
  800420f452:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f456:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f45d:	00 
	switch (bytes_to_read) {
  800420f45e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f461:	83 f8 02             	cmp    $0x2,%eax
  800420f464:	0f 84 ab 00 00 00    	je     800420f515 <_dwarf_decode_lsb+0xd9>
  800420f46a:	83 f8 02             	cmp    $0x2,%eax
  800420f46d:	7f 0e                	jg     800420f47d <_dwarf_decode_lsb+0x41>
  800420f46f:	83 f8 01             	cmp    $0x1,%eax
  800420f472:	0f 84 b3 00 00 00    	je     800420f52b <_dwarf_decode_lsb+0xef>
  800420f478:	e9 d9 00 00 00       	jmpq   800420f556 <_dwarf_decode_lsb+0x11a>
  800420f47d:	83 f8 04             	cmp    $0x4,%eax
  800420f480:	74 65                	je     800420f4e7 <_dwarf_decode_lsb+0xab>
  800420f482:	83 f8 08             	cmp    $0x8,%eax
  800420f485:	0f 85 cb 00 00 00    	jne    800420f556 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f48b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f48f:	48 83 c0 04          	add    $0x4,%rax
  800420f493:	0f b6 00             	movzbl (%rax),%eax
  800420f496:	0f b6 c0             	movzbl %al,%eax
  800420f499:	48 c1 e0 20          	shl    $0x20,%rax
  800420f49d:	48 89 c2             	mov    %rax,%rdx
  800420f4a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4a4:	48 83 c0 05          	add    $0x5,%rax
  800420f4a8:	0f b6 00             	movzbl (%rax),%eax
  800420f4ab:	0f b6 c0             	movzbl %al,%eax
  800420f4ae:	48 c1 e0 28          	shl    $0x28,%rax
  800420f4b2:	48 09 d0             	or     %rdx,%rax
  800420f4b5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f4b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4bd:	48 83 c0 06          	add    $0x6,%rax
  800420f4c1:	0f b6 00             	movzbl (%rax),%eax
  800420f4c4:	0f b6 c0             	movzbl %al,%eax
  800420f4c7:	48 c1 e0 30          	shl    $0x30,%rax
  800420f4cb:	48 89 c2             	mov    %rax,%rdx
  800420f4ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4d2:	48 83 c0 07          	add    $0x7,%rax
  800420f4d6:	0f b6 00             	movzbl (%rax),%eax
  800420f4d9:	0f b6 c0             	movzbl %al,%eax
  800420f4dc:	48 c1 e0 38          	shl    $0x38,%rax
  800420f4e0:	48 09 d0             	or     %rdx,%rax
  800420f4e3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f4e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4eb:	48 83 c0 02          	add    $0x2,%rax
  800420f4ef:	0f b6 00             	movzbl (%rax),%eax
  800420f4f2:	0f b6 c0             	movzbl %al,%eax
  800420f4f5:	48 c1 e0 10          	shl    $0x10,%rax
  800420f4f9:	48 89 c2             	mov    %rax,%rdx
  800420f4fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f500:	48 83 c0 03          	add    $0x3,%rax
  800420f504:	0f b6 00             	movzbl (%rax),%eax
  800420f507:	0f b6 c0             	movzbl %al,%eax
  800420f50a:	48 c1 e0 18          	shl    $0x18,%rax
  800420f50e:	48 09 d0             	or     %rdx,%rax
  800420f511:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f515:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f519:	48 83 c0 01          	add    $0x1,%rax
  800420f51d:	0f b6 00             	movzbl (%rax),%eax
  800420f520:	0f b6 c0             	movzbl %al,%eax
  800420f523:	48 c1 e0 08          	shl    $0x8,%rax
  800420f527:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f52b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f52f:	0f b6 00             	movzbl (%rax),%eax
  800420f532:	0f b6 c0             	movzbl %al,%eax
  800420f535:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f539:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420f53a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f53e:	48 8b 10             	mov    (%rax),%rdx
  800420f541:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f544:	48 98                	cltq   
  800420f546:	48 01 c2             	add    %rax,%rdx
  800420f549:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f54d:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f550:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f554:	eb 05                	jmp    800420f55b <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f556:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420f55b:	c9                   	leaveq 
  800420f55c:	c3                   	retq   

000000800420f55d <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f55d:	55                   	push   %rbp
  800420f55e:	48 89 e5             	mov    %rsp,%rbp
  800420f561:	48 83 ec 24          	sub    $0x24,%rsp
  800420f565:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f569:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f56d:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f570:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f574:	48 8b 10             	mov    (%rax),%rdx
  800420f577:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f57b:	48 01 d0             	add    %rdx,%rax
  800420f57e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420f582:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f585:	83 f8 02             	cmp    $0x2,%eax
  800420f588:	74 35                	je     800420f5bf <_dwarf_read_msb+0x62>
  800420f58a:	83 f8 02             	cmp    $0x2,%eax
  800420f58d:	7f 0a                	jg     800420f599 <_dwarf_read_msb+0x3c>
  800420f58f:	83 f8 01             	cmp    $0x1,%eax
  800420f592:	74 18                	je     800420f5ac <_dwarf_read_msb+0x4f>
  800420f594:	e9 53 01 00 00       	jmpq   800420f6ec <_dwarf_read_msb+0x18f>
  800420f599:	83 f8 04             	cmp    $0x4,%eax
  800420f59c:	74 49                	je     800420f5e7 <_dwarf_read_msb+0x8a>
  800420f59e:	83 f8 08             	cmp    $0x8,%eax
  800420f5a1:	0f 84 96 00 00 00    	je     800420f63d <_dwarf_read_msb+0xe0>
  800420f5a7:	e9 40 01 00 00       	jmpq   800420f6ec <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420f5ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5b0:	0f b6 00             	movzbl (%rax),%eax
  800420f5b3:	0f b6 c0             	movzbl %al,%eax
  800420f5b6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f5ba:	e9 34 01 00 00       	jmpq   800420f6f3 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f5bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5c3:	48 83 c0 01          	add    $0x1,%rax
  800420f5c7:	0f b6 00             	movzbl (%rax),%eax
  800420f5ca:	0f b6 d0             	movzbl %al,%edx
  800420f5cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5d1:	0f b6 00             	movzbl (%rax),%eax
  800420f5d4:	0f b6 c0             	movzbl %al,%eax
  800420f5d7:	48 c1 e0 08          	shl    $0x8,%rax
  800420f5db:	48 09 d0             	or     %rdx,%rax
  800420f5de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f5e2:	e9 0c 01 00 00       	jmpq   800420f6f3 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f5e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5eb:	48 83 c0 03          	add    $0x3,%rax
  800420f5ef:	0f b6 00             	movzbl (%rax),%eax
  800420f5f2:	0f b6 c0             	movzbl %al,%eax
  800420f5f5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5f9:	48 83 c2 02          	add    $0x2,%rdx
  800420f5fd:	0f b6 12             	movzbl (%rdx),%edx
  800420f600:	0f b6 d2             	movzbl %dl,%edx
  800420f603:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f607:	48 09 d0             	or     %rdx,%rax
  800420f60a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f60e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f612:	48 83 c0 01          	add    $0x1,%rax
  800420f616:	0f b6 00             	movzbl (%rax),%eax
  800420f619:	0f b6 c0             	movzbl %al,%eax
  800420f61c:	48 c1 e0 10          	shl    $0x10,%rax
  800420f620:	48 89 c2             	mov    %rax,%rdx
  800420f623:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f627:	0f b6 00             	movzbl (%rax),%eax
  800420f62a:	0f b6 c0             	movzbl %al,%eax
  800420f62d:	48 c1 e0 18          	shl    $0x18,%rax
  800420f631:	48 09 d0             	or     %rdx,%rax
  800420f634:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f638:	e9 b6 00 00 00       	jmpq   800420f6f3 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f63d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f641:	48 83 c0 07          	add    $0x7,%rax
  800420f645:	0f b6 00             	movzbl (%rax),%eax
  800420f648:	0f b6 c0             	movzbl %al,%eax
  800420f64b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f64f:	48 83 c2 06          	add    $0x6,%rdx
  800420f653:	0f b6 12             	movzbl (%rdx),%edx
  800420f656:	0f b6 d2             	movzbl %dl,%edx
  800420f659:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f65d:	48 09 d0             	or     %rdx,%rax
  800420f660:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f664:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f668:	48 83 c0 05          	add    $0x5,%rax
  800420f66c:	0f b6 00             	movzbl (%rax),%eax
  800420f66f:	0f b6 c0             	movzbl %al,%eax
  800420f672:	48 c1 e0 10          	shl    $0x10,%rax
  800420f676:	48 89 c2             	mov    %rax,%rdx
  800420f679:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f67d:	48 83 c0 04          	add    $0x4,%rax
  800420f681:	0f b6 00             	movzbl (%rax),%eax
  800420f684:	0f b6 c0             	movzbl %al,%eax
  800420f687:	48 c1 e0 18          	shl    $0x18,%rax
  800420f68b:	48 09 d0             	or     %rdx,%rax
  800420f68e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f692:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f696:	48 83 c0 03          	add    $0x3,%rax
  800420f69a:	0f b6 00             	movzbl (%rax),%eax
  800420f69d:	0f b6 c0             	movzbl %al,%eax
  800420f6a0:	48 c1 e0 20          	shl    $0x20,%rax
  800420f6a4:	48 89 c2             	mov    %rax,%rdx
  800420f6a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6ab:	48 83 c0 02          	add    $0x2,%rax
  800420f6af:	0f b6 00             	movzbl (%rax),%eax
  800420f6b2:	0f b6 c0             	movzbl %al,%eax
  800420f6b5:	48 c1 e0 28          	shl    $0x28,%rax
  800420f6b9:	48 09 d0             	or     %rdx,%rax
  800420f6bc:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f6c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6c4:	48 83 c0 01          	add    $0x1,%rax
  800420f6c8:	0f b6 00             	movzbl (%rax),%eax
  800420f6cb:	0f b6 c0             	movzbl %al,%eax
  800420f6ce:	48 c1 e0 30          	shl    $0x30,%rax
  800420f6d2:	48 89 c2             	mov    %rax,%rdx
  800420f6d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6d9:	0f b6 00             	movzbl (%rax),%eax
  800420f6dc:	0f b6 c0             	movzbl %al,%eax
  800420f6df:	48 c1 e0 38          	shl    $0x38,%rax
  800420f6e3:	48 09 d0             	or     %rdx,%rax
  800420f6e6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f6ea:	eb 07                	jmp    800420f6f3 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420f6ec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6f1:	eb 1a                	jmp    800420f70d <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420f6f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6f7:	48 8b 10             	mov    (%rax),%rdx
  800420f6fa:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f6fd:	48 98                	cltq   
  800420f6ff:	48 01 c2             	add    %rax,%rdx
  800420f702:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f706:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f709:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f70d:	c9                   	leaveq 
  800420f70e:	c3                   	retq   

000000800420f70f <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420f70f:	55                   	push   %rbp
  800420f710:	48 89 e5             	mov    %rsp,%rbp
  800420f713:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420f717:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f71b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f71e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f722:	48 8b 00             	mov    (%rax),%rax
  800420f725:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f729:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f730:	00 
	switch (bytes_to_read) {
  800420f731:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f734:	83 f8 02             	cmp    $0x2,%eax
  800420f737:	74 35                	je     800420f76e <_dwarf_decode_msb+0x5f>
  800420f739:	83 f8 02             	cmp    $0x2,%eax
  800420f73c:	7f 0a                	jg     800420f748 <_dwarf_decode_msb+0x39>
  800420f73e:	83 f8 01             	cmp    $0x1,%eax
  800420f741:	74 18                	je     800420f75b <_dwarf_decode_msb+0x4c>
  800420f743:	e9 53 01 00 00       	jmpq   800420f89b <_dwarf_decode_msb+0x18c>
  800420f748:	83 f8 04             	cmp    $0x4,%eax
  800420f74b:	74 49                	je     800420f796 <_dwarf_decode_msb+0x87>
  800420f74d:	83 f8 08             	cmp    $0x8,%eax
  800420f750:	0f 84 96 00 00 00    	je     800420f7ec <_dwarf_decode_msb+0xdd>
  800420f756:	e9 40 01 00 00       	jmpq   800420f89b <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420f75b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f75f:	0f b6 00             	movzbl (%rax),%eax
  800420f762:	0f b6 c0             	movzbl %al,%eax
  800420f765:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f769:	e9 34 01 00 00       	jmpq   800420f8a2 <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f76e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f772:	48 83 c0 01          	add    $0x1,%rax
  800420f776:	0f b6 00             	movzbl (%rax),%eax
  800420f779:	0f b6 d0             	movzbl %al,%edx
  800420f77c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f780:	0f b6 00             	movzbl (%rax),%eax
  800420f783:	0f b6 c0             	movzbl %al,%eax
  800420f786:	48 c1 e0 08          	shl    $0x8,%rax
  800420f78a:	48 09 d0             	or     %rdx,%rax
  800420f78d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f791:	e9 0c 01 00 00       	jmpq   800420f8a2 <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f796:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f79a:	48 83 c0 03          	add    $0x3,%rax
  800420f79e:	0f b6 00             	movzbl (%rax),%eax
  800420f7a1:	0f b6 c0             	movzbl %al,%eax
  800420f7a4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f7a8:	48 83 c2 02          	add    $0x2,%rdx
  800420f7ac:	0f b6 12             	movzbl (%rdx),%edx
  800420f7af:	0f b6 d2             	movzbl %dl,%edx
  800420f7b2:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f7b6:	48 09 d0             	or     %rdx,%rax
  800420f7b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f7bd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7c1:	48 83 c0 01          	add    $0x1,%rax
  800420f7c5:	0f b6 00             	movzbl (%rax),%eax
  800420f7c8:	0f b6 c0             	movzbl %al,%eax
  800420f7cb:	48 c1 e0 10          	shl    $0x10,%rax
  800420f7cf:	48 89 c2             	mov    %rax,%rdx
  800420f7d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7d6:	0f b6 00             	movzbl (%rax),%eax
  800420f7d9:	0f b6 c0             	movzbl %al,%eax
  800420f7dc:	48 c1 e0 18          	shl    $0x18,%rax
  800420f7e0:	48 09 d0             	or     %rdx,%rax
  800420f7e3:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f7e7:	e9 b6 00 00 00       	jmpq   800420f8a2 <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f7ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f7f0:	48 83 c0 07          	add    $0x7,%rax
  800420f7f4:	0f b6 00             	movzbl (%rax),%eax
  800420f7f7:	0f b6 c0             	movzbl %al,%eax
  800420f7fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f7fe:	48 83 c2 06          	add    $0x6,%rdx
  800420f802:	0f b6 12             	movzbl (%rdx),%edx
  800420f805:	0f b6 d2             	movzbl %dl,%edx
  800420f808:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f80c:	48 09 d0             	or     %rdx,%rax
  800420f80f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f813:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f817:	48 83 c0 05          	add    $0x5,%rax
  800420f81b:	0f b6 00             	movzbl (%rax),%eax
  800420f81e:	0f b6 c0             	movzbl %al,%eax
  800420f821:	48 c1 e0 10          	shl    $0x10,%rax
  800420f825:	48 89 c2             	mov    %rax,%rdx
  800420f828:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f82c:	48 83 c0 04          	add    $0x4,%rax
  800420f830:	0f b6 00             	movzbl (%rax),%eax
  800420f833:	0f b6 c0             	movzbl %al,%eax
  800420f836:	48 c1 e0 18          	shl    $0x18,%rax
  800420f83a:	48 09 d0             	or     %rdx,%rax
  800420f83d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f841:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f845:	48 83 c0 03          	add    $0x3,%rax
  800420f849:	0f b6 00             	movzbl (%rax),%eax
  800420f84c:	0f b6 c0             	movzbl %al,%eax
  800420f84f:	48 c1 e0 20          	shl    $0x20,%rax
  800420f853:	48 89 c2             	mov    %rax,%rdx
  800420f856:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f85a:	48 83 c0 02          	add    $0x2,%rax
  800420f85e:	0f b6 00             	movzbl (%rax),%eax
  800420f861:	0f b6 c0             	movzbl %al,%eax
  800420f864:	48 c1 e0 28          	shl    $0x28,%rax
  800420f868:	48 09 d0             	or     %rdx,%rax
  800420f86b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f86f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f873:	48 83 c0 01          	add    $0x1,%rax
  800420f877:	0f b6 00             	movzbl (%rax),%eax
  800420f87a:	0f b6 c0             	movzbl %al,%eax
  800420f87d:	48 c1 e0 30          	shl    $0x30,%rax
  800420f881:	48 89 c2             	mov    %rax,%rdx
  800420f884:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f888:	0f b6 00             	movzbl (%rax),%eax
  800420f88b:	0f b6 c0             	movzbl %al,%eax
  800420f88e:	48 c1 e0 38          	shl    $0x38,%rax
  800420f892:	48 09 d0             	or     %rdx,%rax
  800420f895:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f899:	eb 07                	jmp    800420f8a2 <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f89b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f8a0:	eb 1a                	jmp    800420f8bc <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f8a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8a6:	48 8b 10             	mov    (%rax),%rdx
  800420f8a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f8ac:	48 98                	cltq   
  800420f8ae:	48 01 c2             	add    %rax,%rdx
  800420f8b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8b5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f8b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f8bc:	c9                   	leaveq 
  800420f8bd:	c3                   	retq   

000000800420f8be <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f8be:	55                   	push   %rbp
  800420f8bf:	48 89 e5             	mov    %rsp,%rbp
  800420f8c2:	48 83 ec 30          	sub    $0x30,%rsp
  800420f8c6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f8ca:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420f8ce:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f8d5:	00 
	uint8_t b;
	int shift = 0;
  800420f8d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f8dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f8e1:	48 8b 10             	mov    (%rax),%rdx
  800420f8e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f8e8:	48 01 d0             	add    %rdx,%rax
  800420f8eb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f8ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8f3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8f7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f8fb:	0f b6 00             	movzbl (%rax),%eax
  800420f8fe:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f901:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f905:	83 e0 7f             	and    $0x7f,%eax
  800420f908:	89 c2                	mov    %eax,%edx
  800420f90a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f90d:	89 c1                	mov    %eax,%ecx
  800420f90f:	d3 e2                	shl    %cl,%edx
  800420f911:	89 d0                	mov    %edx,%eax
  800420f913:	48 98                	cltq   
  800420f915:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f919:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f91d:	48 8b 00             	mov    (%rax),%rax
  800420f920:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f924:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f928:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f92b:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f92f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f933:	84 c0                	test   %al,%al
  800420f935:	78 b8                	js     800420f8ef <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420f937:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f93b:	7f 1f                	jg     800420f95c <_dwarf_read_sleb128+0x9e>
  800420f93d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f941:	83 e0 40             	and    $0x40,%eax
  800420f944:	85 c0                	test   %eax,%eax
  800420f946:	74 14                	je     800420f95c <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420f948:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f94b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f950:	89 c1                	mov    %eax,%ecx
  800420f952:	d3 e2                	shl    %cl,%edx
  800420f954:	89 d0                	mov    %edx,%eax
  800420f956:	48 98                	cltq   
  800420f958:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420f95c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f960:	c9                   	leaveq 
  800420f961:	c3                   	retq   

000000800420f962 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f962:	55                   	push   %rbp
  800420f963:	48 89 e5             	mov    %rsp,%rbp
  800420f966:	48 83 ec 30          	sub    $0x30,%rsp
  800420f96a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f96e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f972:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f979:	00 
	uint8_t b;
	int shift = 0;
  800420f97a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f981:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f985:	48 8b 10             	mov    (%rax),%rdx
  800420f988:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f98c:	48 01 d0             	add    %rdx,%rax
  800420f98f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f993:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f997:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f99b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f99f:	0f b6 00             	movzbl (%rax),%eax
  800420f9a2:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f9a5:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f9a9:	83 e0 7f             	and    $0x7f,%eax
  800420f9ac:	89 c2                	mov    %eax,%edx
  800420f9ae:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f9b1:	89 c1                	mov    %eax,%ecx
  800420f9b3:	d3 e2                	shl    %cl,%edx
  800420f9b5:	89 d0                	mov    %edx,%eax
  800420f9b7:	48 98                	cltq   
  800420f9b9:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f9bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f9c1:	48 8b 00             	mov    (%rax),%rax
  800420f9c4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f9c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f9cc:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f9cf:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f9d3:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f9d7:	84 c0                	test   %al,%al
  800420f9d9:	78 b8                	js     800420f993 <_dwarf_read_uleb128+0x31>

	return (ret);
  800420f9db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f9df:	c9                   	leaveq 
  800420f9e0:	c3                   	retq   

000000800420f9e1 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f9e1:	55                   	push   %rbp
  800420f9e2:	48 89 e5             	mov    %rsp,%rbp
  800420f9e5:	48 83 ec 28          	sub    $0x28,%rsp
  800420f9e9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420f9ed:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f9f4:	00 
	uint8_t b;
	int shift = 0;
  800420f9f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f9fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa00:	48 8b 00             	mov    (%rax),%rax
  800420fa03:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420fa07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa0b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fa0f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420fa13:	0f b6 00             	movzbl (%rax),%eax
  800420fa16:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420fa19:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420fa1d:	83 e0 7f             	and    $0x7f,%eax
  800420fa20:	89 c2                	mov    %eax,%edx
  800420fa22:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa25:	89 c1                	mov    %eax,%ecx
  800420fa27:	d3 e2                	shl    %cl,%edx
  800420fa29:	89 d0                	mov    %edx,%eax
  800420fa2b:	48 98                	cltq   
  800420fa2d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420fa31:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420fa35:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420fa39:	84 c0                	test   %al,%al
  800420fa3b:	78 ca                	js     800420fa07 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420fa3d:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420fa41:	7f 1f                	jg     800420fa62 <_dwarf_decode_sleb128+0x81>
  800420fa43:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420fa47:	83 e0 40             	and    $0x40,%eax
  800420fa4a:	85 c0                	test   %eax,%eax
  800420fa4c:	74 14                	je     800420fa62 <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420fa4e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fa51:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420fa56:	89 c1                	mov    %eax,%ecx
  800420fa58:	d3 e2                	shl    %cl,%edx
  800420fa5a:	89 d0                	mov    %edx,%eax
  800420fa5c:	48 98                	cltq   
  800420fa5e:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420fa62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa66:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fa6a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fa6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fa71:	c9                   	leaveq 
  800420fa72:	c3                   	retq   

000000800420fa73 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420fa73:	55                   	push   %rbp
  800420fa74:	48 89 e5             	mov    %rsp,%rbp
  800420fa77:	48 83 ec 28          	sub    $0x28,%rsp
  800420fa7b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420fa7f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420fa86:	00 
	uint8_t b;
	int shift = 0;
  800420fa87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420fa8e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa92:	48 8b 00             	mov    (%rax),%rax
  800420fa95:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420fa99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa9d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420faa1:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420faa5:	0f b6 00             	movzbl (%rax),%eax
  800420faa8:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420faab:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420faaf:	83 e0 7f             	and    $0x7f,%eax
  800420fab2:	89 c2                	mov    %eax,%edx
  800420fab4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fab7:	89 c1                	mov    %eax,%ecx
  800420fab9:	d3 e2                	shl    %cl,%edx
  800420fabb:	89 d0                	mov    %edx,%eax
  800420fabd:	48 98                	cltq   
  800420fabf:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420fac3:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420fac7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420facb:	84 c0                	test   %al,%al
  800420facd:	78 ca                	js     800420fa99 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420facf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fad3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fad7:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fada:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fade:	c9                   	leaveq 
  800420fadf:	c3                   	retq   

000000800420fae0 <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420fae0:	55                   	push   %rbp
  800420fae1:	48 89 e5             	mov    %rsp,%rbp
  800420fae4:	48 83 ec 28          	sub    $0x28,%rsp
  800420fae8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420faec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420faf0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420faf4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420faf8:	48 8b 10             	mov    (%rax),%rdx
  800420fafb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faff:	48 01 d0             	add    %rdx,%rax
  800420fb02:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fb06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb0a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420fb0e:	eb 17                	jmp    800420fb27 <_dwarf_read_string+0x47>
		src++;
  800420fb10:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420fb15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb19:	48 8b 00             	mov    (%rax),%rax
  800420fb1c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fb20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb24:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420fb27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb2b:	0f b6 00             	movzbl (%rax),%eax
  800420fb2e:	84 c0                	test   %al,%al
  800420fb30:	74 0d                	je     800420fb3f <_dwarf_read_string+0x5f>
  800420fb32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb36:	48 8b 00             	mov    (%rax),%rax
  800420fb39:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420fb3d:	72 d1                	jb     800420fb10 <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420fb3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb43:	0f b6 00             	movzbl (%rax),%eax
  800420fb46:	84 c0                	test   %al,%al
  800420fb48:	75 1f                	jne    800420fb69 <_dwarf_read_string+0x89>
  800420fb4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb4e:	48 8b 00             	mov    (%rax),%rax
  800420fb51:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420fb55:	73 12                	jae    800420fb69 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420fb57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb5b:	48 8b 00             	mov    (%rax),%rax
  800420fb5e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fb62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb66:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fb69:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fb6d:	c9                   	leaveq 
  800420fb6e:	c3                   	retq   

000000800420fb6f <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420fb6f:	55                   	push   %rbp
  800420fb70:	48 89 e5             	mov    %rsp,%rbp
  800420fb73:	48 83 ec 28          	sub    $0x28,%rsp
  800420fb77:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fb7b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fb7f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420fb83:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb87:	48 8b 10             	mov    (%rax),%rdx
  800420fb8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb8e:	48 01 d0             	add    %rdx,%rax
  800420fb91:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fb95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb99:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420fb9d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fba1:	48 8b 10             	mov    (%rax),%rdx
  800420fba4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fba8:	48 01 c2             	add    %rax,%rdx
  800420fbab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fbaf:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420fbb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fbb6:	c9                   	leaveq 
  800420fbb7:	c3                   	retq   

000000800420fbb8 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420fbb8:	55                   	push   %rbp
  800420fbb9:	48 89 e5             	mov    %rsp,%rbp
  800420fbbc:	48 83 ec 20          	sub    $0x20,%rsp
  800420fbc0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420fbc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbc8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fbcc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fbd1:	75 35                	jne    800420fc08 <_dwarf_elf_get_byte_order+0x50>
  800420fbd3:	48 b9 40 99 21 04 80 	movabs $0x8004219940,%rcx
  800420fbda:	00 00 00 
  800420fbdd:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800420fbe4:	00 00 00 
  800420fbe7:	be 29 01 00 00       	mov    $0x129,%esi
  800420fbec:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800420fbf3:	00 00 00 
  800420fbf6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fbfb:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420fc02:	00 00 00 
  800420fc05:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420fc08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc0c:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420fc10:	0f b6 c0             	movzbl %al,%eax
  800420fc13:	83 f8 02             	cmp    $0x2,%eax
  800420fc16:	75 07                	jne    800420fc1f <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420fc18:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fc1d:	eb 05                	jmp    800420fc24 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420fc1f:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420fc24:	c9                   	leaveq 
  800420fc25:	c3                   	retq   

000000800420fc26 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420fc26:	55                   	push   %rbp
  800420fc27:	48 89 e5             	mov    %rsp,%rbp
  800420fc2a:	48 83 ec 20          	sub    $0x20,%rsp
  800420fc2e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420fc32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc36:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fc3a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fc3f:	75 35                	jne    800420fc76 <_dwarf_elf_get_pointer_size+0x50>
  800420fc41:	48 b9 40 99 21 04 80 	movabs $0x8004219940,%rcx
  800420fc48:	00 00 00 
  800420fc4b:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800420fc52:	00 00 00 
  800420fc55:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420fc5a:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800420fc61:	00 00 00 
  800420fc64:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fc69:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420fc70:	00 00 00 
  800420fc73:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420fc76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc7a:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420fc7e:	3c 01                	cmp    $0x1,%al
  800420fc80:	75 07                	jne    800420fc89 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420fc82:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fc87:	eb 05                	jmp    800420fc8e <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420fc89:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420fc8e:	c9                   	leaveq 
  800420fc8f:	c3                   	retq   

000000800420fc90 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420fc90:	55                   	push   %rbp
  800420fc91:	48 89 e5             	mov    %rsp,%rbp
  800420fc94:	53                   	push   %rbx
  800420fc95:	48 83 ec 18          	sub    $0x18,%rsp
  800420fc99:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fc9d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420fca1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fca5:	ba 60 00 00 00       	mov    $0x60,%edx
  800420fcaa:	be 00 00 00 00       	mov    $0x0,%esi
  800420fcaf:	48 89 c7             	mov    %rax,%rdi
  800420fcb2:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  800420fcb9:	00 00 00 
  800420fcbc:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420fcbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcc2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420fcc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fccd:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420fcd4:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420fcd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcd9:	48 89 c7             	mov    %rax,%rdi
  800420fcdc:	48 b8 26 fc 20 04 80 	movabs $0x800420fc26,%rax
  800420fce3:	00 00 00 
  800420fce6:	ff d0                	callq  *%rax
  800420fce8:	0f b6 d0             	movzbl %al,%edx
  800420fceb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcef:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420fcf2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcf6:	48 89 c7             	mov    %rax,%rdi
  800420fcf9:	48 b8 b8 fb 20 04 80 	movabs $0x800420fbb8,%rax
  800420fd00:	00 00 00 
  800420fd03:	ff d0                	callq  *%rax
  800420fd05:	85 c0                	test   %eax,%eax
  800420fd07:	75 26                	jne    800420fd2f <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  800420fd09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd0d:	48 b9 5d f5 20 04 80 	movabs $0x800420f55d,%rcx
  800420fd14:	00 00 00 
  800420fd17:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420fd1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd1f:	48 bb 0f f7 20 04 80 	movabs $0x800420f70f,%rbx
  800420fd26:	00 00 00 
  800420fd29:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800420fd2d:	eb 24                	jmp    800420fd53 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420fd2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd33:	48 b9 10 f3 20 04 80 	movabs $0x800420f310,%rcx
  800420fd3a:	00 00 00 
  800420fd3d:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420fd41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd45:	48 be 3c f4 20 04 80 	movabs $0x800420f43c,%rsi
  800420fd4c:	00 00 00 
  800420fd4f:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420fd53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd57:	48 89 c7             	mov    %rax,%rdi
  800420fd5a:	48 b8 5d 12 21 04 80 	movabs $0x800421125d,%rax
  800420fd61:	00 00 00 
  800420fd64:	ff d0                	callq  *%rax
	return 0;
  800420fd66:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fd6b:	48 83 c4 18          	add    $0x18,%rsp
  800420fd6f:	5b                   	pop    %rbx
  800420fd70:	5d                   	pop    %rbp
  800420fd71:	c3                   	retq   

000000800420fd72 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420fd72:	55                   	push   %rbp
  800420fd73:	48 89 e5             	mov    %rsp,%rbp
  800420fd76:	48 83 ec 20          	sub    $0x20,%rsp
  800420fd7a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd7e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420fd82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd86:	48 8b 10             	mov    (%rax),%rdx
  800420fd89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd8d:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fd91:	48 39 c2             	cmp    %rax,%rdx
  800420fd94:	76 0a                	jbe    800420fda0 <_get_next_cu+0x2e>
		return -1;
  800420fd96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fd9b:	e9 6b 01 00 00       	jmpq   800420ff0b <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  800420fda0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fda4:	48 8b 00             	mov    (%rax),%rax
  800420fda7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420fdab:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fdaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fdb3:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420fdb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdbb:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fdbf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdc3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fdc7:	48 89 d1             	mov    %rdx,%rcx
  800420fdca:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fdce:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fdd3:	48 89 cf             	mov    %rcx,%rdi
  800420fdd6:	ff d0                	callq  *%rax
  800420fdd8:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420fddb:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420fddf:	75 2a                	jne    800420fe0b <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420fde1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fde5:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fde9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fded:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fdf1:	48 89 d1             	mov    %rdx,%rcx
  800420fdf4:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fdf8:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fdfd:	48 89 cf             	mov    %rcx,%rdi
  800420fe00:	ff d0                	callq  *%rax
  800420fe02:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420fe05:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420fe09:	eb 04                	jmp    800420fe0f <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420fe0b:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420fe0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe13:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fe17:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420fe1a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fe1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe21:	48 01 c2             	add    %rax,%rdx
  800420fe24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe28:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420fe2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe2f:	48 8b 10             	mov    (%rax),%rdx
  800420fe32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe36:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420fe3a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fe3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe41:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420fe44:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420fe48:	75 07                	jne    800420fe51 <_get_next_cu+0xdf>
  800420fe4a:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fe4f:	eb 05                	jmp    800420fe56 <_get_next_cu+0xe4>
  800420fe51:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420fe56:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fe5a:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420fe5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe61:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe69:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fe6d:	48 89 d1             	mov    %rdx,%rcx
  800420fe70:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fe74:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fe79:	48 89 cf             	mov    %rcx,%rdi
  800420fe7c:	ff d0                	callq  *%rax
  800420fe7e:	89 c2                	mov    %eax,%edx
  800420fe80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fe84:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420fe88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe8c:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe90:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fe94:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fe98:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420fe9c:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fea0:	48 89 cf             	mov    %rcx,%rdi
  800420fea3:	ff d0                	callq  *%rax
  800420fea5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420fea9:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420fead:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feb1:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420feb5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420feb9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420febd:	48 89 d1             	mov    %rdx,%rcx
  800420fec0:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  800420fec4:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fec9:	48 89 cf             	mov    %rcx,%rdi
  800420fecc:	ff d0                	callq  *%rax
  800420fece:	89 c2                	mov    %eax,%edx
  800420fed0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fed4:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420fed7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fedb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fedf:	66 83 f8 01          	cmp    $0x1,%ax
  800420fee3:	76 0e                	jbe    800420fef3 <_get_next_cu+0x181>
  800420fee5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fee9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420feed:	66 83 f8 04          	cmp    $0x4,%ax
  800420fef1:	76 07                	jbe    800420fefa <_get_next_cu+0x188>
		return -1;
  800420fef3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fef8:	eb 11                	jmp    800420ff0b <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  800420fefa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fefe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff02:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420ff06:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ff0b:	c9                   	leaveq 
  800420ff0c:	c3                   	retq   

000000800420ff0d <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420ff0d:	55                   	push   %rbp
  800420ff0e:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420ff11:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420ff15:	0f b6 c8             	movzbl %al,%ecx
  800420ff18:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420ff1c:	0f b7 d0             	movzwl %ax,%edx
  800420ff1f:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420ff23:	48 89 c6             	mov    %rax,%rsi
  800420ff26:	48 bf 72 99 21 04 80 	movabs $0x8004219972,%rdi
  800420ff2d:	00 00 00 
  800420ff30:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff35:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  800420ff3c:	00 00 00 
  800420ff3f:	41 ff d0             	callq  *%r8
}
  800420ff42:	5d                   	pop    %rbp
  800420ff43:	c3                   	retq   

000000800420ff44 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420ff44:	55                   	push   %rbp
  800420ff45:	48 89 e5             	mov    %rsp,%rbp
  800420ff48:	48 83 ec 60          	sub    $0x60,%rsp
  800420ff4c:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420ff50:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420ff54:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420ff58:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420ff5c:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420ff61:	75 35                	jne    800420ff98 <_dwarf_abbrev_parse+0x54>
  800420ff63:	48 b9 81 99 21 04 80 	movabs $0x8004219981,%rcx
  800420ff6a:	00 00 00 
  800420ff6d:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800420ff74:	00 00 00 
  800420ff77:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420ff7c:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800420ff83:	00 00 00 
  800420ff86:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff8b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420ff92:	00 00 00 
  800420ff95:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420ff98:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420ff9d:	75 35                	jne    800420ffd4 <_dwarf_abbrev_parse+0x90>
  800420ff9f:	48 b9 8d 99 21 04 80 	movabs $0x800421998d,%rcx
  800420ffa6:	00 00 00 
  800420ffa9:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800420ffb0:	00 00 00 
  800420ffb3:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420ffb8:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800420ffbf:	00 00 00 
  800420ffc2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ffc7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800420ffce:	00 00 00 
  800420ffd1:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420ffd4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ffd8:	48 8b 10             	mov    (%rax),%rdx
  800420ffdb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ffdf:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ffe3:	48 39 c2             	cmp    %rax,%rdx
  800420ffe6:	72 0a                	jb     800420fff2 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420ffe8:	b8 04 00 00 00       	mov    $0x4,%eax
  800420ffed:	e9 d3 01 00 00       	jmpq   80042101c5 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420fff2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fff6:	48 8b 00             	mov    (%rax),%rax
  800420fff9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420fffd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210001:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210005:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210009:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421000d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210011:	48 89 d6             	mov    %rdx,%rsi
  8004210014:	48 89 c7             	mov    %rax,%rdi
  8004210017:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  800421001e:	00 00 00 
  8004210021:	ff d0                	callq  *%rax
  8004210023:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004210027:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421002c:	75 15                	jne    8004210043 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800421002e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210032:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004210039:	b8 00 00 00 00       	mov    $0x0,%eax
  800421003e:	e9 82 01 00 00       	jmpq   80042101c5 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210043:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210047:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421004b:	48 89 d6             	mov    %rdx,%rsi
  800421004e:	48 89 c7             	mov    %rax,%rdi
  8004210051:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004210058:	00 00 00 
  800421005b:	ff d0                	callq  *%rax
  800421005d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210061:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210065:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210069:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800421006d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210071:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210076:	48 89 cf             	mov    %rcx,%rdi
  8004210079:	ff d0                	callq  *%rax
  800421007b:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800421007e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210082:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210086:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004210089:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421008d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210091:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004210095:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210099:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800421009d:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  80042100a0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100a4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042100a8:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  80042100ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100b0:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80042100b7:	00 
	abp->ab_atnum    = 0;
  80042100b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042100bc:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  80042100c3:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  80042100c4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042100c8:	48 8b 00             	mov    (%rax),%rax
  80042100cb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042100cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100d3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042100d7:	48 89 d6             	mov    %rdx,%rsi
  80042100da:	48 89 c7             	mov    %rax,%rdi
  80042100dd:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  80042100e4:	00 00 00 
  80042100e7:	ff d0                	callq  *%rax
  80042100e9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  80042100ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100f1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042100f5:	48 89 d6             	mov    %rdx,%rsi
  80042100f8:	48 89 c7             	mov    %rax,%rdi
  80042100fb:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004210102:	00 00 00 
  8004210105:	ff d0                	callq  *%rax
  8004210107:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800421010b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210110:	0f 84 89 00 00 00    	je     800421019f <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210116:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421011a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421011e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210122:	48 89 d0             	mov    %rdx,%rax
  8004210125:	48 01 c0             	add    %rax,%rax
  8004210128:	48 01 d0             	add    %rdx,%rax
  800421012b:	48 c1 e0 03          	shl    $0x3,%rax
  800421012f:	48 01 c8             	add    %rcx,%rax
  8004210132:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210136:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421013a:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800421013d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210141:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210145:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210149:	48 89 d0             	mov    %rdx,%rax
  800421014c:	48 01 c0             	add    %rax,%rax
  800421014f:	48 01 d0             	add    %rdx,%rax
  8004210152:	48 c1 e0 03          	shl    $0x3,%rax
  8004210156:	48 01 c8             	add    %rcx,%rax
  8004210159:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800421015d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210161:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210164:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210168:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421016c:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210170:	48 89 d0             	mov    %rdx,%rax
  8004210173:	48 01 c0             	add    %rax,%rax
  8004210176:	48 01 d0             	add    %rdx,%rax
  8004210179:	48 c1 e0 03          	shl    $0x3,%rax
  800421017d:	48 01 c8             	add    %rcx,%rax
  8004210180:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210184:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210188:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800421018b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421018f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210193:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210197:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421019b:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800421019f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042101a4:	0f 85 1a ff ff ff    	jne    80042100c4 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  80042101aa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042101ae:	48 8b 00             	mov    (%rax),%rax
  80042101b1:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  80042101b5:	48 89 c2             	mov    %rax,%rdx
  80042101b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042101bc:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  80042101c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042101c5:	c9                   	leaveq 
  80042101c6:	c3                   	retq   

00000080042101c7 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  80042101c7:	55                   	push   %rbp
  80042101c8:	48 89 e5             	mov    %rsp,%rbp
  80042101cb:	48 83 ec 70          	sub    $0x70,%rsp
  80042101cf:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042101d3:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042101d7:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  80042101db:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042101e0:	75 0a                	jne    80042101ec <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  80042101e2:	b8 04 00 00 00       	mov    $0x4,%eax
  80042101e7:	e9 0a 01 00 00       	jmpq   80042102f6 <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  80042101ec:	48 bf 98 99 21 04 80 	movabs $0x8004219998,%rdi
  80042101f3:	00 00 00 
  80042101f6:	48 b8 36 45 21 04 80 	movabs $0x8004214536,%rax
  80042101fd:	00 00 00 
  8004210200:	ff d0                	callq  *%rax
  8004210202:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210206:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421020b:	75 35                	jne    8004210242 <_dwarf_abbrev_find+0x7b>
  800421020d:	48 b9 8d 99 21 04 80 	movabs $0x800421998d,%rcx
  8004210214:	00 00 00 
  8004210217:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800421021e:	00 00 00 
  8004210221:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210226:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800421022d:	00 00 00 
  8004210230:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210235:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421023c:	00 00 00 
  800421023f:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210242:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210246:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  800421024a:	e9 8d 00 00 00       	jmpq   80042102dc <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800421024f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210253:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210257:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800421025b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421025f:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210263:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210267:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800421026b:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210270:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210274:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210279:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800421027d:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210282:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210286:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800421028b:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800421028f:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210294:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210298:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800421029d:	48 89 c7             	mov    %rax,%rdi
  80042102a0:	48 b8 44 ff 20 04 80 	movabs $0x800420ff44,%rax
  80042102a7:	00 00 00 
  80042102aa:	ff d0                	callq  *%rax
  80042102ac:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042102af:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042102b3:	74 05                	je     80042102ba <_dwarf_abbrev_find+0xf3>
			return (ret);
  80042102b5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042102b8:	eb 3c                	jmp    80042102f6 <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  80042102ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102be:	48 8b 00             	mov    (%rax),%rax
  80042102c1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042102c5:	75 07                	jne    80042102ce <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  80042102c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042102cc:	eb 28                	jmp    80042102f6 <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  80042102ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042102d2:	48 8b 00             	mov    (%rax),%rax
  80042102d5:	48 85 c0             	test   %rax,%rax
  80042102d8:	75 02                	jne    80042102dc <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  80042102da:	eb 15                	jmp    80042102f1 <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  80042102dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042102e0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042102e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102e8:	48 39 c2             	cmp    %rax,%rdx
  80042102eb:	0f 87 5e ff ff ff    	ja     800421024f <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  80042102f1:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042102f6:	c9                   	leaveq 
  80042102f7:	c3                   	retq   

00000080042102f8 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  80042102f8:	55                   	push   %rbp
  80042102f9:	48 89 e5             	mov    %rsp,%rbp
  80042102fc:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210303:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421030a:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210311:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210318:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800421031f:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210326:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800421032d:	48 bf a6 99 21 04 80 	movabs $0x80042199a6,%rdi
  8004210334:	00 00 00 
  8004210337:	48 b8 36 45 21 04 80 	movabs $0x8004214536,%rax
  800421033e:	00 00 00 
  8004210341:	ff d0                	callq  *%rax
  8004210343:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210347:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421034b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421034f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  8004210353:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421035a:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421035e:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004210361:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004210368:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800421036f:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210374:	be 00 00 00 00       	mov    $0x0,%esi
  8004210379:	48 89 c7             	mov    %rax,%rdi
  800421037c:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004210383:	00 00 00 
  8004210386:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210388:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800421038f:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210396:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421039d:	48 8b 00             	mov    (%rax),%rax
  80042103a0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042103a4:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042103ab:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042103af:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042103b3:	8b 45 10             	mov    0x10(%rbp),%eax
  80042103b6:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042103b9:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042103c0:	00 

	switch (form) {
  80042103c1:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  80042103c8:	20 
  80042103c9:	0f 87 82 04 00 00    	ja     8004210851 <_dwarf_attr_init+0x559>
  80042103cf:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042103d6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042103dd:	00 
  80042103de:	48 b8 d0 99 21 04 80 	movabs $0x80042199d0,%rax
  80042103e5:	00 00 00 
  80042103e8:	48 01 d0             	add    %rdx,%rax
  80042103eb:	48 8b 00             	mov    (%rax),%rax
  80042103ee:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042103f0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042103f7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042103fb:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210402:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210406:	0f b6 d2             	movzbl %dl,%edx
  8004210409:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210410:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210414:	48 89 cf             	mov    %rcx,%rdi
  8004210417:	ff d0                	callq  *%rax
  8004210419:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421041d:	e9 37 04 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210422:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210429:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421042d:	48 89 d6             	mov    %rdx,%rsi
  8004210430:	48 89 c7             	mov    %rax,%rdi
  8004210433:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  800421043a:	00 00 00 
  800421043d:	ff d0                	callq  *%rax
  800421043f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210443:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210447:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421044e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210452:	48 89 ce             	mov    %rcx,%rsi
  8004210455:	48 89 c7             	mov    %rax,%rdi
  8004210458:	48 b8 6f fb 20 04 80 	movabs $0x800420fb6f,%rax
  800421045f:	00 00 00 
  8004210462:	ff d0                	callq  *%rax
  8004210464:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210468:	e9 ec 03 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800421046d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210474:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210478:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421047f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210483:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210488:	48 89 cf             	mov    %rcx,%rdi
  800421048b:	ff d0                	callq  *%rax
  800421048d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210491:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210495:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421049c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104a0:	48 89 ce             	mov    %rcx,%rsi
  80042104a3:	48 89 c7             	mov    %rax,%rdi
  80042104a6:	48 b8 6f fb 20 04 80 	movabs $0x800420fb6f,%rax
  80042104ad:	00 00 00 
  80042104b0:	ff d0                	callq  *%rax
  80042104b2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042104b6:	e9 9e 03 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042104bb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042104c2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104c6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104cd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104d1:	ba 02 00 00 00       	mov    $0x2,%edx
  80042104d6:	48 89 cf             	mov    %rcx,%rdi
  80042104d9:	ff d0                	callq  *%rax
  80042104db:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042104df:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042104e3:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042104ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ee:	48 89 ce             	mov    %rcx,%rsi
  80042104f1:	48 89 c7             	mov    %rax,%rdi
  80042104f4:	48 b8 6f fb 20 04 80 	movabs $0x800420fb6f,%rax
  80042104fb:	00 00 00 
  80042104fe:	ff d0                	callq  *%rax
  8004210500:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210504:	e9 50 03 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210509:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210510:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210514:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421051b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421051f:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210524:	48 89 cf             	mov    %rcx,%rdi
  8004210527:	ff d0                	callq  *%rax
  8004210529:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421052d:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210531:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210538:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421053c:	48 89 ce             	mov    %rcx,%rsi
  800421053f:	48 89 c7             	mov    %rax,%rdi
  8004210542:	48 b8 6f fb 20 04 80 	movabs $0x800420fb6f,%rax
  8004210549:	00 00 00 
  800421054c:	ff d0                	callq  *%rax
  800421054e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210552:	e9 02 03 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210557:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421055e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210562:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210569:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421056d:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210572:	48 89 cf             	mov    %rcx,%rdi
  8004210575:	ff d0                	callq  *%rax
  8004210577:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421057b:	e9 d9 02 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210580:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210587:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421058b:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210592:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210596:	ba 02 00 00 00       	mov    $0x2,%edx
  800421059b:	48 89 cf             	mov    %rcx,%rdi
  800421059e:	ff d0                	callq  *%rax
  80042105a0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042105a4:	e9 b0 02 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042105a9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042105b0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042105b4:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042105bb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042105bf:	ba 04 00 00 00       	mov    $0x4,%edx
  80042105c4:	48 89 cf             	mov    %rcx,%rdi
  80042105c7:	ff d0                	callq  *%rax
  80042105c9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042105cd:	e9 87 02 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042105d2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042105d9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042105dd:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042105e4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042105e8:	ba 08 00 00 00       	mov    $0x8,%edx
  80042105ed:	48 89 cf             	mov    %rcx,%rdi
  80042105f0:	ff d0                	callq  *%rax
  80042105f2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042105f6:	e9 5e 02 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  80042105fb:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210602:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210606:	48 89 d6             	mov    %rdx,%rsi
  8004210609:	48 89 c7             	mov    %rax,%rdi
  800421060c:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004210613:	00 00 00 
  8004210616:	ff d0                	callq  *%rax
  8004210618:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800421061f:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004210626:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800421062d:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210634:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421063b:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210642:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210649:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  8004210650:	4d 89 c1             	mov    %r8,%r9
  8004210653:	49 89 f8             	mov    %rdi,%r8
  8004210656:	48 89 c7             	mov    %rax,%rdi
  8004210659:	48 b8 f8 02 21 04 80 	movabs $0x80042102f8,%rax
  8004210660:	00 00 00 
  8004210663:	ff d0                	callq  *%rax
  8004210665:	e9 1d 03 00 00       	jmpq   8004210987 <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  800421066a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210671:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210675:	66 83 f8 02          	cmp    $0x2,%ax
  8004210679:	75 2f                	jne    80042106aa <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800421067b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210682:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210686:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421068d:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004210691:	0f b6 d2             	movzbl %dl,%edx
  8004210694:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421069b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421069f:	48 89 cf             	mov    %rcx,%rdi
  80042106a2:	ff d0                	callq  *%rax
  80042106a4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042106a8:	eb 39                	jmp    80042106e3 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042106aa:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042106b1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042106b5:	66 83 f8 03          	cmp    $0x3,%ax
  80042106b9:	75 28                	jne    80042106e3 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042106bb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042106c2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042106c6:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042106ca:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042106d1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042106d5:	48 89 cf             	mov    %rcx,%rdi
  80042106d8:	ff d0                	callq  *%rax
  80042106da:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042106de:	e9 76 01 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
  80042106e3:	e9 71 01 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042106e8:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042106ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106f3:	48 89 d6             	mov    %rdx,%rsi
  80042106f6:	48 89 c7             	mov    %rax,%rdi
  80042106f9:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004210700:	00 00 00 
  8004210703:	ff d0                	callq  *%rax
  8004210705:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210709:	e9 4b 01 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421070e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210715:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210719:	48 89 d6             	mov    %rdx,%rsi
  800421071c:	48 89 c7             	mov    %rax,%rdi
  800421071f:	48 b8 be f8 20 04 80 	movabs $0x800420f8be,%rax
  8004210726:	00 00 00 
  8004210729:	ff d0                	callq  *%rax
  800421072b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421072f:	e9 25 01 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210734:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421073b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421073f:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210743:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421074a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421074e:	48 89 cf             	mov    %rcx,%rdi
  8004210751:	ff d0                	callq  *%rax
  8004210753:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210757:	e9 fd 00 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800421075c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210760:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004210764:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421076b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421076f:	48 89 ce             	mov    %rcx,%rsi
  8004210772:	48 89 c7             	mov    %rax,%rdi
  8004210775:	48 b8 e0 fa 20 04 80 	movabs $0x800420fae0,%rax
  800421077c:	00 00 00 
  800421077f:	ff d0                	callq  *%rax
  8004210781:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210785:	e9 cf 00 00 00       	jmpq   8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800421078a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210791:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210795:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004210799:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042107a0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042107a4:	48 89 cf             	mov    %rcx,%rdi
  80042107a7:	ff d0                	callq  *%rax
  80042107a9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042107ad:	48 bf b2 99 21 04 80 	movabs $0x80042199b2,%rdi
  80042107b4:	00 00 00 
  80042107b7:	48 b8 36 45 21 04 80 	movabs $0x8004214536,%rax
  80042107be:	00 00 00 
  80042107c1:	ff d0                	callq  *%rax
  80042107c3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042107c7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042107cc:	75 35                	jne    8004210803 <_dwarf_attr_init+0x50b>
  80042107ce:	48 b9 bd 99 21 04 80 	movabs $0x80042199bd,%rcx
  80042107d5:	00 00 00 
  80042107d8:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  80042107df:	00 00 00 
  80042107e2:	be 51 02 00 00       	mov    $0x251,%esi
  80042107e7:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  80042107ee:	00 00 00 
  80042107f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107f6:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042107fd:	00 00 00 
  8004210800:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004210803:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210807:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421080b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421080f:	48 01 d0             	add    %rdx,%rax
  8004210812:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210816:	eb 41                	jmp    8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004210818:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421081f:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  8004210820:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210824:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421082b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421082f:	48 89 ce             	mov    %rcx,%rsi
  8004210832:	48 89 c7             	mov    %rax,%rdi
  8004210835:	48 b8 6f fb 20 04 80 	movabs $0x800420fb6f,%rax
  800421083c:	00 00 00 
  800421083f:	ff d0                	callq  *%rax
  8004210841:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210845:	eb 12                	jmp    8004210859 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004210847:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421084e:	00 
		break;
  800421084f:	eb 08                	jmp    8004210859 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  8004210851:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004210858:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004210859:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421085d:	0f 85 21 01 00 00    	jne    8004210984 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004210863:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  800421086a:	09 
  800421086b:	74 1e                	je     800421088b <_dwarf_attr_init+0x593>
  800421086d:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004210874:	0a 
  8004210875:	74 14                	je     800421088b <_dwarf_attr_init+0x593>
  8004210877:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800421087e:	03 
  800421087f:	74 0a                	je     800421088b <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  8004210881:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004210888:	04 
  8004210889:	75 10                	jne    800421089b <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  800421088b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421088f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  8004210893:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210897:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  800421089b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421089f:	48 83 f8 03          	cmp    $0x3,%rax
  80042108a3:	75 39                	jne    80042108de <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042108a5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042108a9:	48 83 f8 08          	cmp    $0x8,%rax
  80042108ad:	74 1c                	je     80042108cb <_dwarf_attr_init+0x5d3>
  80042108af:	48 83 f8 0e          	cmp    $0xe,%rax
  80042108b3:	74 02                	je     80042108b7 <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042108b5:	eb 27                	jmp    80042108de <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042108b7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042108bb:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042108c2:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042108c9:	eb 13                	jmp    80042108de <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042108cb:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042108cf:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042108d6:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042108dd:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  80042108de:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042108e5:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  80042108ec:	8d 48 01             	lea    0x1(%rax),%ecx
  80042108ef:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  80042108f6:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  80042108fc:	0f b6 c0             	movzbl %al,%eax
  80042108ff:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210906:	48 63 d0             	movslq %eax,%rdx
  8004210909:	48 89 d0             	mov    %rdx,%rax
  800421090c:	48 01 c0             	add    %rax,%rax
  800421090f:	48 01 d0             	add    %rdx,%rax
  8004210912:	48 c1 e0 05          	shl    $0x5,%rax
  8004210916:	48 01 c8             	add    %rcx,%rax
  8004210919:	48 05 70 03 00 00    	add    $0x370,%rax
  800421091f:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210926:	48 89 10             	mov    %rdx,(%rax)
  8004210929:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004210930:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004210934:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004210938:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421093c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004210940:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004210944:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004210948:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421094c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210950:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004210954:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210958:	48 89 50 30          	mov    %rdx,0x30(%rax)
  800421095c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004210960:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004210964:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210968:	48 89 50 40          	mov    %rdx,0x40(%rax)
  800421096c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004210970:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004210974:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210978:	48 89 50 50          	mov    %rdx,0x50(%rax)
  800421097c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210980:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004210984:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210987:	c9                   	leaveq 
  8004210988:	c3                   	retq   

0000008004210989 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004210989:	55                   	push   %rbp
  800421098a:	48 89 e5             	mov    %rsp,%rbp
  800421098d:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  8004210994:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  800421099b:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042109a2:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042109a9:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042109af:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042109b6:	00 
  80042109b7:	75 35                	jne    80042109ee <dwarf_search_die_within_cu+0x65>
  80042109b9:	48 b9 d8 9a 21 04 80 	movabs $0x8004219ad8,%rcx
  80042109c0:	00 00 00 
  80042109c3:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  80042109ca:	00 00 00 
  80042109cd:	be 86 02 00 00       	mov    $0x286,%esi
  80042109d2:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  80042109d9:	00 00 00 
  80042109dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042109e1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042109e8:	00 00 00 
  80042109eb:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  80042109ee:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  80042109f5:	00 
  80042109f6:	75 35                	jne    8004210a2d <dwarf_search_die_within_cu+0xa4>
  80042109f8:	48 b9 dc 9a 21 04 80 	movabs $0x8004219adc,%rcx
  80042109ff:	00 00 00 
  8004210a02:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210a09:	00 00 00 
  8004210a0c:	be 88 02 00 00       	mov    $0x288,%esi
  8004210a11:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210a18:	00 00 00 
  8004210a1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a20:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210a27:	00 00 00 
  8004210a2a:	41 ff d0             	callq  *%r8

	level = 1;
  8004210a2d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210a34:	e9 17 02 00 00       	jmpq   8004210c50 <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004210a39:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210a40:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004210a44:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210a4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210a4f:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004210a56:	48 89 d6             	mov    %rdx,%rsi
  8004210a59:	48 89 c7             	mov    %rax,%rdi
  8004210a5c:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004210a63:	00 00 00 
  8004210a66:	ff d0                	callq  *%rax
  8004210a68:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004210a6c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210a71:	75 22                	jne    8004210a95 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  8004210a73:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210a77:	74 09                	je     8004210a82 <dwarf_search_die_within_cu+0xf9>
  8004210a79:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210a80:	75 0a                	jne    8004210a8c <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004210a82:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210a87:	e9 f4 01 00 00       	jmpq   8004210c80 <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  8004210a8c:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  8004210a90:	e9 bb 01 00 00       	jmpq   8004210c50 <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  8004210a95:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210a9c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210aa0:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210aa7:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004210aab:	48 89 34 24          	mov    %rsi,(%rsp)
  8004210aaf:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  8004210ab3:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  8004210ab8:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  8004210abc:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004210ac1:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004210ac5:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004210aca:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  8004210ace:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004210ad3:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004210ad7:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004210adc:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004210ae0:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004210ae5:	48 89 ce             	mov    %rcx,%rsi
  8004210ae8:	48 89 c7             	mov    %rax,%rdi
  8004210aeb:	48 b8 c7 01 21 04 80 	movabs $0x80042101c7,%rax
  8004210af2:	00 00 00 
  8004210af5:	ff d0                	callq  *%rax
  8004210af7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210afa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210afe:	74 08                	je     8004210b08 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  8004210b00:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210b03:	e9 78 01 00 00       	jmpq   8004210c80 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004210b08:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210b0f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b13:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004210b16:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210b1d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210b21:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004210b25:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210b2c:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004210b30:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210b37:	b8 66 00 00 00       	mov    $0x66,%eax
  8004210b3c:	48 89 d6             	mov    %rdx,%rsi
  8004210b3f:	48 89 c1             	mov    %rax,%rcx
  8004210b42:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004210b45:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210b4c:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004210b53:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004210b5a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210b61:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210b65:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004210b6c:	e9 8e 00 00 00       	jmpq   8004210bff <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004210b71:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210b74:	48 63 d0             	movslq %eax,%rdx
  8004210b77:	48 89 d0             	mov    %rdx,%rax
  8004210b7a:	48 01 c0             	add    %rax,%rax
  8004210b7d:	48 01 d0             	add    %rdx,%rax
  8004210b80:	48 c1 e0 03          	shl    $0x3,%rax
  8004210b84:	48 01 e8             	add    %rbp,%rax
  8004210b87:	48 2d 18 03 00 00    	sub    $0x318,%rax
  8004210b8d:	48 8b 08             	mov    (%rax),%rcx
  8004210b90:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004210b97:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210b9a:	48 63 d0             	movslq %eax,%rdx
  8004210b9d:	48 89 d0             	mov    %rdx,%rax
  8004210ba0:	48 01 c0             	add    %rax,%rax
  8004210ba3:	48 01 d0             	add    %rdx,%rax
  8004210ba6:	48 c1 e0 03          	shl    $0x3,%rax
  8004210baa:	48 83 c0 30          	add    $0x30,%rax
  8004210bae:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  8004210bb2:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  8004210bb9:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004210bc0:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210bc7:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  8004210bce:	49 89 c9             	mov    %rcx,%r9
  8004210bd1:	49 89 f8             	mov    %rdi,%r8
  8004210bd4:	48 89 d1             	mov    %rdx,%rcx
  8004210bd7:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004210bdb:	48 89 c7             	mov    %rax,%rdi
  8004210bde:	48 b8 f8 02 21 04 80 	movabs $0x80042102f8,%rax
  8004210be5:	00 00 00 
  8004210be8:	ff d0                	callq  *%rax
  8004210bea:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004210bed:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210bf1:	74 08                	je     8004210bfb <dwarf_search_die_within_cu+0x272>
				return (ret);
  8004210bf3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210bf6:	e9 85 00 00 00       	jmpq   8004210c80 <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210bfb:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004210bff:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210c02:	48 63 d0             	movslq %eax,%rdx
  8004210c05:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004210c0c:	48 39 c2             	cmp    %rax,%rdx
  8004210c0f:	0f 82 5c ff ff ff    	jb     8004210b71 <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004210c15:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004210c1c:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210c23:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004210c27:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210c2e:	74 19                	je     8004210c49 <dwarf_search_die_within_cu+0x2c0>
  8004210c30:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210c34:	7e 13                	jle    8004210c49 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210c36:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004210c3d:	3c 01                	cmp    $0x1,%al
  8004210c3f:	75 06                	jne    8004210c47 <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  8004210c41:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210c45:	eb 09                	jmp    8004210c50 <dwarf_search_die_within_cu+0x2c7>
  8004210c47:	eb 07                	jmp    8004210c50 <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004210c49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c4e:	eb 30                	jmp    8004210c80 <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210c50:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004210c54:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210c5b:	48 39 c2             	cmp    %rax,%rdx
  8004210c5e:	76 1b                	jbe    8004210c7b <dwarf_search_die_within_cu+0x2f2>
  8004210c60:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210c67:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210c6b:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210c72:	48 39 c2             	cmp    %rax,%rdx
  8004210c75:	0f 87 be fd ff ff    	ja     8004210a39 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004210c7b:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210c80:	c9                   	leaveq 
  8004210c81:	c3                   	retq   

0000008004210c82 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004210c82:	55                   	push   %rbp
  8004210c83:	48 89 e5             	mov    %rsp,%rbp
  8004210c86:	48 83 ec 60          	sub    $0x60,%rsp
  8004210c8a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c8e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210c92:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004210c96:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210c9b:	75 35                	jne    8004210cd2 <dwarf_offdie+0x50>
  8004210c9d:	48 b9 d8 9a 21 04 80 	movabs $0x8004219ad8,%rcx
  8004210ca4:	00 00 00 
  8004210ca7:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210cae:	00 00 00 
  8004210cb1:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004210cb6:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210cbd:	00 00 00 
  8004210cc0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210cc5:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210ccc:	00 00 00 
  8004210ccf:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210cd2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210cd7:	75 35                	jne    8004210d0e <dwarf_offdie+0x8c>
  8004210cd9:	48 b9 dc 9a 21 04 80 	movabs $0x8004219adc,%rcx
  8004210ce0:	00 00 00 
  8004210ce3:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210cea:	00 00 00 
  8004210ced:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004210cf2:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210cf9:	00 00 00 
  8004210cfc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210d01:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210d08:	00 00 00 
  8004210d0b:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004210d0e:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004210d12:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210d16:	76 66                	jbe    8004210d7e <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004210d18:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210d1c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004210d20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d24:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004210d28:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004210d2c:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004210d30:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210d35:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004210d39:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004210d3e:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004210d42:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210d47:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004210d4b:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004210d50:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004210d54:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210d59:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004210d5d:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004210d62:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210d67:	48 89 c7             	mov    %rax,%rdi
  8004210d6a:	48 b8 89 09 21 04 80 	movabs $0x8004210989,%rax
  8004210d71:	00 00 00 
  8004210d74:	ff d0                	callq  *%rax
  8004210d76:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004210d79:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210d7c:	eb 05                	jmp    8004210d83 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004210d7e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210d83:	c9                   	leaveq 
  8004210d84:	c3                   	retq   

0000008004210d85 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004210d85:	55                   	push   %rbp
  8004210d86:	48 89 e5             	mov    %rsp,%rbp
  8004210d89:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210d8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d91:	89 f0                	mov    %esi,%eax
  8004210d93:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004210d97:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210d9e:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210d9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004210da6:	eb 57                	jmp    8004210dff <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004210da8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210dac:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210daf:	48 63 d0             	movslq %eax,%rdx
  8004210db2:	48 89 d0             	mov    %rdx,%rax
  8004210db5:	48 01 c0             	add    %rax,%rax
  8004210db8:	48 01 d0             	add    %rdx,%rax
  8004210dbb:	48 c1 e0 05          	shl    $0x5,%rax
  8004210dbf:	48 01 c8             	add    %rcx,%rax
  8004210dc2:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210dc8:	48 8b 10             	mov    (%rax),%rdx
  8004210dcb:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004210dcf:	48 39 c2             	cmp    %rax,%rdx
  8004210dd2:	75 27                	jne    8004210dfb <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004210dd4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210dd7:	48 63 d0             	movslq %eax,%rdx
  8004210dda:	48 89 d0             	mov    %rdx,%rax
  8004210ddd:	48 01 c0             	add    %rax,%rax
  8004210de0:	48 01 d0             	add    %rdx,%rax
  8004210de3:	48 c1 e0 05          	shl    $0x5,%rax
  8004210de7:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004210dee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210df2:	48 01 d0             	add    %rdx,%rax
  8004210df5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004210df9:	eb 17                	jmp    8004210e12 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210dfb:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004210dff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e03:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210e0a:	0f b6 c0             	movzbl %al,%eax
  8004210e0d:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004210e10:	7f 96                	jg     8004210da8 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004210e12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210e16:	c9                   	leaveq 
  8004210e17:	c3                   	retq   

0000008004210e18 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004210e18:	55                   	push   %rbp
  8004210e19:	48 89 e5             	mov    %rsp,%rbp
  8004210e1c:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004210e20:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210e24:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210e28:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004210e2c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004210e30:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210e35:	75 35                	jne    8004210e6c <dwarf_siblingof+0x54>
  8004210e37:	48 b9 d8 9a 21 04 80 	movabs $0x8004219ad8,%rcx
  8004210e3e:	00 00 00 
  8004210e41:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210e48:	00 00 00 
  8004210e4b:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004210e50:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210e57:	00 00 00 
  8004210e5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e5f:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210e66:	00 00 00 
  8004210e69:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210e6c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210e71:	75 35                	jne    8004210ea8 <dwarf_siblingof+0x90>
  8004210e73:	48 b9 dc 9a 21 04 80 	movabs $0x8004219adc,%rcx
  8004210e7a:	00 00 00 
  8004210e7d:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210e84:	00 00 00 
  8004210e87:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004210e8c:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210e93:	00 00 00 
  8004210e96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e9b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210ea2:	00 00 00 
  8004210ea5:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210ea8:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004210ead:	75 35                	jne    8004210ee4 <dwarf_siblingof+0xcc>
  8004210eaf:	48 b9 e4 9a 21 04 80 	movabs $0x8004219ae4,%rcx
  8004210eb6:	00 00 00 
  8004210eb9:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004210ec0:	00 00 00 
  8004210ec3:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004210ec8:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004210ecf:	00 00 00 
  8004210ed2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ed7:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004210ede:	00 00 00 
  8004210ee1:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004210ee4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210ee9:	75 65                	jne    8004210f50 <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004210eeb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210eef:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004210ef3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210ef7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210efb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210eff:	48 8b 38             	mov    (%rax),%rdi
  8004210f02:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210f06:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210f0a:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210f0f:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004210f13:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210f18:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004210f1c:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210f21:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004210f25:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210f2a:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004210f2e:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210f33:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210f37:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210f3c:	48 89 cf             	mov    %rcx,%rdi
  8004210f3f:	48 b8 82 0c 21 04 80 	movabs $0x8004210c82,%rax
  8004210f46:	00 00 00 
  8004210f49:	ff d0                	callq  *%rax
  8004210f4b:	e9 0a 01 00 00       	jmpq   800421105a <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004210f50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210f57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f5b:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210f5f:	84 c0                	test   %al,%al
  8004210f61:	75 0e                	jne    8004210f71 <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004210f63:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f67:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f6b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210f6f:	eb 6b                	jmp    8004210fdc <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004210f71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f75:	be 01 00 00 00       	mov    $0x1,%esi
  8004210f7a:	48 89 c7             	mov    %rax,%rdi
  8004210f7d:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  8004210f84:	00 00 00 
  8004210f87:	ff d0                	callq  *%rax
  8004210f89:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210f8d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210f92:	74 35                	je     8004210fc9 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004210f94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f98:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210f9c:	48 83 f8 10          	cmp    $0x10,%rax
  8004210fa0:	74 19                	je     8004210fbb <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004210fa2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fa6:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210faa:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210fae:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210fb2:	48 01 d0             	add    %rdx,%rax
  8004210fb5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210fb9:	eb 21                	jmp    8004210fdc <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004210fbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fbf:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210fc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210fc7:	eb 13                	jmp    8004210fdc <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004210fc9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210fcd:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210fd1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004210fd5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004210fdc:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004210fdf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210fe3:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210fe7:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004210feb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210fef:	4c 8b 00             	mov    (%rax),%r8
  8004210ff2:	4c 89 04 24          	mov    %r8,(%rsp)
  8004210ff6:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210ffa:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004210fff:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211003:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211008:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421100c:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211011:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211015:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  800421101a:	4c 8b 40 28          	mov    0x28(%rax),%r8
  800421101e:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211023:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211027:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421102c:	48 b8 89 09 21 04 80 	movabs $0x8004210989,%rax
  8004211033:	00 00 00 
  8004211036:	ff d0                	callq  *%rax
  8004211038:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  800421103b:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800421103f:	75 07                	jne    8004211048 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004211041:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211046:	eb 12                	jmp    800421105a <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004211048:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421104c:	74 07                	je     8004211055 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  800421104e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211053:	eb 05                	jmp    800421105a <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004211055:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421105a:	c9                   	leaveq 
  800421105b:	c3                   	retq   

000000800421105c <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800421105c:	55                   	push   %rbp
  800421105d:	48 89 e5             	mov    %rsp,%rbp
  8004211060:	48 83 ec 70          	sub    $0x70,%rsp
  8004211064:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211068:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421106c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211070:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004211074:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211079:	75 35                	jne    80042110b0 <dwarf_child+0x54>
  800421107b:	48 b9 e7 9a 21 04 80 	movabs $0x8004219ae7,%rcx
  8004211082:	00 00 00 
  8004211085:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  800421108c:	00 00 00 
  800421108f:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211094:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800421109b:	00 00 00 
  800421109e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110a3:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042110aa:	00 00 00 
  80042110ad:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042110b0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042110b5:	75 35                	jne    80042110ec <dwarf_child+0x90>
  80042110b7:	48 b9 dc 9a 21 04 80 	movabs $0x8004219adc,%rcx
  80042110be:	00 00 00 
  80042110c1:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  80042110c8:	00 00 00 
  80042110cb:	be 1d 03 00 00       	mov    $0x31d,%esi
  80042110d0:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  80042110d7:	00 00 00 
  80042110da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110df:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042110e6:	00 00 00 
  80042110e9:	41 ff d0             	callq  *%r8
	assert(dbg);
  80042110ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042110f1:	75 35                	jne    8004211128 <dwarf_child+0xcc>
  80042110f3:	48 b9 d8 9a 21 04 80 	movabs $0x8004219ad8,%rcx
  80042110fa:	00 00 00 
  80042110fd:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004211104:	00 00 00 
  8004211107:	be 1e 03 00 00       	mov    $0x31e,%esi
  800421110c:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  8004211113:	00 00 00 
  8004211116:	b8 00 00 00 00       	mov    $0x0,%eax
  800421111b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004211122:	00 00 00 
  8004211125:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211128:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421112d:	75 35                	jne    8004211164 <dwarf_child+0x108>
  800421112f:	48 b9 e4 9a 21 04 80 	movabs $0x8004219ae4,%rcx
  8004211136:	00 00 00 
  8004211139:	48 ba 4a 99 21 04 80 	movabs $0x800421994a,%rdx
  8004211140:	00 00 00 
  8004211143:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211148:	48 bf 5f 99 21 04 80 	movabs $0x800421995f,%rdi
  800421114f:	00 00 00 
  8004211152:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211157:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421115e:	00 00 00 
  8004211161:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211164:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211168:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800421116c:	84 c0                	test   %al,%al
  800421116e:	75 0a                	jne    800421117a <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004211170:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211175:	e9 84 00 00 00       	jmpq   80042111fe <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  800421117a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421117e:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211182:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211186:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  800421118a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421118e:	48 8b 08             	mov    (%rax),%rcx
  8004211191:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211195:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211199:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421119e:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042111a2:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  80042111a7:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042111ab:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  80042111b0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042111b4:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042111b9:	48 8b 48 28          	mov    0x28(%rax),%rcx
  80042111bd:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  80042111c2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042111c6:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  80042111cb:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042111d0:	48 b8 89 09 21 04 80 	movabs $0x8004210989,%rax
  80042111d7:	00 00 00 
  80042111da:	ff d0                	callq  *%rax
  80042111dc:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  80042111df:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  80042111e3:	75 07                	jne    80042111ec <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042111e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042111ea:	eb 12                	jmp    80042111fe <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  80042111ec:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042111f0:	74 07                	je     80042111f9 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  80042111f2:	b8 01 00 00 00       	mov    $0x1,%eax
  80042111f7:	eb 05                	jmp    80042111fe <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  80042111f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042111fe:	c9                   	leaveq 
  80042111ff:	c3                   	retq   

0000008004211200 <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211200:	55                   	push   %rbp
  8004211201:	48 89 e5             	mov    %rsp,%rbp
  8004211204:	48 83 ec 20          	sub    $0x20,%rsp
  8004211208:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  800421120c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211210:	48 8b 00             	mov    (%rax),%rax
  8004211213:	48 89 c7             	mov    %rax,%rdi
  8004211216:	48 b8 36 45 21 04 80 	movabs $0x8004214536,%rax
  800421121d:	00 00 00 
  8004211220:	ff d0                	callq  *%rax
  8004211222:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211226:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421122a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421122e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211232:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004211236:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421123a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421123e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211242:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004211246:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421124a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421124e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211252:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004211256:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421125b:	c9                   	leaveq 
  800421125c:	c3                   	retq   

000000800421125d <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  800421125d:	55                   	push   %rbp
  800421125e:	48 89 e5             	mov    %rsp,%rbp
  8004211261:	48 83 ec 08          	sub    $0x8,%rsp
  8004211265:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211269:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421126d:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211277:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  800421127d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211281:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211287:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421128b:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211291:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211295:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  800421129b:	c9                   	leaveq 
  800421129c:	c3                   	retq   

000000800421129d <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  800421129d:	55                   	push   %rbp
  800421129e:	48 89 e5             	mov    %rsp,%rbp
  80042112a1:	48 83 ec 40          	sub    $0x40,%rsp
  80042112a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042112a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042112ad:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042112b1:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042112b5:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  80042112b9:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	Dwarf_Fde fde = ret_fde;
  80042112bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042112c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  80042112c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112c9:	ba 80 00 00 00       	mov    $0x80,%edx
  80042112ce:	be 00 00 00 00       	mov    $0x0,%esi
  80042112d3:	48 89 c7             	mov    %rax,%rdi
  80042112d6:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042112dd:	00 00 00 
  80042112e0:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  80042112e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042112e6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042112ea:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
  80042112ee:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042112f3:	74 0e                	je     8004211303 <dwarf_get_fde_at_pc+0x66>
  80042112f5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042112fa:	74 07                	je     8004211303 <dwarf_get_fde_at_pc+0x66>
  80042112fc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211301:	75 07                	jne    800421130a <dwarf_get_fde_at_pc+0x6d>
                return (DW_DLV_ERROR);
  8004211303:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211308:	eb 78                	jmp    8004211382 <dwarf_get_fde_at_pc+0xe5>

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  800421130a:	eb 5c                	jmp    8004211368 <dwarf_get_fde_at_pc+0xcb>
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  800421130c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211310:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211314:	48 89 d1             	mov    %rdx,%rcx
  8004211317:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421131b:	be 01 00 00 00       	mov    $0x1,%esi
  8004211320:	48 89 c7             	mov    %rax,%rdi
  8004211323:	48 b8 c1 34 21 04 80 	movabs $0x80042134c1,%rax
  800421132a:	00 00 00 
  800421132d:	ff d0                	callq  *%rax
  800421132f:	85 c0                	test   %eax,%eax
  8004211331:	79 07                	jns    800421133a <dwarf_get_fde_at_pc+0x9d>
		{
			return DW_DLV_NO_ENTRY;
  8004211333:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211338:	eb 48                	jmp    8004211382 <dwarf_get_fde_at_pc+0xe5>
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800421133a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421133e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211342:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211346:	77 20                	ja     8004211368 <dwarf_get_fde_at_pc+0xcb>
  8004211348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421134c:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange)
  8004211350:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211354:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211358:	48 01 d0             	add    %rdx,%rax
  800421135b:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421135f:	76 07                	jbe    8004211368 <dwarf_get_fde_at_pc+0xcb>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
  8004211361:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211366:	eb 1a                	jmp    8004211382 <dwarf_get_fde_at_pc+0xe5>
	fde->fde_cie = cie;
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
                return (DW_DLV_ERROR);

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004211368:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421136c:	48 8b 50 38          	mov    0x38(%rax),%rdx
  8004211370:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211374:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004211378:	48 39 c2             	cmp    %rax,%rdx
  800421137b:	72 8f                	jb     800421130c <dwarf_get_fde_at_pc+0x6f>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  800421137d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211382:	c9                   	leaveq 
  8004211383:	c3                   	retq   

0000008004211384 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004211384:	55                   	push   %rbp
  8004211385:	48 89 e5             	mov    %rsp,%rbp
  8004211388:	53                   	push   %rbx
  8004211389:	48 83 ec 38          	sub    $0x38,%rsp
  800421138d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211391:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211395:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211399:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  800421139d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042113a2:	75 35                	jne    80042113d9 <_dwarf_frame_regtable_copy+0x55>
  80042113a4:	48 b9 fa 9a 21 04 80 	movabs $0x8004219afa,%rcx
  80042113ab:	00 00 00 
  80042113ae:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  80042113b5:	00 00 00 
  80042113b8:	be 57 00 00 00       	mov    $0x57,%esi
  80042113bd:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  80042113c4:	00 00 00 
  80042113c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042113cc:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042113d3:	00 00 00 
  80042113d6:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  80042113d9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042113de:	75 35                	jne    8004211415 <_dwarf_frame_regtable_copy+0x91>
  80042113e0:	48 b9 32 9b 21 04 80 	movabs $0x8004219b32,%rcx
  80042113e7:	00 00 00 
  80042113ea:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  80042113f1:	00 00 00 
  80042113f4:	be 58 00 00 00       	mov    $0x58,%esi
  80042113f9:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  8004211400:	00 00 00 
  8004211403:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211408:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421140f:	00 00 00 
  8004211412:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004211415:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211419:	48 8b 00             	mov    (%rax),%rax
  800421141c:	48 85 c0             	test   %rax,%rax
  800421141f:	75 39                	jne    800421145a <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  8004211421:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211425:	48 bb e0 56 37 04 80 	movabs $0x80043756e0,%rbx
  800421142c:	00 00 00 
  800421142f:	48 89 18             	mov    %rbx,(%rax)
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004211432:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211436:	48 8b 00             	mov    (%rax),%rax
  8004211439:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421143d:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004211441:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004211445:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211449:	48 8b 00             	mov    (%rax),%rax
  800421144c:	48 bb 80 59 37 04 80 	movabs $0x8004375980,%rbx
  8004211453:	00 00 00 
  8004211456:	48 89 58 20          	mov    %rbx,0x20(%rax)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  800421145a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421145e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211462:	48 8b 00             	mov    (%rax),%rax
  8004211465:	ba 18 00 00 00       	mov    $0x18,%edx
  800421146a:	48 89 ce             	mov    %rcx,%rsi
  800421146d:	48 89 c7             	mov    %rax,%rdi
  8004211470:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  8004211477:	00 00 00 
  800421147a:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421147c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004211483:	eb 5a                	jmp    80042114df <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004211485:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211489:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421148d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211490:	48 63 d0             	movslq %eax,%rdx
  8004211493:	48 89 d0             	mov    %rdx,%rax
  8004211496:	48 01 c0             	add    %rax,%rax
  8004211499:	48 01 d0             	add    %rdx,%rax
  800421149c:	48 c1 e0 03          	shl    $0x3,%rax
  80042114a0:	48 01 c1             	add    %rax,%rcx
  80042114a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042114a7:	48 8b 00             	mov    (%rax),%rax
  80042114aa:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042114ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042114b1:	48 63 d0             	movslq %eax,%rdx
  80042114b4:	48 89 d0             	mov    %rdx,%rax
  80042114b7:	48 01 c0             	add    %rax,%rax
  80042114ba:	48 01 d0             	add    %rdx,%rax
  80042114bd:	48 c1 e0 03          	shl    $0x3,%rax
  80042114c1:	48 01 f0             	add    %rsi,%rax
  80042114c4:	ba 18 00 00 00       	mov    $0x18,%edx
  80042114c9:	48 89 ce             	mov    %rcx,%rsi
  80042114cc:	48 89 c7             	mov    %rax,%rdi
  80042114cf:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  80042114d6:	00 00 00 
  80042114d9:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  80042114db:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042114df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042114e3:	48 8b 00             	mov    (%rax),%rax
  80042114e6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042114ea:	0f b7 c0             	movzwl %ax,%eax
  80042114ed:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042114f0:	7e 10                	jle    8004211502 <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  80042114f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042114f6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042114fa:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042114fd:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211500:	7f 83                	jg     8004211485 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211502:	eb 32                	jmp    8004211536 <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  8004211504:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211508:	48 8b 00             	mov    (%rax),%rax
  800421150b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421150f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004211512:	48 63 d0             	movslq %eax,%rdx
  8004211515:	48 89 d0             	mov    %rdx,%rax
  8004211518:	48 01 c0             	add    %rax,%rax
  800421151b:	48 01 d0             	add    %rdx,%rax
  800421151e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211522:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004211526:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421152a:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  800421152e:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211532:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004211536:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421153a:	48 8b 00             	mov    (%rax),%rax
  800421153d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211541:	0f b7 c0             	movzwl %ax,%eax
  8004211544:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004211547:	7f bb                	jg     8004211504 <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004211549:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421154e:	48 83 c4 38          	add    $0x38,%rsp
  8004211552:	5b                   	pop    %rbx
  8004211553:	5d                   	pop    %rbp
  8004211554:	c3                   	retq   

0000008004211555 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004211555:	55                   	push   %rbp
  8004211556:	48 89 e5             	mov    %rsp,%rbp
  8004211559:	53                   	push   %rbx
  800421155a:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004211561:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004211565:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004211569:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  800421156d:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004211571:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004211578:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
                        ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
                        goto program_done;                              \
                }                                                       \
        } while(0)

        ret = DW_DLE_NONE;
  800421157f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004211586:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800421158d:	00 
  800421158e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211592:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  8004211596:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421159a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421159e:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  80042115a1:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042115a5:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042115a9:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  80042115ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115b1:	48 89 c7             	mov    %rax,%rdi
  80042115b4:	48 b8 84 13 21 04 80 	movabs $0x8004211384,%rax
  80042115bb:	00 00 00 
  80042115be:	ff d0                	callq  *%rax
        p = insts;
  80042115c0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042115c4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  80042115c8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042115cc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042115d0:	48 01 d0             	add    %rdx,%rax
  80042115d3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  80042115d7:	e9 3a 0d 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                if (*p == DW_CFA_nop) {
  80042115dc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042115e0:	0f b6 00             	movzbl (%rax),%eax
  80042115e3:	84 c0                	test   %al,%al
  80042115e5:	75 11                	jne    80042115f8 <_dwarf_frame_run_inst+0xa3>
                        p++;
  80042115e7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042115eb:	48 83 c0 01          	add    $0x1,%rax
  80042115ef:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  80042115f3:	e9 1e 0d 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                }

                high2 = *p & 0xc0;
  80042115f8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042115fc:	0f b6 00             	movzbl (%rax),%eax
  80042115ff:	83 e0 c0             	and    $0xffffffc0,%eax
  8004211602:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004211605:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211609:	0f b6 00             	movzbl (%rax),%eax
  800421160c:	83 e0 3f             	and    $0x3f,%eax
  800421160f:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  8004211612:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211616:	48 83 c0 01          	add    $0x1,%rax
  800421161a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  800421161e:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004211622:	0f 84 a1 01 00 00    	je     80042117c9 <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  8004211628:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800421162c:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004211631:	74 38                	je     800421166b <_dwarf_frame_run_inst+0x116>
  8004211633:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004211638:	0f 84 01 01 00 00    	je     800421173f <_dwarf_frame_run_inst+0x1ea>
  800421163e:	83 f8 40             	cmp    $0x40,%eax
  8004211641:	0f 85 71 01 00 00    	jne    80042117b8 <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004211647:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421164b:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211652:	ff 
  8004211653:	48 01 45 10          	add    %rax,0x10(%rbp)
                                if (pc_req < pc)
  8004211657:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421165b:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421165f:	73 05                	jae    8004211666 <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  8004211661:	e9 be 0c 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                                break;
  8004211666:	e9 59 01 00 00       	jmpq   80042117c4 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  800421166b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421166f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211673:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004211676:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421167a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421167e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211682:	66 39 c2             	cmp    %ax,%dx
  8004211685:	72 0c                	jb     8004211693 <_dwarf_frame_run_inst+0x13e>
  8004211687:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421168e:	e9 91 0c 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                                RL[low6].dw_offset_relevant = 1;
  8004211693:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211697:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421169b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421169f:	48 89 d0             	mov    %rdx,%rax
  80042116a2:	48 01 c0             	add    %rax,%rax
  80042116a5:	48 01 d0             	add    %rdx,%rax
  80042116a8:	48 c1 e0 03          	shl    $0x3,%rax
  80042116ac:	48 01 c8             	add    %rcx,%rax
  80042116af:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042116b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116b6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116ba:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042116be:	48 89 d0             	mov    %rdx,%rax
  80042116c1:	48 01 c0             	add    %rax,%rax
  80042116c4:	48 01 d0             	add    %rdx,%rax
  80042116c7:	48 c1 e0 03          	shl    $0x3,%rax
  80042116cb:	48 01 c8             	add    %rcx,%rax
  80042116ce:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  80042116d2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116d6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116da:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042116de:	48 89 d0             	mov    %rdx,%rax
  80042116e1:	48 01 c0             	add    %rax,%rax
  80042116e4:	48 01 d0             	add    %rdx,%rax
  80042116e7:	48 c1 e0 03          	shl    $0x3,%rax
  80042116eb:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042116ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042116f3:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042116f7:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  80042116fb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116ff:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211703:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211707:	48 89 d0             	mov    %rdx,%rax
  800421170a:	48 01 c0             	add    %rax,%rax
  800421170d:	48 01 d0             	add    %rdx,%rax
  8004211710:	48 c1 e0 03          	shl    $0x3,%rax
  8004211714:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004211718:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421171c:	48 89 c7             	mov    %rax,%rdi
  800421171f:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211726:	00 00 00 
  8004211729:	ff d0                	callq  *%rax
  800421172b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211732:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004211736:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
                                break;
  800421173a:	e9 85 00 00 00       	jmpq   80042117c4 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  800421173f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211743:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211747:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  800421174a:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421174e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211752:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211756:	66 39 c2             	cmp    %ax,%dx
  8004211759:	72 0c                	jb     8004211767 <_dwarf_frame_run_inst+0x212>
  800421175b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211762:	e9 bd 0b 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                                memcpy(&RL[low6], &INITRL[low6],
  8004211767:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421176b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421176f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211773:	48 89 d0             	mov    %rdx,%rax
  8004211776:	48 01 c0             	add    %rax,%rax
  8004211779:	48 01 d0             	add    %rdx,%rax
  800421177c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211780:	48 01 c1             	add    %rax,%rcx
  8004211783:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211787:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421178b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421178f:	48 89 d0             	mov    %rdx,%rax
  8004211792:	48 01 c0             	add    %rax,%rax
  8004211795:	48 01 d0             	add    %rdx,%rax
  8004211798:	48 c1 e0 03          	shl    $0x3,%rax
  800421179c:	48 01 f0             	add    %rsi,%rax
  800421179f:	ba 18 00 00 00       	mov    $0x18,%edx
  80042117a4:	48 89 ce             	mov    %rcx,%rsi
  80042117a7:	48 89 c7             	mov    %rax,%rdi
  80042117aa:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  80042117b1:	00 00 00 
  80042117b4:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
                                break;
  80042117b6:	eb 0c                	jmp    80042117c4 <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042117b8:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  80042117bf:	e9 60 0b 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        }

                        continue;
  80042117c4:	e9 4d 0b 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                }

                switch (low6) {
  80042117c9:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042117cd:	83 f8 16             	cmp    $0x16,%eax
  80042117d0:	0f 87 37 0b 00 00    	ja     800421230d <_dwarf_frame_run_inst+0xdb8>
  80042117d6:	89 c0                	mov    %eax,%eax
  80042117d8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042117df:	00 
  80042117e0:	48 b8 40 9b 21 04 80 	movabs $0x8004219b40,%rax
  80042117e7:	00 00 00 
  80042117ea:	48 01 d0             	add    %rdx,%rax
  80042117ed:	48 8b 00             	mov    (%rax),%rax
  80042117f0:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  80042117f2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042117f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042117fa:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042117fe:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004211801:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211805:	89 ce                	mov    %ecx,%esi
  8004211807:	48 89 d7             	mov    %rdx,%rdi
  800421180a:	ff d0                	callq  *%rax
  800421180c:	48 89 45 10          	mov    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004211810:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211814:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211818:	73 05                	jae    800421181f <_dwarf_frame_run_inst+0x2ca>
                                goto program_done;
  800421181a:	e9 05 0b 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        break;
  800421181f:	e9 f2 0a 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  8004211824:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211828:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421182c:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211830:	be 01 00 00 00       	mov    $0x1,%esi
  8004211835:	48 89 d7             	mov    %rdx,%rdi
  8004211838:	ff d0                	callq  *%rax
  800421183a:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211841:	ff 
  8004211842:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004211846:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421184a:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421184e:	73 05                	jae    8004211855 <_dwarf_frame_run_inst+0x300>
                                goto program_done;
  8004211850:	e9 cf 0a 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004211855:	e9 bc 0a 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  800421185a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421185e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211862:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211866:	be 02 00 00 00       	mov    $0x2,%esi
  800421186b:	48 89 d7             	mov    %rdx,%rdi
  800421186e:	ff d0                	callq  *%rax
  8004211870:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211877:	ff 
  8004211878:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  800421187c:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211880:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211884:	73 05                	jae    800421188b <_dwarf_frame_run_inst+0x336>
                                goto program_done;
  8004211886:	e9 99 0a 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        break;
  800421188b:	e9 86 0a 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  8004211890:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211894:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211898:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421189c:	be 04 00 00 00       	mov    $0x4,%esi
  80042118a1:	48 89 d7             	mov    %rdx,%rdi
  80042118a4:	ff d0                	callq  *%rax
  80042118a6:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042118ad:	ff 
  80042118ae:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042118b2:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042118b6:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042118ba:	73 05                	jae    80042118c1 <_dwarf_frame_run_inst+0x36c>
                                goto program_done;
  80042118bc:	e9 63 0a 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042118c1:	e9 50 0a 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  80042118c6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042118ca:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042118ce:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042118d1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118d5:	48 89 c7             	mov    %rax,%rdi
  80042118d8:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  80042118df:	00 00 00 
  80042118e2:	ff d0                	callq  *%rax
  80042118e4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042118e8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118ec:	48 89 c7             	mov    %rax,%rdi
  80042118ef:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  80042118f6:	00 00 00 
  80042118f9:	ff d0                	callq  *%rax
  80042118fb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042118ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211903:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211907:	0f b7 c0             	movzwl %ax,%eax
  800421190a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421190e:	77 0c                	ja     800421191c <_dwarf_frame_run_inst+0x3c7>
  8004211910:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211917:	e9 08 0a 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  800421191c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211920:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211924:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211928:	48 89 d0             	mov    %rdx,%rax
  800421192b:	48 01 c0             	add    %rax,%rax
  800421192e:	48 01 d0             	add    %rdx,%rax
  8004211931:	48 c1 e0 03          	shl    $0x3,%rax
  8004211935:	48 01 c8             	add    %rcx,%rax
  8004211938:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421193b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421193f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211943:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211947:	48 89 d0             	mov    %rdx,%rax
  800421194a:	48 01 c0             	add    %rax,%rax
  800421194d:	48 01 d0             	add    %rdx,%rax
  8004211950:	48 c1 e0 03          	shl    $0x3,%rax
  8004211954:	48 01 c8             	add    %rcx,%rax
  8004211957:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421195b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421195f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211963:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211967:	48 89 d0             	mov    %rdx,%rax
  800421196a:	48 01 c0             	add    %rax,%rax
  800421196d:	48 01 d0             	add    %rdx,%rax
  8004211970:	48 c1 e0 03          	shl    $0x3,%rax
  8004211974:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211978:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421197c:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211980:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004211984:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211988:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421198c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211990:	48 89 d0             	mov    %rdx,%rax
  8004211993:	48 01 c0             	add    %rax,%rax
  8004211996:	48 01 d0             	add    %rdx,%rax
  8004211999:	48 c1 e0 03          	shl    $0x3,%rax
  800421199d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119a1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042119a8:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042119ad:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042119b1:	e9 60 09 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  80042119b6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042119ba:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042119be:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042119c1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119c5:	48 89 c7             	mov    %rax,%rdi
  80042119c8:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  80042119cf:	00 00 00 
  80042119d2:	ff d0                	callq  *%rax
  80042119d4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042119d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119dc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042119e0:	0f b7 c0             	movzwl %ax,%eax
  80042119e3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042119e7:	77 0c                	ja     80042119f5 <_dwarf_frame_run_inst+0x4a0>
  80042119e9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042119f0:	e9 2f 09 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        memcpy(&RL[reg], &INITRL[reg],
  80042119f5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042119f9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042119fd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a01:	48 89 d0             	mov    %rdx,%rax
  8004211a04:	48 01 c0             	add    %rax,%rax
  8004211a07:	48 01 d0             	add    %rdx,%rax
  8004211a0a:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a0e:	48 01 c1             	add    %rax,%rcx
  8004211a11:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a15:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211a19:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a1d:	48 89 d0             	mov    %rdx,%rax
  8004211a20:	48 01 c0             	add    %rax,%rax
  8004211a23:	48 01 d0             	add    %rdx,%rax
  8004211a26:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a2a:	48 01 f0             	add    %rsi,%rax
  8004211a2d:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211a32:	48 89 ce             	mov    %rcx,%rsi
  8004211a35:	48 89 c7             	mov    %rax,%rdi
  8004211a38:	48 b8 f2 ef 20 04 80 	movabs $0x800420eff2,%rax
  8004211a3f:	00 00 00 
  8004211a42:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
                        break;
  8004211a44:	e9 cd 08 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_undefined:
                        *row_pc = pc;
  8004211a49:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a4d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a51:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211a54:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a58:	48 89 c7             	mov    %rax,%rdi
  8004211a5b:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211a62:	00 00 00 
  8004211a65:	ff d0                	callq  *%rax
  8004211a67:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211a6b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a6f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211a73:	0f b7 c0             	movzwl %ax,%eax
  8004211a76:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211a7a:	77 0c                	ja     8004211a88 <_dwarf_frame_run_inst+0x533>
  8004211a7c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211a83:	e9 9c 08 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211a88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a8c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a90:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a94:	48 89 d0             	mov    %rdx,%rax
  8004211a97:	48 01 c0             	add    %rax,%rax
  8004211a9a:	48 01 d0             	add    %rdx,%rax
  8004211a9d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211aa1:	48 01 c8             	add    %rcx,%rax
  8004211aa4:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004211aa7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211aaf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ab3:	48 89 d0             	mov    %rdx,%rax
  8004211ab6:	48 01 c0             	add    %rax,%rax
  8004211ab9:	48 01 d0             	add    %rdx,%rax
  8004211abc:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ac0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ac4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211ac8:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004211acc:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004211ad0:	e9 41 08 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  8004211ad5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ad9:	48 89 c7             	mov    %rax,%rdi
  8004211adc:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211ae3:	00 00 00 
  8004211ae6:	ff d0                	callq  *%rax
  8004211ae8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211aec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211af0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211af4:	0f b7 c0             	movzwl %ax,%eax
  8004211af7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211afb:	77 0c                	ja     8004211b09 <_dwarf_frame_run_inst+0x5b4>
  8004211afd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211b04:	e9 1b 08 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211b09:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b0d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b11:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b15:	48 89 d0             	mov    %rdx,%rax
  8004211b18:	48 01 c0             	add    %rax,%rax
  8004211b1b:	48 01 d0             	add    %rdx,%rax
  8004211b1e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b22:	48 01 c8             	add    %rcx,%rax
  8004211b25:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004211b28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b2c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b34:	48 89 d0             	mov    %rdx,%rax
  8004211b37:	48 01 c0             	add    %rax,%rax
  8004211b3a:	48 01 d0             	add    %rdx,%rax
  8004211b3d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b41:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211b45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211b49:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004211b4d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004211b51:	e9 c0 07 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_register:
                        *row_pc = pc;
  8004211b56:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211b5a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211b5e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211b61:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b65:	48 89 c7             	mov    %rax,%rdi
  8004211b68:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211b6f:	00 00 00 
  8004211b72:	ff d0                	callq  *%rax
  8004211b74:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  8004211b78:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b7c:	48 89 c7             	mov    %rax,%rdi
  8004211b7f:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211b86:	00 00 00 
  8004211b89:	ff d0                	callq  *%rax
  8004211b8b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211b8f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b93:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211b97:	0f b7 c0             	movzwl %ax,%eax
  8004211b9a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211b9e:	77 0c                	ja     8004211bac <_dwarf_frame_run_inst+0x657>
  8004211ba0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211ba7:	e9 78 07 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211bac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bb0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211bb4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bb8:	48 89 d0             	mov    %rdx,%rax
  8004211bbb:	48 01 c0             	add    %rax,%rax
  8004211bbe:	48 01 d0             	add    %rdx,%rax
  8004211bc1:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bc5:	48 01 c8             	add    %rcx,%rax
  8004211bc8:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  8004211bcb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bcf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211bd3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bd7:	48 89 d0             	mov    %rdx,%rax
  8004211bda:	48 01 c0             	add    %rax,%rax
  8004211bdd:	48 01 d0             	add    %rdx,%rax
  8004211be0:	48 c1 e0 03          	shl    $0x3,%rax
  8004211be4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211be8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211bec:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  8004211bf0:	e9 21 07 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004211bf5:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211bf9:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211bfd:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004211c01:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211c05:	48 89 c7             	mov    %rax,%rdi
  8004211c08:	48 b8 84 13 21 04 80 	movabs $0x8004211384,%rax
  8004211c0f:	00 00 00 
  8004211c12:	ff d0                	callq  *%rax
                        break;
  8004211c14:	e9 fd 06 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  8004211c19:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c1d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c21:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004211c24:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211c28:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004211c2c:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  8004211c30:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211c34:	48 89 c7             	mov    %rax,%rdi
  8004211c37:	48 b8 84 13 21 04 80 	movabs $0x8004211384,%rax
  8004211c3e:	00 00 00 
  8004211c41:	ff d0                	callq  *%rax
                        break;
  8004211c43:	e9 ce 06 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004211c48:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211c4c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211c50:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211c53:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c57:	48 89 c7             	mov    %rax,%rdi
  8004211c5a:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211c61:	00 00 00 
  8004211c64:	ff d0                	callq  *%rax
  8004211c66:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211c6a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211c6e:	48 89 c7             	mov    %rax,%rdi
  8004211c71:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211c78:	00 00 00 
  8004211c7b:	ff d0                	callq  *%rax
  8004211c7d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211c81:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c85:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211c88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c8c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004211c90:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c94:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c98:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004211c9c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ca0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211ca4:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211ca8:	e9 69 06 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  8004211cad:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211cb1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211cb5:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211cb8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211cbc:	48 89 c7             	mov    %rax,%rdi
  8004211cbf:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211cc6:	00 00 00 
  8004211cc9:	ff d0                	callq  *%rax
  8004211ccb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004211ccf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cd3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211cd7:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * Note that DW_CFA_def_cfa_register change the CFA
                         * rule register while keep the old offset. So we
                         * should not touch the CFA.dw_offset_relevant flag
                         * here.
                         */
                        break;
  8004211cdb:	e9 36 06 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  8004211ce0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211ce4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ce8:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211ceb:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211cef:	48 89 c7             	mov    %rax,%rdi
  8004211cf2:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211cf9:	00 00 00 
  8004211cfc:	ff d0                	callq  *%rax
  8004211cfe:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211d02:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d06:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211d09:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d0d:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004211d11:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d15:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211d19:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211d1d:	e9 f4 05 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  8004211d22:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211d26:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211d2a:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  8004211d2d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d31:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004211d34:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d38:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004211d3c:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004211d40:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d44:	48 89 c7             	mov    %rax,%rdi
  8004211d47:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211d4e:	00 00 00 
  8004211d51:	ff d0                	callq  *%rax
  8004211d53:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004211d57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d5b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211d5f:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004211d63:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211d67:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d6b:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211d6f:	48 01 d0             	add    %rdx,%rax
  8004211d72:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004211d76:	e9 9b 05 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_expression:
                        *row_pc = pc;
  8004211d7b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211d7f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211d83:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211d86:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d8a:	48 89 c7             	mov    %rax,%rdi
  8004211d8d:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211d94:	00 00 00 
  8004211d97:	ff d0                	callq  *%rax
  8004211d99:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211d9d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211da1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211da5:	0f b7 c0             	movzwl %ax,%eax
  8004211da8:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211dac:	77 0c                	ja     8004211dba <_dwarf_frame_run_inst+0x865>
  8004211dae:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211db5:	e9 6a 05 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004211dba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211dbe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211dc2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211dc6:	48 89 d0             	mov    %rdx,%rax
  8004211dc9:	48 01 c0             	add    %rax,%rax
  8004211dcc:	48 01 d0             	add    %rdx,%rax
  8004211dcf:	48 c1 e0 03          	shl    $0x3,%rax
  8004211dd3:	48 01 c8             	add    %rcx,%rax
  8004211dd6:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004211dd9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ddd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211de1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211de5:	48 89 d0             	mov    %rdx,%rax
  8004211de8:	48 01 c0             	add    %rax,%rax
  8004211deb:	48 01 d0             	add    %rdx,%rax
  8004211dee:	48 c1 e0 03          	shl    $0x3,%rax
  8004211df2:	48 01 c8             	add    %rcx,%rax
  8004211df5:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004211df9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211dfd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e01:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e05:	48 89 d0             	mov    %rdx,%rax
  8004211e08:	48 01 c0             	add    %rax,%rax
  8004211e0b:	48 01 d0             	add    %rdx,%rax
  8004211e0e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e12:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004211e16:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e1a:	48 89 c7             	mov    %rax,%rdi
  8004211e1d:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211e24:	00 00 00 
  8004211e27:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004211e29:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004211e2d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e31:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e35:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e39:	48 89 d0             	mov    %rdx,%rax
  8004211e3c:	48 01 c0             	add    %rax,%rax
  8004211e3f:	48 01 d0             	add    %rdx,%rax
  8004211e42:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e46:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211e4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211e4e:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004211e52:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211e56:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e5a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211e5e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e62:	48 89 d0             	mov    %rdx,%rax
  8004211e65:	48 01 c0             	add    %rax,%rax
  8004211e68:	48 01 d0             	add    %rdx,%rax
  8004211e6b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e6f:	48 01 f0             	add    %rsi,%rax
  8004211e72:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211e76:	48 01 c8             	add    %rcx,%rax
  8004211e79:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004211e7d:	e9 94 04 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  8004211e82:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211e86:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211e8a:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211e8d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e91:	48 89 c7             	mov    %rax,%rdi
  8004211e94:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211e9b:	00 00 00 
  8004211e9e:	ff d0                	callq  *%rax
  8004211ea0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211ea4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ea8:	48 89 c7             	mov    %rax,%rdi
  8004211eab:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  8004211eb2:	00 00 00 
  8004211eb5:	ff d0                	callq  *%rax
  8004211eb7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211ebb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ebf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ec3:	0f b7 c0             	movzwl %ax,%eax
  8004211ec6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211eca:	77 0c                	ja     8004211ed8 <_dwarf_frame_run_inst+0x983>
  8004211ecc:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211ed3:	e9 4c 04 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004211ed8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211edc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ee0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ee4:	48 89 d0             	mov    %rdx,%rax
  8004211ee7:	48 01 c0             	add    %rax,%rax
  8004211eea:	48 01 d0             	add    %rdx,%rax
  8004211eed:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ef1:	48 01 c8             	add    %rcx,%rax
  8004211ef4:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211ef7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211efb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211eff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f03:	48 89 d0             	mov    %rdx,%rax
  8004211f06:	48 01 c0             	add    %rax,%rax
  8004211f09:	48 01 d0             	add    %rdx,%rax
  8004211f0c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f10:	48 01 c8             	add    %rcx,%rax
  8004211f13:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211f17:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f1b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f1f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f23:	48 89 d0             	mov    %rdx,%rax
  8004211f26:	48 01 c0             	add    %rax,%rax
  8004211f29:	48 01 d0             	add    %rdx,%rax
  8004211f2c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f30:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211f34:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211f38:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211f3c:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004211f40:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f44:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f48:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f4c:	48 89 d0             	mov    %rdx,%rax
  8004211f4f:	48 01 c0             	add    %rax,%rax
  8004211f52:	48 01 d0             	add    %rdx,%rax
  8004211f55:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f59:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211f5d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211f64:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211f69:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004211f6d:	e9 a4 03 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  8004211f72:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211f76:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211f7a:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211f7d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f81:	48 89 c7             	mov    %rax,%rdi
  8004211f84:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004211f8b:	00 00 00 
  8004211f8e:	ff d0                	callq  *%rax
  8004211f90:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211f94:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f98:	48 89 c7             	mov    %rax,%rdi
  8004211f9b:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  8004211fa2:	00 00 00 
  8004211fa5:	ff d0                	callq  *%rax
  8004211fa7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211fab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211faf:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211fb2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fb6:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004211fba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fc2:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004211fc6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fca:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211fd1:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211fd6:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004211fda:	e9 37 03 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004211fdf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211fe3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211fe7:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004211fea:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211fee:	48 89 c7             	mov    %rax,%rdi
  8004211ff1:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  8004211ff8:	00 00 00 
  8004211ffb:	ff d0                	callq  *%rax
  8004211ffd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212001:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212005:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212008:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421200c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212010:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212014:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421201b:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212020:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004212024:	e9 ed 02 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004212029:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421202d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212031:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212034:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212038:	48 89 c7             	mov    %rax,%rdi
  800421203b:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004212042:	00 00 00 
  8004212045:	ff d0                	callq  *%rax
  8004212047:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  800421204b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421204f:	48 89 c7             	mov    %rax,%rdi
  8004212052:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004212059:	00 00 00 
  800421205c:	ff d0                	callq  *%rax
  800421205e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212062:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212066:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421206a:	0f b7 c0             	movzwl %ax,%eax
  800421206d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212071:	77 0c                	ja     800421207f <_dwarf_frame_run_inst+0xb2a>
  8004212073:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421207a:	e9 a5 02 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  800421207f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212083:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212087:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421208b:	48 89 d0             	mov    %rdx,%rax
  800421208e:	48 01 c0             	add    %rax,%rax
  8004212091:	48 01 d0             	add    %rdx,%rax
  8004212094:	48 c1 e0 03          	shl    $0x3,%rax
  8004212098:	48 01 c8             	add    %rcx,%rax
  800421209b:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421209e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120a2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120aa:	48 89 d0             	mov    %rdx,%rax
  80042120ad:	48 01 c0             	add    %rax,%rax
  80042120b0:	48 01 d0             	add    %rdx,%rax
  80042120b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042120b7:	48 01 c8             	add    %rcx,%rax
  80042120ba:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042120be:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120c2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120c6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120ca:	48 89 d0             	mov    %rdx,%rax
  80042120cd:	48 01 c0             	add    %rax,%rax
  80042120d0:	48 01 d0             	add    %rdx,%rax
  80042120d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042120d7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042120db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042120df:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042120e3:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042120e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042120eb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120ef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042120f3:	48 89 d0             	mov    %rdx,%rax
  80042120f6:	48 01 c0             	add    %rax,%rax
  80042120f9:	48 01 d0             	add    %rdx,%rax
  80042120fc:	48 c1 e0 03          	shl    $0x3,%rax
  8004212100:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212104:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  800421210b:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212110:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212114:	e9 fd 01 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004212119:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421211d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212121:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212124:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212128:	48 89 c7             	mov    %rax,%rdi
  800421212b:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004212132:	00 00 00 
  8004212135:	ff d0                	callq  *%rax
  8004212137:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  800421213b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421213f:	48 89 c7             	mov    %rax,%rdi
  8004212142:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  8004212149:	00 00 00 
  800421214c:	ff d0                	callq  *%rax
  800421214e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212152:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212156:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421215a:	0f b7 c0             	movzwl %ax,%eax
  800421215d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212161:	77 0c                	ja     800421216f <_dwarf_frame_run_inst+0xc1a>
  8004212163:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421216a:	e9 b5 01 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  800421216f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212173:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212177:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421217b:	48 89 d0             	mov    %rdx,%rax
  800421217e:	48 01 c0             	add    %rax,%rax
  8004212181:	48 01 d0             	add    %rdx,%rax
  8004212184:	48 c1 e0 03          	shl    $0x3,%rax
  8004212188:	48 01 c8             	add    %rcx,%rax
  800421218b:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421218e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212192:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212196:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421219a:	48 89 d0             	mov    %rdx,%rax
  800421219d:	48 01 c0             	add    %rax,%rax
  80042121a0:	48 01 d0             	add    %rdx,%rax
  80042121a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042121a7:	48 01 c8             	add    %rcx,%rax
  80042121aa:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042121ae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121b2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121b6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042121ba:	48 89 d0             	mov    %rdx,%rax
  80042121bd:	48 01 c0             	add    %rax,%rax
  80042121c0:	48 01 d0             	add    %rdx,%rax
  80042121c3:	48 c1 e0 03          	shl    $0x3,%rax
  80042121c7:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042121cb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042121cf:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042121d3:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  80042121d7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042121db:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042121df:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042121e3:	48 89 d0             	mov    %rdx,%rax
  80042121e6:	48 01 c0             	add    %rax,%rax
  80042121e9:	48 01 d0             	add    %rdx,%rax
  80042121ec:	48 c1 e0 03          	shl    $0x3,%rax
  80042121f0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042121f4:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042121fb:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212200:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212204:	e9 0d 01 00 00       	jmpq   8004212316 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004212209:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421220d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212211:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212214:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212218:	48 89 c7             	mov    %rax,%rdi
  800421221b:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004212222:	00 00 00 
  8004212225:	ff d0                	callq  *%rax
  8004212227:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421222b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421222f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212233:	0f b7 c0             	movzwl %ax,%eax
  8004212236:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421223a:	77 0c                	ja     8004212248 <_dwarf_frame_run_inst+0xcf3>
  800421223c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212243:	e9 dc 00 00 00       	jmpq   8004212324 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004212248:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421224c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212250:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212254:	48 89 d0             	mov    %rdx,%rax
  8004212257:	48 01 c0             	add    %rax,%rax
  800421225a:	48 01 d0             	add    %rdx,%rax
  800421225d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212261:	48 01 c8             	add    %rcx,%rax
  8004212264:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004212267:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421226b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421226f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212273:	48 89 d0             	mov    %rdx,%rax
  8004212276:	48 01 c0             	add    %rax,%rax
  8004212279:	48 01 d0             	add    %rdx,%rax
  800421227c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212280:	48 01 c8             	add    %rcx,%rax
  8004212283:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004212287:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421228b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421228f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212293:	48 89 d0             	mov    %rdx,%rax
  8004212296:	48 01 c0             	add    %rax,%rax
  8004212299:	48 01 d0             	add    %rdx,%rax
  800421229c:	48 c1 e0 03          	shl    $0x3,%rax
  80042122a0:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  80042122a4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042122a8:	48 89 c7             	mov    %rax,%rdi
  80042122ab:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  80042122b2:	00 00 00 
  80042122b5:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  80042122b7:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  80042122bb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122bf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122c3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042122c7:	48 89 d0             	mov    %rdx,%rax
  80042122ca:	48 01 c0             	add    %rax,%rax
  80042122cd:	48 01 d0             	add    %rdx,%rax
  80042122d0:	48 c1 e0 03          	shl    $0x3,%rax
  80042122d4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042122d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042122dc:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  80042122e0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042122e4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122e8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042122ec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042122f0:	48 89 d0             	mov    %rdx,%rax
  80042122f3:	48 01 c0             	add    %rax,%rax
  80042122f6:	48 01 d0             	add    %rdx,%rax
  80042122f9:	48 c1 e0 03          	shl    $0x3,%rax
  80042122fd:	48 01 f0             	add    %rsi,%rax
  8004212300:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212304:	48 01 c8             	add    %rcx,%rax
  8004212307:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  800421230b:	eb 09                	jmp    8004212316 <_dwarf_frame_run_inst+0xdc1>
                default:
                        DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421230d:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004212314:	eb 0e                	jmp    8004212324 <_dwarf_frame_run_inst+0xdcf>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004212316:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421231a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421231e:	0f 82 b8 f2 ff ff    	jb     80042115dc <_dwarf_frame_run_inst+0x87>
                        goto program_done;
                }
        }

program_done:
        return (ret);
  8004212324:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212327:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800421232e:	5b                   	pop    %rbx
  800421232f:	5d                   	pop    %rbp
  8004212330:	c3                   	retq   

0000008004212331 <_dwarf_frame_get_internal_table>:

int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004212331:	55                   	push   %rbp
  8004212332:	48 89 e5             	mov    %rsp,%rbp
  8004212335:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212339:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421233d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212341:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212345:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212349:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  800421234d:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004212351:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212356:	75 35                	jne    800421238d <_dwarf_frame_get_internal_table+0x5c>
  8004212358:	48 b9 f8 9b 21 04 80 	movabs $0x8004219bf8,%rcx
  800421235f:	00 00 00 
  8004212362:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  8004212369:	00 00 00 
  800421236c:	be 82 01 00 00       	mov    $0x182,%esi
  8004212371:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  8004212378:	00 00 00 
  800421237b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212380:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004212387:	00 00 00 
  800421238a:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  800421238d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212392:	75 35                	jne    80042123c9 <_dwarf_frame_get_internal_table+0x98>
  8004212394:	48 b9 07 9c 21 04 80 	movabs $0x8004219c07,%rcx
  800421239b:	00 00 00 
  800421239e:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  80042123a5:	00 00 00 
  80042123a8:	be 85 01 00 00       	mov    $0x185,%esi
  80042123ad:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  80042123b4:	00 00 00 
  80042123b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123bc:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042123c3:	00 00 00 
  80042123c6:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  80042123c9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042123cd:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042123d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  80042123d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042123d9:	ba 18 00 00 00       	mov    $0x18,%edx
  80042123de:	be 00 00 00 00       	mov    $0x0,%esi
  80042123e3:	48 89 c7             	mov    %rax,%rdi
  80042123e6:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042123ed:	00 00 00 
  80042123f0:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  80042123f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042123f6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042123fa:	0f b7 d0             	movzwl %ax,%edx
  80042123fd:	48 89 d0             	mov    %rdx,%rax
  8004212400:	48 01 c0             	add    %rax,%rax
  8004212403:	48 01 d0             	add    %rdx,%rax
  8004212406:	48 c1 e0 03          	shl    $0x3,%rax
  800421240a:	48 89 c2             	mov    %rax,%rdx
  800421240d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212411:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212415:	be 00 00 00 00       	mov    $0x0,%esi
  800421241a:	48 89 c7             	mov    %rax,%rdi
  800421241d:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004212424:	00 00 00 
  8004212427:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212429:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004212430:	eb 2f                	jmp    8004212461 <_dwarf_frame_get_internal_table+0x130>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004212432:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212436:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421243a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421243d:	48 63 d0             	movslq %eax,%rdx
  8004212440:	48 89 d0             	mov    %rdx,%rax
  8004212443:	48 01 c0             	add    %rax,%rax
  8004212446:	48 01 d0             	add    %rdx,%rax
  8004212449:	48 c1 e0 03          	shl    $0x3,%rax
  800421244d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212451:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212455:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004212459:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  800421245d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004212461:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212465:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212469:	0f b7 c0             	movzwl %ax,%eax
  800421246c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421246f:	7f c1                	jg     8004212432 <_dwarf_frame_get_internal_table+0x101>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004212471:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212475:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212479:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  800421247d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212482:	75 35                	jne    80042124b9 <_dwarf_frame_get_internal_table+0x188>
  8004212484:	48 b9 13 9c 21 04 80 	movabs $0x8004219c13,%rcx
  800421248b:	00 00 00 
  800421248e:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  8004212495:	00 00 00 
  8004212498:	be 94 01 00 00       	mov    $0x194,%esi
  800421249d:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  80042124a4:	00 00 00 
  80042124a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042124ac:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042124b3:	00 00 00 
  80042124b6:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  80042124b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124bd:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042124c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124c5:	4c 8b 40 38          	mov    0x38(%rax),%r8
  80042124c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124cd:	48 8b 48 70          	mov    0x70(%rax),%rcx
  80042124d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124d5:	48 8b 50 68          	mov    0x68(%rax),%rdx
  80042124d9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042124dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042124e1:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  80042124e5:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  80042124ea:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  80042124ee:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042124f3:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  80042124fa:	ff ff 
  80042124fc:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004212503:	00 
  8004212504:	48 89 c7             	mov    %rax,%rdi
  8004212507:	48 b8 55 15 21 04 80 	movabs $0x8004211555,%rax
  800421250e:	00 00 00 
  8004212511:	ff d0                	callq  *%rax
  8004212513:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004212516:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421251a:	74 08                	je     8004212524 <_dwarf_frame_get_internal_table+0x1f3>
                return (ret);
  800421251c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421251f:	e9 98 00 00 00       	jmpq   80042125bc <_dwarf_frame_get_internal_table+0x28b>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004212524:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212528:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421252c:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004212530:	77 6f                	ja     80042125a1 <_dwarf_frame_get_internal_table+0x270>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004212532:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212536:	48 8b 78 30          	mov    0x30(%rax),%rdi
  800421253a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421253e:	4c 8b 48 40          	mov    0x40(%rax),%r9
  8004212542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212546:	4c 8b 50 38          	mov    0x38(%rax),%r10
  800421254a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421254e:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004212552:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212556:	48 8b 50 50          	mov    0x50(%rax),%rdx
  800421255a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421255e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212562:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004212566:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  800421256b:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  800421256f:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004212574:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  8004212578:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800421257d:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212581:	4d 89 d0             	mov    %r10,%r8
  8004212584:	48 89 c7             	mov    %rax,%rdi
  8004212587:	48 b8 55 15 21 04 80 	movabs $0x8004211555,%rax
  800421258e:	00 00 00 
  8004212591:	ff d0                	callq  *%rax
  8004212593:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
					    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  8004212596:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421259a:	74 05                	je     80042125a1 <_dwarf_frame_get_internal_table+0x270>
                        return (ret);
  800421259c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421259f:	eb 1b                	jmp    80042125bc <_dwarf_frame_get_internal_table+0x28b>
        }

        *ret_rt = rt;
  80042125a1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042125a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042125a9:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  80042125ac:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042125b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042125b4:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  80042125b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042125bc:	c9                   	leaveq 
  80042125bd:	c3                   	retq   

00000080042125be <dwarf_get_fde_info_for_all_regs>:

int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested, Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042125be:	55                   	push   %rbp
  80042125bf:	48 89 e5             	mov    %rsp,%rbp
  80042125c2:	48 83 ec 50          	sub    $0x50,%rsp
  80042125c6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042125ca:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042125ce:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042125d2:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042125d6:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  80042125da:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL) {
  80042125de:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042125e3:	74 07                	je     80042125ec <dwarf_get_fde_info_for_all_regs+0x2e>
  80042125e5:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042125ea:	75 0a                	jne    80042125f6 <dwarf_get_fde_info_for_all_regs+0x38>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  80042125ec:	b8 01 00 00 00       	mov    $0x1,%eax
  80042125f1:	e9 eb 02 00 00       	jmpq   80042128e1 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        assert(dbg != NULL);
  80042125f6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042125fb:	75 35                	jne    8004212632 <dwarf_get_fde_info_for_all_regs+0x74>
  80042125fd:	48 b9 07 9c 21 04 80 	movabs $0x8004219c07,%rcx
  8004212604:	00 00 00 
  8004212607:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  800421260e:	00 00 00 
  8004212611:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004212616:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  800421261d:	00 00 00 
  8004212620:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212625:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421262c:	00 00 00 
  800421262f:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  8004212632:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212636:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421263a:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421263e:	77 19                	ja     8004212659 <dwarf_get_fde_info_for_all_regs+0x9b>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004212640:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212644:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004212648:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421264c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212650:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004212653:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004212657:	77 0a                	ja     8004212663 <dwarf_get_fde_info_for_all_regs+0xa5>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
                return (DW_DLV_ERROR);
  8004212659:	b8 01 00 00 00       	mov    $0x1,%eax
  800421265e:	e9 7e 02 00 00       	jmpq   80042128e1 <dwarf_get_fde_info_for_all_regs+0x323>
        }

        ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004212663:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  8004212667:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800421266b:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800421266f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212673:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212677:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421267b:	4d 89 c1             	mov    %r8,%r9
  800421267e:	49 89 f8             	mov    %rdi,%r8
  8004212681:	48 89 c7             	mov    %rax,%rdi
  8004212684:	48 b8 31 23 21 04 80 	movabs $0x8004212331,%rax
  800421268b:	00 00 00 
  800421268e:	ff d0                	callq  *%rax
  8004212690:	89 45 f8             	mov    %eax,-0x8(%rbp)
                                              error);
        if (ret != DW_DLE_NONE)
  8004212693:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004212697:	74 0a                	je     80042126a3 <dwarf_get_fde_info_for_all_regs+0xe5>
                return (DW_DLV_ERROR);
  8004212699:	b8 01 00 00 00       	mov    $0x1,%eax
  800421269e:	e9 3e 02 00 00       	jmpq   80042128e1 <dwarf_get_fde_info_for_all_regs+0x323>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  80042126a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042126a7:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042126ab:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  80042126af:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042126b4:	0f 87 b1 00 00 00    	ja     800421276b <dwarf_get_fde_info_for_all_regs+0x1ad>
                reg_table->rules[cfa].dw_offset_relevant =
  80042126ba:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042126be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126c2:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  80042126c5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042126c9:	48 63 c9             	movslq %ecx,%rcx
  80042126cc:	48 83 c1 01          	add    $0x1,%rcx
  80042126d0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042126d4:	48 01 ca             	add    %rcx,%rdx
  80042126d7:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  80042126d9:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042126dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126e1:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042126e5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042126e9:	48 63 c9             	movslq %ecx,%rcx
  80042126ec:	48 83 c1 01          	add    $0x1,%rcx
  80042126f0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042126f4:	48 01 ca             	add    %rcx,%rdx
  80042126f7:	88 42 01             	mov    %al,0x1(%rdx)
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  80042126fa:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  80042126fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212702:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004212706:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421270a:	48 63 c9             	movslq %ecx,%rcx
  800421270d:	48 83 c1 01          	add    $0x1,%rcx
  8004212711:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212715:	48 01 ca             	add    %rcx,%rdx
  8004212718:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421271c:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212720:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212724:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212728:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421272c:	48 63 c9             	movslq %ecx,%rcx
  800421272f:	48 83 c1 01          	add    $0x1,%rcx
  8004212733:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212737:	48 01 ca             	add    %rcx,%rdx
  800421273a:	48 83 c2 08          	add    $0x8,%rdx
  800421273e:	48 89 02             	mov    %rax,(%rdx)
                reg_table->cfa_rule = reg_table->rules[cfa];
  8004212741:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004212745:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004212749:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421274d:	48 63 d2             	movslq %edx,%rdx
  8004212750:	48 83 c2 01          	add    $0x1,%rdx
  8004212754:	48 c1 e2 04          	shl    $0x4,%rdx
  8004212758:	48 01 d0             	add    %rdx,%rax
  800421275b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421275f:	48 8b 00             	mov    (%rax),%rax
  8004212762:	48 89 01             	mov    %rax,(%rcx)
  8004212765:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  8004212769:	eb 3c                	jmp    80042127a7 <dwarf_get_fde_info_for_all_regs+0x1e9>
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
                    CFA.dw_offset_relevant;
  800421276b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421276f:	0f b6 10             	movzbl (%rax),%edx
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
                reg_table->cfa_rule = reg_table->rules[cfa];
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
  8004212772:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212776:	88 10                	mov    %dl,(%rax)
                    CFA.dw_offset_relevant;
                reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  8004212778:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421277c:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  8004212780:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212784:	88 50 01             	mov    %dl,0x1(%rax)
                reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  8004212787:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421278b:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  800421278f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212793:	66 89 50 02          	mov    %dx,0x2(%rax)
                reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  8004212797:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421279b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421279f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042127a3:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042127a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042127ae:	e9 fd 00 00 00       	jmpq   80042128b0 <dwarf_get_fde_info_for_all_regs+0x2f2>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  80042127b3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042127b7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042127ba:	75 05                	jne    80042127c1 <dwarf_get_fde_info_for_all_regs+0x203>
                        continue;
  80042127bc:	e9 eb 00 00 00       	jmpq   80042128ac <dwarf_get_fde_info_for_all_regs+0x2ee>

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042127c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127c5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042127cc:	48 63 d0             	movslq %eax,%rdx
  80042127cf:	48 89 d0             	mov    %rdx,%rax
  80042127d2:	48 01 c0             	add    %rax,%rax
  80042127d5:	48 01 d0             	add    %rdx,%rax
  80042127d8:	48 c1 e0 03          	shl    $0x3,%rax
  80042127dc:	48 01 c8             	add    %rcx,%rax
  80042127df:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  80042127e2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042127e6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042127e9:	48 63 c9             	movslq %ecx,%rcx
  80042127ec:	48 83 c1 01          	add    $0x1,%rcx
  80042127f0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042127f4:	48 01 ca             	add    %rcx,%rdx
  80042127f7:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  80042127f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127fd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212801:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212804:	48 63 d0             	movslq %eax,%rdx
  8004212807:	48 89 d0             	mov    %rdx,%rax
  800421280a:	48 01 c0             	add    %rax,%rax
  800421280d:	48 01 d0             	add    %rdx,%rax
  8004212810:	48 c1 e0 03          	shl    $0x3,%rax
  8004212814:	48 01 c8             	add    %rcx,%rax
  8004212817:	0f b6 40 01          	movzbl 0x1(%rax),%eax
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
  800421281b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421281f:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212822:	48 63 c9             	movslq %ecx,%rcx
  8004212825:	48 83 c1 01          	add    $0x1,%rcx
  8004212829:	48 c1 e1 04          	shl    $0x4,%rcx
  800421282d:	48 01 ca             	add    %rcx,%rdx
  8004212830:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004212833:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212837:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421283b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421283e:	48 63 d0             	movslq %eax,%rdx
  8004212841:	48 89 d0             	mov    %rdx,%rax
  8004212844:	48 01 c0             	add    %rax,%rax
  8004212847:	48 01 d0             	add    %rdx,%rax
  800421284a:	48 c1 e0 03          	shl    $0x3,%rax
  800421284e:	48 01 c8             	add    %rcx,%rax
  8004212851:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004212855:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212859:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421285c:	48 63 c9             	movslq %ecx,%rcx
  800421285f:	48 83 c1 01          	add    $0x1,%rcx
  8004212863:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212867:	48 01 ca             	add    %rcx,%rdx
  800421286a:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  800421286e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212872:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212876:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212879:	48 63 d0             	movslq %eax,%rdx
  800421287c:	48 89 d0             	mov    %rdx,%rax
  800421287f:	48 01 c0             	add    %rax,%rax
  8004212882:	48 01 d0             	add    %rdx,%rax
  8004212885:	48 c1 e0 03          	shl    $0x3,%rax
  8004212889:	48 01 c8             	add    %rcx,%rax
  800421288c:	48 8b 40 08          	mov    0x8(%rax),%rax
                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  8004212890:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212894:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212897:	48 63 c9             	movslq %ecx,%rcx
  800421289a:	48 83 c1 01          	add    $0x1,%rcx
  800421289e:	48 c1 e1 04          	shl    $0x4,%rcx
  80042128a2:	48 01 ca             	add    %rcx,%rdx
  80042128a5:	48 83 c2 08          	add    $0x8,%rdx
  80042128a9:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  80042128ac:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042128b0:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042128b4:	7f 14                	jg     80042128ca <dwarf_get_fde_info_for_all_regs+0x30c>
  80042128b6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042128ba:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042128be:	0f b7 c0             	movzwl %ax,%eax
  80042128c1:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042128c4:	0f 8f e9 fe ff ff    	jg     80042127b3 <dwarf_get_fde_info_for_all_regs+0x1f5>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
        }

        if (row_pc) *row_pc = pc;
  80042128ca:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042128cf:	74 0b                	je     80042128dc <dwarf_get_fde_info_for_all_regs+0x31e>
  80042128d1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042128d5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042128d9:	48 89 10             	mov    %rdx,(%rax)
        return (DW_DLV_OK);
  80042128dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042128e1:	c9                   	leaveq 
  80042128e2:	c3                   	retq   

00000080042128e3 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042128e3:	55                   	push   %rbp
  80042128e4:	48 89 e5             	mov    %rsp,%rbp
  80042128e7:	48 83 ec 40          	sub    $0x40,%rsp
  80042128eb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042128ef:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042128f3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042128f7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80042128fb:	44 89 c0             	mov    %r8d,%eax
  80042128fe:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  8004212902:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004212905:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004212909:	75 0a                	jne    8004212915 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  800421290b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212910:	e9 e6 01 00 00       	jmpq   8004212afb <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004212915:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212919:	83 e0 f0             	and    $0xfffffff0,%eax
  800421291c:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421291f:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004212923:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212927:	83 f8 0c             	cmp    $0xc,%eax
  800421292a:	0f 87 72 01 00 00    	ja     8004212aa2 <_dwarf_frame_read_lsb_encoded+0x1bf>
  8004212930:	89 c0                	mov    %eax,%eax
  8004212932:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212939:	00 
  800421293a:	48 b8 20 9c 21 04 80 	movabs $0x8004219c20,%rax
  8004212941:	00 00 00 
  8004212944:	48 01 d0             	add    %rdx,%rax
  8004212947:	48 8b 00             	mov    (%rax),%rax
  800421294a:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  800421294c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212950:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212954:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212958:	8b 52 28             	mov    0x28(%rdx),%edx
  800421295b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421295f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212963:	48 89 cf             	mov    %rcx,%rdi
  8004212966:	ff d0                	callq  *%rax
  8004212968:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421296c:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421296f:	e9 35 01 00 00       	jmpq   8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  8004212974:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212978:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421297c:	48 89 d6             	mov    %rdx,%rsi
  800421297f:	48 89 c7             	mov    %rax,%rdi
  8004212982:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004212989:	00 00 00 
  800421298c:	ff d0                	callq  *%rax
  800421298e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212992:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212995:	e9 0f 01 00 00       	jmpq   8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  800421299a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421299e:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129a2:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042129a6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129aa:	ba 02 00 00 00       	mov    $0x2,%edx
  80042129af:	48 89 cf             	mov    %rcx,%rdi
  80042129b2:	ff d0                	callq  *%rax
  80042129b4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042129b8:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042129bb:	e9 e9 00 00 00       	jmpq   8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042129c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129c4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129c8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042129cc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129d0:	ba 04 00 00 00       	mov    $0x4,%edx
  80042129d5:	48 89 cf             	mov    %rcx,%rdi
  80042129d8:	ff d0                	callq  *%rax
  80042129da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042129de:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042129e1:	e9 c3 00 00 00       	jmpq   8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  80042129e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042129ea:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042129ee:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042129f2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042129f6:	ba 08 00 00 00       	mov    $0x8,%edx
  80042129fb:	48 89 cf             	mov    %rcx,%rdi
  80042129fe:	ff d0                	callq  *%rax
  8004212a00:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212a04:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212a07:	e9 9d 00 00 00       	jmpq   8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004212a0c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212a14:	48 89 d6             	mov    %rdx,%rsi
  8004212a17:	48 89 c7             	mov    %rax,%rdi
  8004212a1a:	48 b8 be f8 20 04 80 	movabs $0x800420f8be,%rax
  8004212a21:	00 00 00 
  8004212a24:	ff d0                	callq  *%rax
  8004212a26:	48 89 c2             	mov    %rax,%rdx
  8004212a29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a2d:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212a30:	eb 77                	jmp    8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004212a32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a36:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a3a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212a3e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212a42:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212a47:	48 89 cf             	mov    %rcx,%rdi
  8004212a4a:	ff d0                	callq  *%rax
  8004212a4c:	48 0f bf d0          	movswq %ax,%rdx
  8004212a50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a54:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212a57:	eb 50                	jmp    8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004212a59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a5d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a61:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212a65:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212a69:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212a6e:	48 89 cf             	mov    %rcx,%rdi
  8004212a71:	ff d0                	callq  *%rax
  8004212a73:	48 63 d0             	movslq %eax,%rdx
  8004212a76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212a7a:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212a7d:	eb 2a                	jmp    8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  8004212a7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a83:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a87:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212a8b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212a8f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212a94:	48 89 cf             	mov    %rcx,%rdi
  8004212a97:	ff d0                	callq  *%rax
  8004212a99:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212a9d:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212aa0:	eb 07                	jmp    8004212aa9 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212aa2:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212aa7:	eb 52                	jmp    8004212afb <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  8004212aa9:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212aad:	75 47                	jne    8004212af6 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212aaf:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212ab3:	83 f8 01             	cmp    $0x1,%eax
  8004212ab6:	7c 3d                	jl     8004212af5 <_dwarf_frame_read_lsb_encoded+0x212>
  8004212ab8:	83 f8 04             	cmp    $0x4,%eax
  8004212abb:	7e 0a                	jle    8004212ac7 <_dwarf_frame_read_lsb_encoded+0x1e4>
  8004212abd:	83 e8 09             	sub    $0x9,%eax
  8004212ac0:	83 f8 03             	cmp    $0x3,%eax
  8004212ac3:	77 30                	ja     8004212af5 <_dwarf_frame_read_lsb_encoded+0x212>
  8004212ac5:	eb 17                	jmp    8004212ade <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004212ac7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212acb:	48 8b 10             	mov    (%rax),%rdx
  8004212ace:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ad2:	48 01 c2             	add    %rax,%rdx
  8004212ad5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ad9:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212adc:	eb 18                	jmp    8004212af6 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004212ade:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212ae2:	48 8b 10             	mov    (%rax),%rdx
  8004212ae5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212ae9:	48 01 c2             	add    %rax,%rdx
  8004212aec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212af0:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212af3:	eb 01                	jmp    8004212af6 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004212af5:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004212af6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212afb:	c9                   	leaveq 
  8004212afc:	c3                   	retq   

0000008004212afd <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004212afd:	55                   	push   %rbp
  8004212afe:	48 89 e5             	mov    %rsp,%rbp
  8004212b01:	48 83 ec 50          	sub    $0x50,%rsp
  8004212b05:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212b09:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212b0d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  8004212b11:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b15:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212b19:	48 85 c0             	test   %rax,%rax
  8004212b1c:	74 0f                	je     8004212b2d <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212b1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b22:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212b26:	0f b6 00             	movzbl (%rax),%eax
  8004212b29:	3c 7a                	cmp    $0x7a,%al
  8004212b2b:	74 35                	je     8004212b62 <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004212b2d:	48 b9 88 9c 21 04 80 	movabs $0x8004219c88,%rcx
  8004212b34:	00 00 00 
  8004212b37:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  8004212b3e:	00 00 00 
  8004212b41:	be 45 02 00 00       	mov    $0x245,%esi
  8004212b46:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  8004212b4d:	00 00 00 
  8004212b50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b55:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004212b5c:	00 00 00 
  8004212b5f:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  8004212b62:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b66:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212b6a:	48 83 c0 01          	add    $0x1,%rax
  8004212b6e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  8004212b72:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212b76:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212b7a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  8004212b7e:	e9 af 00 00 00       	jmpq   8004212c32 <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  8004212b83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212b87:	0f b6 00             	movzbl (%rax),%eax
  8004212b8a:	0f b6 c0             	movzbl %al,%eax
  8004212b8d:	83 f8 50             	cmp    $0x50,%eax
  8004212b90:	74 18                	je     8004212baa <_dwarf_frame_parse_lsb_cie_augment+0xad>
  8004212b92:	83 f8 52             	cmp    $0x52,%eax
  8004212b95:	74 77                	je     8004212c0e <_dwarf_frame_parse_lsb_cie_augment+0x111>
  8004212b97:	83 f8 4c             	cmp    $0x4c,%eax
  8004212b9a:	0f 85 86 00 00 00    	jne    8004212c26 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004212ba0:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004212ba5:	e9 83 00 00 00       	jmpq   8004212c2d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004212baa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212bae:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212bb2:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212bb6:	0f b6 00             	movzbl (%rax),%eax
  8004212bb9:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004212bbc:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004212bc3:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212bc4:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004212bc9:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212bcd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212bd1:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004212bd5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212bd9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212bdd:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212be1:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004212be7:	48 89 c7             	mov    %rax,%rdi
  8004212bea:	48 b8 e3 28 21 04 80 	movabs $0x80042128e3,%rax
  8004212bf1:	00 00 00 
  8004212bf4:	ff d0                	callq  *%rax
  8004212bf6:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004212bf9:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004212bfd:	74 05                	je     8004212c04 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  8004212bff:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004212c02:	eb 42                	jmp    8004212c46 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004212c04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212c08:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004212c0c:	eb 1f                	jmp    8004212c2d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  8004212c0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212c12:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212c16:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212c1a:	0f b6 10             	movzbl (%rax),%edx
  8004212c1d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212c21:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004212c24:	eb 07                	jmp    8004212c2d <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212c26:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212c2b:	eb 19                	jmp    8004212c46 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  8004212c2d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004212c32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212c36:	0f b6 00             	movzbl (%rax),%eax
  8004212c39:	84 c0                	test   %al,%al
  8004212c3b:	0f 85 42 ff ff ff    	jne    8004212b83 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  8004212c41:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212c46:	c9                   	leaveq 
  8004212c47:	c3                   	retq   

0000008004212c48 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004212c48:	55                   	push   %rbp
  8004212c49:	48 89 e5             	mov    %rsp,%rbp
  8004212c4c:	48 83 ec 60          	sub    $0x60,%rsp
  8004212c50:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212c54:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212c58:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212c5c:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212c60:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004212c64:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212c69:	75 35                	jne    8004212ca0 <_dwarf_frame_set_cie+0x58>
  8004212c6b:	48 b9 bd 9c 21 04 80 	movabs $0x8004219cbd,%rcx
  8004212c72:	00 00 00 
  8004212c75:	48 ba 07 9b 21 04 80 	movabs $0x8004219b07,%rdx
  8004212c7c:	00 00 00 
  8004212c7f:	be 76 02 00 00       	mov    $0x276,%esi
  8004212c84:	48 bf 1c 9b 21 04 80 	movabs $0x8004219b1c,%rdi
  8004212c8b:	00 00 00 
  8004212c8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c93:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004212c9a:	00 00 00 
  8004212c9d:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  8004212ca0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212ca4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004212ca8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cac:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212cb0:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004212cb3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212cb7:	48 8b 10             	mov    (%rax),%rdx
  8004212cba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cbe:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212cc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cc6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212cca:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212cce:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212cd2:	48 89 d1             	mov    %rdx,%rcx
  8004212cd5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212cd9:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212cde:	48 89 cf             	mov    %rcx,%rdi
  8004212ce1:	ff d0                	callq  *%rax
  8004212ce3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212ce7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212cec:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212cf0:	75 2e                	jne    8004212d20 <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004212cf2:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212cf9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cfd:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d01:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d05:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212d09:	48 89 d1             	mov    %rdx,%rcx
  8004212d0c:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d10:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212d15:	48 89 cf             	mov    %rcx,%rdi
  8004212d18:	ff d0                	callq  *%rax
  8004212d1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212d1e:	eb 07                	jmp    8004212d27 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004212d20:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212d27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d2b:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212d2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d33:	48 8b 00             	mov    (%rax),%rax
  8004212d36:	48 29 c2             	sub    %rax,%rdx
  8004212d39:	48 89 d0             	mov    %rdx,%rax
  8004212d3c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212d40:	73 0a                	jae    8004212d4c <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212d42:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212d47:	e9 5d 03 00 00       	jmpq   80042130a9 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004212d4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d50:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d54:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d58:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212d5c:	48 89 d1             	mov    %rdx,%rcx
  8004212d5f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212d62:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d66:	48 89 cf             	mov    %rcx,%rdi
  8004212d69:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004212d6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d6f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212d73:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212d77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d7b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212d7f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d83:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212d87:	48 89 d1             	mov    %rdx,%rcx
  8004212d8a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212d8e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212d93:	48 89 cf             	mov    %rcx,%rdi
  8004212d96:	ff d0                	callq  *%rax
  8004212d98:	89 c2                	mov    %eax,%edx
  8004212d9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d9e:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212da2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212da6:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212daa:	66 83 f8 01          	cmp    $0x1,%ax
  8004212dae:	74 26                	je     8004212dd6 <_dwarf_frame_set_cie+0x18e>
  8004212db0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212db4:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212db8:	66 83 f8 03          	cmp    $0x3,%ax
  8004212dbc:	74 18                	je     8004212dd6 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004212dbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dc2:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212dc6:	66 83 f8 04          	cmp    $0x4,%ax
  8004212dca:	74 0a                	je     8004212dd6 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004212dcc:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212dd1:	e9 d3 02 00 00       	jmpq   80042130a9 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212dd6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212dda:	48 8b 10             	mov    (%rax),%rdx
  8004212ddd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212de1:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212de5:	48 01 d0             	add    %rdx,%rax
  8004212de8:	48 89 c2             	mov    %rax,%rdx
  8004212deb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212def:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004212df3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212df7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212dfb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004212dff:	90                   	nop
  8004212e00:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e04:	48 8b 00             	mov    (%rax),%rax
  8004212e07:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004212e0b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212e0f:	48 89 0a             	mov    %rcx,(%rdx)
  8004212e12:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212e16:	48 01 d0             	add    %rdx,%rax
  8004212e19:	0f b6 00             	movzbl (%rax),%eax
  8004212e1c:	84 c0                	test   %al,%al
  8004212e1e:	75 e0                	jne    8004212e00 <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212e20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e24:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212e28:	0f b6 00             	movzbl (%rax),%eax
  8004212e2b:	84 c0                	test   %al,%al
  8004212e2d:	74 48                	je     8004212e77 <_dwarf_frame_set_cie+0x22f>
  8004212e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e33:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212e37:	0f b6 00             	movzbl (%rax),%eax
  8004212e3a:	3c 7a                	cmp    $0x7a,%al
  8004212e3c:	74 39                	je     8004212e77 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212e3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e42:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212e46:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212e4a:	75 07                	jne    8004212e53 <_dwarf_frame_set_cie+0x20b>
  8004212e4c:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212e51:	eb 05                	jmp    8004212e58 <_dwarf_frame_set_cie+0x210>
  8004212e53:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004212e58:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004212e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e5f:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212e63:	48 01 c2             	add    %rax,%rdx
  8004212e66:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e6a:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004212e6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212e72:	e9 32 02 00 00       	jmpq   80042130a9 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004212e77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e7b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212e7f:	48 be c5 9c 21 04 80 	movabs $0x8004219cc5,%rsi
  8004212e86:	00 00 00 
  8004212e89:	48 89 c7             	mov    %rax,%rdi
  8004212e8c:	48 b8 75 f2 20 04 80 	movabs $0x800420f275,%rax
  8004212e93:	00 00 00 
  8004212e96:	ff d0                	callq  *%rax
  8004212e98:	48 85 c0             	test   %rax,%rax
  8004212e9b:	74 28                	je     8004212ec5 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004212e9d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ea1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ea5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ea9:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212eac:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004212eb0:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004212eb4:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212eb8:	48 89 cf             	mov    %rcx,%rdi
  8004212ebb:	ff d0                	callq  *%rax
  8004212ebd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ec1:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212ec5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ec9:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212ecd:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212ed1:	48 89 d6             	mov    %rdx,%rsi
  8004212ed4:	48 89 c7             	mov    %rax,%rdi
  8004212ed7:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004212ede:	00 00 00 
  8004212ee1:	ff d0                	callq  *%rax
  8004212ee3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ee7:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212eeb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212eef:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212ef3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212ef7:	48 89 d6             	mov    %rdx,%rsi
  8004212efa:	48 89 c7             	mov    %rax,%rdi
  8004212efd:	48 b8 be f8 20 04 80 	movabs $0x800420f8be,%rax
  8004212f04:	00 00 00 
  8004212f07:	ff d0                	callq  *%rax
  8004212f09:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f0d:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004212f11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f15:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212f19:	66 83 f8 01          	cmp    $0x1,%ax
  8004212f1d:	75 2b                	jne    8004212f4a <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212f1f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f23:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f27:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f2b:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f2f:	48 89 d1             	mov    %rdx,%rcx
  8004212f32:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004212f36:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212f3b:	48 89 cf             	mov    %rcx,%rdi
  8004212f3e:	ff d0                	callq  *%rax
  8004212f40:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f44:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004212f48:	eb 26                	jmp    8004212f70 <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212f4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f4e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212f52:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212f56:	48 89 d6             	mov    %rdx,%rsi
  8004212f59:	48 89 c7             	mov    %rax,%rdi
  8004212f5c:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004212f63:	00 00 00 
  8004212f66:	ff d0                	callq  *%rax
  8004212f68:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f6c:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004212f70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f74:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212f78:	0f b6 00             	movzbl (%rax),%eax
  8004212f7b:	3c 7a                	cmp    $0x7a,%al
  8004212f7d:	0f 85 93 00 00 00    	jne    8004213016 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212f83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f87:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212f8b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212f8f:	48 89 d6             	mov    %rdx,%rsi
  8004212f92:	48 89 c7             	mov    %rax,%rdi
  8004212f95:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004212f9c:	00 00 00 
  8004212f9f:	ff d0                	callq  *%rax
  8004212fa1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212fa5:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212fa9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fad:	48 8b 10             	mov    (%rax),%rdx
  8004212fb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fb4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212fb8:	48 01 d0             	add    %rdx,%rax
  8004212fbb:	48 89 c2             	mov    %rax,%rdx
  8004212fbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fc2:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004212fc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fca:	48 8b 10             	mov    (%rax),%rdx
  8004212fcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fd1:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212fd5:	48 01 c2             	add    %rax,%rdx
  8004212fd8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fdc:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212fdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fe3:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004212fe7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212feb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212fef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ff3:	48 89 ce             	mov    %rcx,%rsi
  8004212ff6:	48 89 c7             	mov    %rax,%rdi
  8004212ff9:	48 b8 fd 2a 21 04 80 	movabs $0x8004212afd,%rax
  8004213000:	00 00 00 
  8004213003:	ff d0                	callq  *%rax
  8004213005:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213008:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421300c:	74 08                	je     8004213016 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  800421300e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213011:	e9 93 00 00 00       	jmpq   80042130a9 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213016:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421301a:	48 8b 10             	mov    (%rax),%rdx
  800421301d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213021:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213025:	48 01 d0             	add    %rdx,%rax
  8004213028:	48 89 c2             	mov    %rax,%rdx
  800421302b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421302f:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213033:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213037:	75 2a                	jne    8004213063 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213039:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421303d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213045:	48 01 c2             	add    %rax,%rdx
  8004213048:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421304c:	48 8b 00             	mov    (%rax),%rax
  800421304f:	48 29 c2             	sub    %rax,%rdx
  8004213052:	48 89 d0             	mov    %rdx,%rax
  8004213055:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213059:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421305d:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213061:	eb 28                	jmp    800421308b <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213067:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421306b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421306f:	48 01 c2             	add    %rax,%rdx
  8004213072:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213076:	48 8b 00             	mov    (%rax),%rax
  8004213079:	48 29 c2             	sub    %rax,%rdx
  800421307c:	48 89 d0             	mov    %rdx,%rax
  800421307f:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213083:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213087:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  800421308b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421308f:	48 8b 10             	mov    (%rax),%rdx
  8004213092:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213096:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421309a:	48 01 c2             	add    %rax,%rdx
  800421309d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042130a1:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  80042130a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042130a9:	c9                   	leaveq 
  80042130aa:	c3                   	retq   

00000080042130ab <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  80042130ab:	55                   	push   %rbp
  80042130ac:	48 89 e5             	mov    %rsp,%rbp
  80042130af:	48 83 ec 70          	sub    $0x70,%rsp
  80042130b3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042130b7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042130bb:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042130bf:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042130c3:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  80042130c7:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  80042130cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042130cf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  80042130d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130d7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130db:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042130de:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042130e2:	48 8b 10             	mov    (%rax),%rdx
  80042130e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130e9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042130ed:	48 01 d0             	add    %rdx,%rax
  80042130f0:	48 89 c2             	mov    %rax,%rdx
  80042130f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130f7:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  80042130fb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042130ff:	48 8b 10             	mov    (%rax),%rdx
  8004213102:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213106:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  800421310a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421310e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213112:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213116:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421311a:	48 89 d1             	mov    %rdx,%rcx
  800421311d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213121:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213126:	48 89 cf             	mov    %rcx,%rdi
  8004213129:	ff d0                	callq  *%rax
  800421312b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  800421312f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213134:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213138:	75 2e                	jne    8004213168 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  800421313a:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213141:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213145:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213149:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421314d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213151:	48 89 d1             	mov    %rdx,%rcx
  8004213154:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213158:	ba 08 00 00 00       	mov    $0x8,%edx
  800421315d:	48 89 cf             	mov    %rcx,%rdi
  8004213160:	ff d0                	callq  *%rax
  8004213162:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213166:	eb 07                	jmp    800421316f <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004213168:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  800421316f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213173:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213177:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421317b:	48 8b 00             	mov    (%rax),%rax
  800421317e:	48 29 c2             	sub    %rax,%rdx
  8004213181:	48 89 d0             	mov    %rdx,%rax
  8004213184:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213188:	73 0a                	jae    8004213194 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421318a:	b8 12 00 00 00       	mov    $0x12,%eax
  800421318f:	e9 c4 02 00 00       	jmpq   8004213458 <_dwarf_frame_set_fde+0x3ad>
	}

	fde->fde_length = length;
  8004213194:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213198:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421319c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  80042131a0:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042131a4:	74 5e                	je     8004213204 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042131a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042131aa:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042131ae:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042131b2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042131b6:	48 89 d1             	mov    %rdx,%rcx
  80042131b9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042131bd:	ba 04 00 00 00       	mov    $0x4,%edx
  80042131c2:	48 89 cf             	mov    %rcx,%rdi
  80042131c5:	ff d0                	callq  *%rax
  80042131c7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042131cb:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  80042131cf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131d3:	48 8b 10             	mov    (%rax),%rdx
  80042131d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131da:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042131de:	48 29 c2             	sub    %rax,%rdx
  80042131e1:	48 89 d0             	mov    %rdx,%rax
  80042131e4:	48 83 e8 04          	sub    $0x4,%rax
  80042131e8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  80042131ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131f0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042131f4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042131f8:	75 3d                	jne    8004213237 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  80042131fa:	b8 13 00 00 00       	mov    $0x13,%eax
  80042131ff:	e9 54 02 00 00       	jmpq   8004213458 <_dwarf_frame_set_fde+0x3ad>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004213204:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213208:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421320c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213210:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213214:	48 89 d1             	mov    %rdx,%rcx
  8004213217:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421321a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421321e:	48 89 cf             	mov    %rcx,%rdi
  8004213221:	ff d0                	callq  *%rax
  8004213223:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213227:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  800421322b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421322f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213233:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213237:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  800421323b:	0f 84 c3 00 00 00    	je     8004213304 <_dwarf_frame_set_fde+0x259>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213241:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213245:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213249:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421324d:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213250:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213254:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213258:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  800421325c:	44 0f b6 c0          	movzbl %al,%r8d
  8004213260:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213264:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213268:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800421326c:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213270:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213274:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213278:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421327c:	48 89 c7             	mov    %rax,%rdi
  800421327f:	48 b8 e3 28 21 04 80 	movabs $0x80042128e3,%rax
  8004213286:	00 00 00 
  8004213289:	ff d0                	callq  *%rax
  800421328b:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  800421328e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213292:	74 08                	je     800421329c <_dwarf_frame_set_fde+0x1f1>
			return (ret);
  8004213294:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213297:	e9 bc 01 00 00       	jmpq   8004213458 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_initloc = val;
  800421329c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042132a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132a4:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, 0, error);
  80042132a8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042132ac:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  80042132b0:	44 0f b6 c0          	movzbl %al,%r8d
  80042132b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042132b8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042132bc:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042132c0:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  80042132c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132c8:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  80042132cc:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042132d0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80042132d6:	48 89 c7             	mov    %rax,%rdi
  80042132d9:	48 b8 e3 28 21 04 80 	movabs $0x80042128e3,%rax
  80042132e0:	00 00 00 
  80042132e3:	ff d0                	callq  *%rax
  80042132e5:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  80042132e8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042132ec:	74 08                	je     80042132f6 <_dwarf_frame_set_fde+0x24b>
			return (ret);
  80042132ee:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042132f1:	e9 62 01 00 00       	jmpq   8004213458 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_adrange = val;
  80042132f6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042132fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132fe:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213302:	eb 50                	jmp    8004213354 <_dwarf_frame_set_fde+0x2a9>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004213304:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213308:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421330c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213310:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213313:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213317:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800421331b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421331f:	48 89 cf             	mov    %rcx,%rdi
  8004213322:	ff d0                	callq  *%rax
  8004213324:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213328:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  800421332c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213330:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213334:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213338:	8b 52 28             	mov    0x28(%rdx),%edx
  800421333b:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421333f:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004213343:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213347:	48 89 cf             	mov    %rcx,%rdi
  800421334a:	ff d0                	callq  *%rax
  800421334c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213350:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213354:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213358:	74 6b                	je     80042133c5 <_dwarf_frame_set_fde+0x31a>
  800421335a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421335e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213362:	0f b6 00             	movzbl (%rax),%eax
  8004213365:	3c 7a                	cmp    $0x7a,%al
  8004213367:	75 5c                	jne    80042133c5 <_dwarf_frame_set_fde+0x31a>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213369:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421336d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213371:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213375:	48 89 d6             	mov    %rdx,%rsi
  8004213378:	48 89 c7             	mov    %rax,%rdi
  800421337b:	48 b8 62 f9 20 04 80 	movabs $0x800420f962,%rax
  8004213382:	00 00 00 
  8004213385:	ff d0                	callq  *%rax
  8004213387:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421338b:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421338f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213393:	48 8b 10             	mov    (%rax),%rdx
  8004213396:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421339a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421339e:	48 01 d0             	add    %rdx,%rax
  80042133a1:	48 89 c2             	mov    %rax,%rdx
  80042133a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133a8:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  80042133ac:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133b0:	48 8b 10             	mov    (%rax),%rdx
  80042133b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133b7:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042133bb:	48 01 c2             	add    %rax,%rdx
  80042133be:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133c2:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042133c5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133c9:	48 8b 10             	mov    (%rax),%rdx
  80042133cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042133d0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042133d4:	48 01 d0             	add    %rdx,%rax
  80042133d7:	48 89 c2             	mov    %rax,%rdx
  80042133da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133de:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  80042133e2:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042133e6:	75 2a                	jne    8004213412 <_dwarf_frame_set_fde+0x367>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  80042133e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133ec:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042133f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042133f4:	48 01 c2             	add    %rax,%rdx
  80042133f7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133fb:	48 8b 00             	mov    (%rax),%rax
  80042133fe:	48 29 c2             	sub    %rax,%rdx
  8004213401:	48 89 d0             	mov    %rdx,%rax
  8004213404:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213408:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421340c:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004213410:	eb 28                	jmp    800421343a <_dwarf_frame_set_fde+0x38f>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004213412:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213416:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421341a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421341e:	48 01 c2             	add    %rax,%rdx
  8004213421:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213425:	48 8b 00             	mov    (%rax),%rax
  8004213428:	48 29 c2             	sub    %rax,%rdx
  800421342b:	48 89 d0             	mov    %rdx,%rax
  800421342e:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213432:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213436:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  800421343a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421343e:	48 8b 10             	mov    (%rax),%rdx
  8004213441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213445:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213449:	48 01 c2             	add    %rax,%rdx
  800421344c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213450:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213453:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213458:	c9                   	leaveq 
  8004213459:	c3                   	retq   

000000800421345a <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421345a:	55                   	push   %rbp
  800421345b:	48 89 e5             	mov    %rsp,%rbp
  800421345e:	48 83 ec 20          	sub    $0x20,%rsp
  8004213462:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213466:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  800421346a:	48 b8 a0 56 37 04 80 	movabs $0x80043756a0,%rax
  8004213471:	00 00 00 
  8004213474:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  8004213478:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421347c:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213480:	48 85 c0             	test   %rax,%rax
  8004213483:	74 07                	je     800421348c <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  8004213485:	b8 00 00 00 00       	mov    $0x0,%eax
  800421348a:	eb 33                	jmp    80042134bf <_dwarf_frame_interal_table_init+0x65>

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  800421348c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213490:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  8004213494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213498:	66 89 50 18          	mov    %dx,0x18(%rax)
        rt->rt3_rules = global_rules;
  800421349c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042134a0:	48 b9 c0 5f 37 04 80 	movabs $0x8004375fc0,%rcx
  80042134a7:	00 00 00 
  80042134aa:	48 89 48 20          	mov    %rcx,0x20(%rax)

        dbg->dbg_internal_reg_table = rt;
  80042134ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134b2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042134b6:	48 89 50 58          	mov    %rdx,0x58(%rax)

        return (DW_DLE_NONE);
  80042134ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042134bf:	c9                   	leaveq 
  80042134c0:	c3                   	retq   

00000080042134c1 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042134c1:	55                   	push   %rbp
  80042134c2:	48 89 e5             	mov    %rsp,%rbp
  80042134c5:	48 83 ec 60          	sub    $0x60,%rsp
  80042134c9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042134cd:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042134d0:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042134d4:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  80042134d8:	48 b8 a0 b8 22 04 80 	movabs $0x800422b8a0,%rax
  80042134df:	00 00 00 
  80042134e2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  80042134e6:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042134ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134f1:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042134f5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042134f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134fd:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213501:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213505:	48 39 c2             	cmp    %rax,%rdx
  8004213508:	0f 86 fe 01 00 00    	jbe    800421370c <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  800421350e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213512:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004213516:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421351a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421351e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213522:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213526:	48 89 d1             	mov    %rdx,%rcx
  8004213529:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421352d:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213532:	48 89 cf             	mov    %rcx,%rdi
  8004213535:	ff d0                	callq  *%rax
  8004213537:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  800421353b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213540:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213544:	75 2e                	jne    8004213574 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004213546:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  800421354d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213551:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213555:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213559:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421355d:	48 89 d1             	mov    %rdx,%rcx
  8004213560:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004213564:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213569:	48 89 cf             	mov    %rcx,%rdi
  800421356c:	ff d0                	callq  *%rax
  800421356e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213572:	eb 07                	jmp    800421357b <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  8004213574:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  800421357b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421357f:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213583:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213587:	48 29 c2             	sub    %rax,%rdx
  800421358a:	48 89 d0             	mov    %rdx,%rax
  800421358d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213591:	72 0d                	jb     80042135a0 <_dwarf_get_next_fde+0xdf>
  8004213593:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213598:	75 10                	jne    80042135aa <_dwarf_get_next_fde+0xe9>
  800421359a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421359e:	75 0a                	jne    80042135aa <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042135a0:	b8 12 00 00 00       	mov    $0x12,%eax
  80042135a5:	e9 67 01 00 00       	jmpq   8004213711 <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042135aa:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042135ae:	74 11                	je     80042135c1 <_dwarf_get_next_fde+0x100>
  80042135b0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042135b5:	75 0a                	jne    80042135c1 <_dwarf_get_next_fde+0x100>
			return(-1);
  80042135b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042135bc:	e9 50 01 00 00       	jmpq   8004213711 <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042135c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135c5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135c9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042135cd:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042135d1:	48 89 d1             	mov    %rdx,%rcx
  80042135d4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042135d7:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042135db:	48 89 cf             	mov    %rcx,%rdi
  80042135de:	ff d0                	callq  *%rax
  80042135e0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  80042135e4:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042135e8:	74 79                	je     8004213663 <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042135ea:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042135ef:	75 32                	jne    8004213623 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042135f1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042135f5:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042135f9:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042135fd:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004213601:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004213605:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213609:	49 89 f8             	mov    %rdi,%r8
  800421360c:	48 89 c7             	mov    %rax,%rdi
  800421360f:	48 b8 48 2c 21 04 80 	movabs $0x8004212c48,%rax
  8004213616:	00 00 00 
  8004213619:	ff d0                	callq  *%rax
  800421361b:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421361e:	e9 c8 00 00 00       	jmpq   80042136eb <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004213623:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213627:	4c 8b 40 08          	mov    0x8(%rax),%r8
  800421362b:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421362f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213633:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213637:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421363b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421363f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213643:	4d 89 c1             	mov    %r8,%r9
  8004213646:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  800421364c:	48 89 c7             	mov    %rax,%rdi
  800421364f:	48 b8 ab 30 21 04 80 	movabs $0x80042130ab,%rax
  8004213656:	00 00 00 
  8004213659:	ff d0                	callq  *%rax
  800421365b:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421365e:	e9 88 00 00 00       	jmpq   80042136eb <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004213663:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213667:	75 0b                	jne    8004213674 <_dwarf_get_next_fde+0x1b3>
  8004213669:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421366e:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004213672:	74 0d                	je     8004213681 <_dwarf_get_next_fde+0x1c0>
  8004213674:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004213678:	75 36                	jne    80042136b0 <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  800421367a:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  800421367f:	75 2f                	jne    80042136b0 <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004213681:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213685:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213689:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421368d:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004213691:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004213695:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213699:	49 89 f8             	mov    %rdi,%r8
  800421369c:	48 89 c7             	mov    %rax,%rdi
  800421369f:	48 b8 48 2c 21 04 80 	movabs $0x8004212c48,%rax
  80042136a6:	00 00 00 
  80042136a9:	ff d0                	callq  *%rax
  80042136ab:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042136ae:	eb 3b                	jmp    80042136eb <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042136b0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042136b4:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042136b8:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042136bc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042136c0:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042136c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042136c8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042136cc:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042136d0:	4d 89 c1             	mov    %r8,%r9
  80042136d3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042136d9:	48 89 c7             	mov    %rax,%rdi
  80042136dc:	48 b8 ab 30 21 04 80 	movabs $0x80042130ab,%rax
  80042136e3:	00 00 00 
  80042136e6:	ff d0                	callq  *%rax
  80042136e8:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042136eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042136ef:	74 07                	je     80042136f8 <_dwarf_get_next_fde+0x237>
			return(-1);
  80042136f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042136f6:	eb 19                	jmp    8004213711 <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  80042136f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042136fc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  8004213700:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213704:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213708:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  800421370c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213711:	c9                   	leaveq 
  8004213712:	c3                   	retq   

0000008004213713 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004213713:	55                   	push   %rbp
  8004213714:	48 89 e5             	mov    %rsp,%rbp
  8004213717:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421371b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421371f:	89 f0                	mov    %esi,%eax
  8004213721:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004213725:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213729:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421372d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  8004213731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213735:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004213739:	66 89 50 4c          	mov    %dx,0x4c(%rax)

        return (old_value);
  800421373d:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004213741:	c9                   	leaveq 
  8004213742:	c3                   	retq   

0000008004213743 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213743:	55                   	push   %rbp
  8004213744:	48 89 e5             	mov    %rsp,%rbp
  8004213747:	48 83 ec 10          	sub    $0x10,%rsp
  800421374b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421374f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004213753:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213758:	75 0a                	jne    8004213764 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  800421375a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421375f:	e9 85 00 00 00       	jmpq   80042137e9 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004213764:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213768:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421376c:	48 85 c0             	test   %rax,%rax
  800421376f:	75 25                	jne    8004213796 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  8004213771:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213775:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213779:	48 89 d6             	mov    %rdx,%rsi
  800421377c:	48 89 c7             	mov    %rax,%rdi
  800421377f:	48 b8 5a 34 21 04 80 	movabs $0x800421345a,%rax
  8004213786:	00 00 00 
  8004213789:	ff d0                	callq  *%rax
  800421378b:	85 c0                	test   %eax,%eax
  800421378d:	74 07                	je     8004213796 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  800421378f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213794:	eb 53                	jmp    80042137e9 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004213796:	48 bf a0 b8 22 04 80 	movabs $0x800422b8a0,%rdi
  800421379d:	00 00 00 
  80042137a0:	48 b8 00 12 21 04 80 	movabs $0x8004211200,%rax
  80042137a7:	00 00 00 
  80042137aa:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042137ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042137b0:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042137b7:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042137b8:	48 b8 a0 b8 22 04 80 	movabs $0x800422b8a0,%rax
  80042137bf:	00 00 00 
  80042137c2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042137c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042137ca:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042137ce:	48 b8 a0 b8 22 04 80 	movabs $0x800422b8a0,%rax
  80042137d5:	00 00 00 
  80042137d8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042137dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042137e0:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042137e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042137e9:	c9                   	leaveq 
  80042137ea:	c3                   	retq   

00000080042137eb <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042137eb:	55                   	push   %rbp
  80042137ec:	48 89 e5             	mov    %rsp,%rbp
  80042137ef:	53                   	push   %rbx
  80042137f0:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  80042137f7:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  80042137fb:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  80042137ff:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004213806:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  800421380d:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004213814:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  800421381b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421381f:	48 83 c0 48          	add    $0x48,%rax
  8004213823:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004213827:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421382e:	00 
  800421382f:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004213836:	00 
  8004213837:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421383e:	00 
  800421383f:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004213846:	00 
  8004213847:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421384b:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421384f:	0f b6 c0             	movzbl %al,%eax
  8004213852:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004213855:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  800421385c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004213863:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  800421386a:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213871:	e9 0a 05 00 00       	jmpq   8004213d80 <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  8004213876:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421387d:	0f b6 00             	movzbl (%rax),%eax
  8004213880:	84 c0                	test   %al,%al
  8004213882:	0f 85 78 01 00 00    	jne    8004213a00 <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  8004213888:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421388f:	48 83 c0 01          	add    $0x1,%rax
  8004213893:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  800421389a:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042138a1:	48 89 c7             	mov    %rax,%rdi
  80042138a4:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  80042138ab:	00 00 00 
  80042138ae:	ff d0                	callq  *%rax
  80042138b0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042138b4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042138bb:	0f b6 00             	movzbl (%rax),%eax
  80042138be:	0f b6 c0             	movzbl %al,%eax
  80042138c1:	83 f8 02             	cmp    $0x2,%eax
  80042138c4:	74 7a                	je     8004213940 <_dwarf_lineno_run_program+0x155>
  80042138c6:	83 f8 03             	cmp    $0x3,%eax
  80042138c9:	0f 84 b3 00 00 00    	je     8004213982 <_dwarf_lineno_run_program+0x197>
  80042138cf:	83 f8 01             	cmp    $0x1,%eax
  80042138d2:	0f 85 09 01 00 00    	jne    80042139e1 <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  80042138d8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042138df:	48 83 c0 01          	add    $0x1,%rax
  80042138e3:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  80042138ea:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  80042138f1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042138f8:	00 
  80042138f9:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004213900:	00 
  8004213901:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004213908:	00 
  8004213909:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004213910:	00 
  8004213911:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213915:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004213919:	0f b6 c0             	movzbl %al,%eax
  800421391c:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421391f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004213926:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421392d:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004213934:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  800421393b:	e9 bb 00 00 00       	jmpq   80042139fb <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  8004213940:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213947:	48 83 c0 01          	add    $0x1,%rax
  800421394b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  8004213952:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004213959:	00 00 00 
  800421395c:	48 8b 00             	mov    (%rax),%rax
  800421395f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213963:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004213967:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421396b:	0f b6 ca             	movzbl %dl,%ecx
  800421396e:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004213975:	89 ce                	mov    %ecx,%esi
  8004213977:	48 89 d7             	mov    %rdx,%rdi
  800421397a:	ff d0                	callq  *%rax
  800421397c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  8004213980:	eb 79                	jmp    80042139fb <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  8004213982:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213989:	48 83 c0 01          	add    $0x1,%rax
  800421398d:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004213994:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800421399b:	00 00 00 
  800421399e:	48 8b 08             	mov    (%rax),%rcx
  80042139a1:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042139a8:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042139af:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042139b3:	49 89 c8             	mov    %rcx,%r8
  80042139b6:	48 89 d1             	mov    %rdx,%rcx
  80042139b9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042139be:	48 89 c7             	mov    %rax,%rdi
  80042139c1:	48 b8 a3 3d 21 04 80 	movabs $0x8004213da3,%rax
  80042139c8:	00 00 00 
  80042139cb:	ff d0                	callq  *%rax
  80042139cd:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  80042139d0:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  80042139d4:	74 09                	je     80042139df <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  80042139d6:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  80042139d7:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042139da:	e9 ba 03 00 00       	jmpq   8004213d99 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  80042139df:	eb 1a                	jmp    80042139fb <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  80042139e1:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042139e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042139ec:	48 01 d0             	add    %rdx,%rax
  80042139ef:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042139f6:	e9 85 03 00 00       	jmpq   8004213d80 <_dwarf_lineno_run_program+0x595>
  80042139fb:	e9 80 03 00 00       	jmpq   8004213d80 <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004213a00:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a07:	0f b6 00             	movzbl (%rax),%eax
  8004213a0a:	84 c0                	test   %al,%al
  8004213a0c:	0f 84 3c 02 00 00    	je     8004213c4e <_dwarf_lineno_run_program+0x463>
  8004213a12:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a19:	0f b6 10             	movzbl (%rax),%edx
  8004213a1c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213a20:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213a24:	38 c2                	cmp    %al,%dl
  8004213a26:	0f 83 22 02 00 00    	jae    8004213c4e <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004213a2c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a33:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213a37:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004213a3e:	0f b6 00             	movzbl (%rax),%eax
  8004213a41:	0f b6 c0             	movzbl %al,%eax
  8004213a44:	83 f8 0c             	cmp    $0xc,%eax
  8004213a47:	0f 87 fb 01 00 00    	ja     8004213c48 <_dwarf_lineno_run_program+0x45d>
  8004213a4d:	89 c0                	mov    %eax,%eax
  8004213a4f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213a56:	00 
  8004213a57:	48 b8 c8 9c 21 04 80 	movabs $0x8004219cc8,%rax
  8004213a5e:	00 00 00 
  8004213a61:	48 01 d0             	add    %rdx,%rax
  8004213a64:	48 8b 00             	mov    (%rax),%rax
  8004213a67:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004213a69:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213a70:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213a74:	73 0a                	jae    8004213a80 <_dwarf_lineno_run_program+0x295>
  8004213a76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a7b:	e9 19 03 00 00       	jmpq   8004213d99 <_dwarf_lineno_run_program+0x5ae>
  8004213a80:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a84:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a88:	48 89 10             	mov    %rdx,(%rax)
  8004213a8b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a8f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213a96:	00 
  8004213a97:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a9b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213a9f:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213aa3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213aa7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213aab:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213aaf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ab3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ab7:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213abb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213abf:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213ac2:	89 50 28             	mov    %edx,0x28(%rax)
  8004213ac5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ac9:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213acc:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213acf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ad3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213ad6:	89 50 30             	mov    %edx,0x30(%rax)
  8004213ad9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213add:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213ae4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213ae8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213aec:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004213af3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004213afa:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  8004213b01:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004213b08:	e9 3c 01 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213b0d:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213b14:	48 89 c7             	mov    %rax,%rdi
  8004213b17:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213b1e:	00 00 00 
  8004213b21:	ff d0                	callq  *%rax
					li->li_minlen;
  8004213b23:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004213b27:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213b2b:	0f b6 d2             	movzbl %dl,%edx
  8004213b2e:	48 0f af c2          	imul   %rdx,%rax
  8004213b32:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  8004213b36:	e9 0e 01 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004213b3b:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213b42:	48 89 c7             	mov    %rax,%rdi
  8004213b45:	48 b8 e1 f9 20 04 80 	movabs $0x800420f9e1,%rax
  8004213b4c:	00 00 00 
  8004213b4f:	ff d0                	callq  *%rax
  8004213b51:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  8004213b55:	e9 ef 00 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004213b5a:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213b61:	48 89 c7             	mov    %rax,%rdi
  8004213b64:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213b6b:	00 00 00 
  8004213b6e:	ff d0                	callq  *%rax
  8004213b70:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004213b74:	e9 d0 00 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  8004213b79:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213b80:	48 89 c7             	mov    %rax,%rdi
  8004213b83:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213b8a:	00 00 00 
  8004213b8d:	ff d0                	callq  *%rax
  8004213b8f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  8004213b93:	e9 b1 00 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  8004213b98:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004213b9c:	0f 94 c0             	sete   %al
  8004213b9f:	0f b6 c0             	movzbl %al,%eax
  8004213ba2:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  8004213ba5:	e9 9f 00 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  8004213baa:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  8004213bb1:	e9 93 00 00 00       	jmpq   8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  8004213bb6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213bba:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213bbe:	0f b6 c0             	movzbl %al,%eax
  8004213bc1:	ba ff 00 00 00       	mov    $0xff,%edx
  8004213bc6:	89 d1                	mov    %edx,%ecx
  8004213bc8:	29 c1                	sub    %eax,%ecx
  8004213bca:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213bce:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213bd2:	0f b6 d8             	movzbl %al,%ebx
  8004213bd5:	89 c8                	mov    %ecx,%eax
  8004213bd7:	99                   	cltd   
  8004213bd8:	f7 fb                	idiv   %ebx
  8004213bda:	89 c2                	mov    %eax,%edx
  8004213bdc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213be0:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213be4:	0f b6 c0             	movzbl %al,%eax
  8004213be7:	0f af c2             	imul   %edx,%eax
  8004213bea:	48 98                	cltq   
  8004213bec:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004213bf0:	eb 57                	jmp    8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004213bf2:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004213bf9:	00 00 00 
  8004213bfc:	48 8b 00             	mov    (%rax),%rax
  8004213bff:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213c03:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004213c0a:	be 02 00 00 00       	mov    $0x2,%esi
  8004213c0f:	48 89 d7             	mov    %rdx,%rdi
  8004213c12:	ff d0                	callq  *%rax
  8004213c14:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004213c18:	eb 2f                	jmp    8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004213c1a:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  8004213c21:	eb 26                	jmp    8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004213c23:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004213c2a:	eb 1d                	jmp    8004213c49 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004213c2c:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004213c33:	48 89 c7             	mov    %rax,%rdi
  8004213c36:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213c3d:	00 00 00 
  8004213c40:	ff d0                	callq  *%rax
  8004213c42:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  8004213c46:	eb 01                	jmp    8004213c49 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004213c48:	90                   	nop
			}

		} else {
  8004213c49:	e9 32 01 00 00       	jmpq   8004213d80 <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  8004213c4e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c52:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004213c56:	0f be c8             	movsbl %al,%ecx
  8004213c59:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213c60:	0f b6 00             	movzbl (%rax),%eax
  8004213c63:	0f b6 d0             	movzbl %al,%edx
  8004213c66:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c6a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213c6e:	0f b6 c0             	movzbl %al,%eax
  8004213c71:	29 c2                	sub    %eax,%edx
  8004213c73:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c77:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213c7b:	0f b6 f0             	movzbl %al,%esi
  8004213c7e:	89 d0                	mov    %edx,%eax
  8004213c80:	99                   	cltd   
  8004213c81:	f7 fe                	idiv   %esi
  8004213c83:	89 d0                	mov    %edx,%eax
  8004213c85:	01 c8                	add    %ecx,%eax
  8004213c87:	48 98                	cltq   
  8004213c89:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  8004213c8d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213c94:	0f b6 00             	movzbl (%rax),%eax
  8004213c97:	0f b6 d0             	movzbl %al,%edx
  8004213c9a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213c9e:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213ca2:	0f b6 c0             	movzbl %al,%eax
  8004213ca5:	89 d1                	mov    %edx,%ecx
  8004213ca7:	29 c1                	sub    %eax,%ecx
  8004213ca9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213cad:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213cb1:	0f b6 d8             	movzbl %al,%ebx
  8004213cb4:	89 c8                	mov    %ecx,%eax
  8004213cb6:	99                   	cltd   
  8004213cb7:	f7 fb                	idiv   %ebx
  8004213cb9:	89 c2                	mov    %eax,%edx
  8004213cbb:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213cbf:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213cc3:	0f b6 c0             	movzbl %al,%eax
  8004213cc6:	0f af c2             	imul   %edx,%eax
  8004213cc9:	48 98                	cltq   
  8004213ccb:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004213ccf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213cd6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213cda:	73 0a                	jae    8004213ce6 <_dwarf_lineno_run_program+0x4fb>
  8004213cdc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213ce1:	e9 b3 00 00 00       	jmpq   8004213d99 <_dwarf_lineno_run_program+0x5ae>
  8004213ce6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213cee:	48 89 10             	mov    %rdx,(%rax)
  8004213cf1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cf5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213cfc:	00 
  8004213cfd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d01:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213d05:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213d09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d0d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213d11:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213d15:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d19:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d1d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213d21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d25:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004213d28:	89 50 28             	mov    %edx,0x28(%rax)
  8004213d2b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d2f:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004213d32:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213d35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213d39:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004213d3c:	89 50 30             	mov    %edx,0x30(%rax)
  8004213d3f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213d43:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213d4a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213d4e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004213d52:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004213d59:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004213d60:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004213d67:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004213d6e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213d75:	48 83 c0 01          	add    $0x1,%rax
  8004213d79:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213d80:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213d87:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004213d8e:	0f 82 e2 fa ff ff    	jb     8004213876 <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004213d94:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004213d99:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004213da0:	5b                   	pop    %rbx
  8004213da1:	5d                   	pop    %rbp
  8004213da2:	c3                   	retq   

0000008004213da3 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004213da3:	55                   	push   %rbp
  8004213da4:	48 89 e5             	mov    %rsp,%rbp
  8004213da7:	53                   	push   %rbx
  8004213da8:	48 83 ec 48          	sub    $0x48,%rsp
  8004213dac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004213db0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004213db4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213db8:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213dbc:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004213dc0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213dc4:	48 8b 00             	mov    (%rax),%rax
  8004213dc7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004213dcb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213dcf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004213dd3:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004213dd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ddb:	48 89 c7             	mov    %rax,%rdi
  8004213dde:	48 b8 4b eb 20 04 80 	movabs $0x800420eb4b,%rax
  8004213de5:	00 00 00 
  8004213de8:	ff d0                	callq  *%rax
  8004213dea:	48 98                	cltq   
  8004213dec:	48 83 c0 01          	add    $0x1,%rax
  8004213df0:	48 01 d8             	add    %rbx,%rax
  8004213df3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004213df7:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213dfb:	48 89 c7             	mov    %rax,%rdi
  8004213dfe:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213e05:	00 00 00 
  8004213e08:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004213e0a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213e0e:	48 89 c7             	mov    %rax,%rdi
  8004213e11:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213e18:	00 00 00 
  8004213e1b:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004213e1d:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213e21:	48 89 c7             	mov    %rax,%rdi
  8004213e24:	48 b8 73 fa 20 04 80 	movabs $0x800420fa73,%rax
  8004213e2b:	00 00 00 
  8004213e2e:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004213e30:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213e34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213e38:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004213e3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213e40:	48 83 c4 48          	add    $0x48,%rsp
  8004213e44:	5b                   	pop    %rbx
  8004213e45:	5d                   	pop    %rbp
  8004213e46:	c3                   	retq   

0000008004213e47 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004213e47:	55                   	push   %rbp
  8004213e48:	48 89 e5             	mov    %rsp,%rbp
  8004213e4b:	53                   	push   %rbx
  8004213e4c:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004213e53:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004213e5a:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004213e61:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004213e68:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004213e6f:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004213e76:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004213e7d:	00 
  8004213e7e:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004213e85:	00 
  8004213e86:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004213e8d:	00 
  8004213e8e:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004213e95:	00 
  8004213e96:	48 b8 30 9d 21 04 80 	movabs $0x8004219d30,%rax
  8004213e9d:	00 00 00 
  8004213ea0:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004213ea4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004213ea8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004213eac:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004213eb3:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213eba:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004213ebe:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213ec3:	75 35                	jne    8004213efa <_dwarf_lineno_init+0xb3>
  8004213ec5:	48 b9 3c 9d 21 04 80 	movabs $0x8004219d3c,%rcx
  8004213ecc:	00 00 00 
  8004213ecf:	48 ba 47 9d 21 04 80 	movabs $0x8004219d47,%rdx
  8004213ed6:	00 00 00 
  8004213ed9:	be 17 01 00 00       	mov    $0x117,%esi
  8004213ede:	48 bf 5c 9d 21 04 80 	movabs $0x8004219d5c,%rdi
  8004213ee5:	00 00 00 
  8004213ee8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213eed:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004213ef4:	00 00 00 
  8004213ef7:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004213efa:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004213f01:	00 00 00 
  8004213f04:	48 8b 00             	mov    (%rax),%rax
  8004213f07:	48 85 c0             	test   %rax,%rax
  8004213f0a:	75 35                	jne    8004213f41 <_dwarf_lineno_init+0xfa>
  8004213f0c:	48 b9 73 9d 21 04 80 	movabs $0x8004219d73,%rcx
  8004213f13:	00 00 00 
  8004213f16:	48 ba 47 9d 21 04 80 	movabs $0x8004219d47,%rdx
  8004213f1d:	00 00 00 
  8004213f20:	be 18 01 00 00       	mov    $0x118,%esi
  8004213f25:	48 bf 5c 9d 21 04 80 	movabs $0x8004219d5c,%rdi
  8004213f2c:	00 00 00 
  8004213f2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213f34:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004213f3b:	00 00 00 
  8004213f3e:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004213f41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213f45:	48 89 c7             	mov    %rax,%rdi
  8004213f48:	48 b8 00 12 21 04 80 	movabs $0x8004211200,%rax
  8004213f4f:	00 00 00 
  8004213f52:	ff d0                	callq  *%rax
  8004213f54:	85 c0                	test   %eax,%eax
  8004213f56:	74 0a                	je     8004213f62 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004213f58:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213f5d:	e9 4f 04 00 00       	jmpq   80042143b1 <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004213f62:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004213f69:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004213f6d:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004213f74:	00 00 00 
  8004213f77:	48 8b 00             	mov    (%rax),%rax
  8004213f7a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f7e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f82:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f86:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f8d:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213f92:	48 89 cf             	mov    %rcx,%rdi
  8004213f95:	ff d0                	callq  *%rax
  8004213f97:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004213f9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213fa0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004213fa4:	75 37                	jne    8004213fdd <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004213fa6:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004213fad:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004213fb4:	00 00 00 
  8004213fb7:	48 8b 00             	mov    (%rax),%rax
  8004213fba:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213fbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213fc2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213fc6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213fcd:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213fd2:	48 89 cf             	mov    %rcx,%rdi
  8004213fd5:	ff d0                	callq  *%rax
  8004213fd7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213fdb:	eb 07                	jmp    8004213fe4 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004213fdd:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004213fe4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213fe8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213fec:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213ff3:	48 29 c2             	sub    %rax,%rdx
  8004213ff6:	48 89 d0             	mov    %rdx,%rax
  8004213ff9:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213ffd:	73 0a                	jae    8004214009 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213fff:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214004:	e9 a8 03 00 00       	jmpq   80042143b1 <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004214009:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421400d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214011:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004214014:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  800421401b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421401f:	48 01 d0             	add    %rdx,%rax
  8004214022:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214026:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800421402d:	00 00 00 
  8004214030:	48 8b 00             	mov    (%rax),%rax
  8004214033:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214037:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421403b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421403f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214046:	ba 02 00 00 00       	mov    $0x2,%edx
  800421404b:	48 89 cf             	mov    %rcx,%rdi
  800421404e:	ff d0                	callq  *%rax
  8004214050:	89 c2                	mov    %eax,%edx
  8004214052:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214056:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  800421405a:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004214061:	00 00 00 
  8004214064:	48 8b 00             	mov    (%rax),%rax
  8004214067:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421406b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421406f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214073:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214076:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421407d:	48 89 cf             	mov    %rcx,%rdi
  8004214080:	ff d0                	callq  *%rax
  8004214082:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214086:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  800421408a:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214091:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214095:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  800421409c:	00 00 00 
  800421409f:	48 8b 00             	mov    (%rax),%rax
  80042140a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042140a6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140aa:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042140ae:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042140b5:	ba 01 00 00 00       	mov    $0x1,%edx
  80042140ba:	48 89 cf             	mov    %rcx,%rdi
  80042140bd:	ff d0                	callq  *%rax
  80042140bf:	89 c2                	mov    %eax,%edx
  80042140c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140c5:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  80042140c8:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  80042140cf:	00 00 00 
  80042140d2:	48 8b 00             	mov    (%rax),%rax
  80042140d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042140d9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042140dd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042140e1:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  80042140e8:	ba 01 00 00 00       	mov    $0x1,%edx
  80042140ed:	48 89 cf             	mov    %rcx,%rdi
  80042140f0:	ff d0                	callq  *%rax
  80042140f2:	89 c2                	mov    %eax,%edx
  80042140f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042140f8:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  80042140fb:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004214102:	00 00 00 
  8004214105:	48 8b 00             	mov    (%rax),%rax
  8004214108:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421410c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214110:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214114:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421411b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214120:	48 89 cf             	mov    %rcx,%rdi
  8004214123:	ff d0                	callq  *%rax
  8004214125:	89 c2                	mov    %eax,%edx
  8004214127:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421412b:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  800421412e:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004214135:	00 00 00 
  8004214138:	48 8b 00             	mov    (%rax),%rax
  800421413b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421413f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214143:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214147:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  800421414e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214153:	48 89 cf             	mov    %rcx,%rdi
  8004214156:	ff d0                	callq  *%rax
  8004214158:	89 c2                	mov    %eax,%edx
  800421415a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421415e:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214161:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  8004214168:	00 00 00 
  800421416b:	48 8b 00             	mov    (%rax),%rax
  800421416e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214172:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214176:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800421417a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214181:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214186:	48 89 cf             	mov    %rcx,%rdi
  8004214189:	ff d0                	callq  *%rax
  800421418b:	89 c2                	mov    %eax,%edx
  800421418d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214191:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214194:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214198:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421419c:	8d 50 fb             	lea    -0x5(%rax),%edx
  800421419f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042141a3:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042141a7:	0f b6 c0             	movzbl %al,%eax
  80042141aa:	83 e8 01             	sub    $0x1,%eax
  80042141ad:	39 c2                	cmp    %eax,%edx
  80042141af:	7d 0c                	jge    80042141bd <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042141b1:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042141b8:	e9 f1 01 00 00       	jmpq   80042143ae <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  80042141bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042141c1:	48 bb 00 66 37 04 80 	movabs $0x8004376600,%rbx
  80042141c8:	00 00 00 
  80042141cb:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  80042141cf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  80042141d6:	eb 41                	jmp    8004214219 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  80042141d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042141dc:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042141e0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042141e3:	48 98                	cltq   
  80042141e5:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  80042141e9:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  80042141f0:	00 00 00 
  80042141f3:	48 8b 00             	mov    (%rax),%rax
  80042141f6:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042141fa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042141fe:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214202:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214209:	ba 01 00 00 00       	mov    $0x1,%edx
  800421420e:	48 89 cf             	mov    %rcx,%rdi
  8004214211:	ff d0                	callq  *%rax
  8004214213:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214215:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214219:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421421d:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214221:	0f b6 c0             	movzbl %al,%eax
  8004214224:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214227:	7f af                	jg     80042141d8 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004214229:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214230:	00 
	p = ds->ds_data + offset;
  8004214231:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214235:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214239:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214240:	48 01 d0             	add    %rdx,%rax
  8004214243:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  800421424a:	eb 1f                	jmp    800421426b <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  800421424c:	90                   	nop
  800421424d:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214254:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214258:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  800421425f:	0f b6 00             	movzbl (%rax),%eax
  8004214262:	84 c0                	test   %al,%al
  8004214264:	75 e7                	jne    800421424d <_dwarf_lineno_init+0x406>
			;
		length++;
  8004214266:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  800421426b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214272:	0f b6 00             	movzbl (%rax),%eax
  8004214275:	84 c0                	test   %al,%al
  8004214277:	75 d3                	jne    800421424c <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004214279:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421427d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214281:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214285:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421428c:	48 89 c2             	mov    %rax,%rdx
  800421428f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214293:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214297:	48 29 c2             	sub    %rax,%rdx
  800421429a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421429e:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042142a2:	48 98                	cltq   
  80042142a4:	48 39 c2             	cmp    %rax,%rdx
  80042142a7:	7e 0c                	jle    80042142b5 <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042142a9:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042142b0:	e9 f9 00 00 00       	jmpq   80042143ae <_dwarf_lineno_init+0x567>
  li->li_incdirs[i++] = (char *) p;
  while (*p++ != '\0')
  ;
  }
*/
	p++;
  80042142b5:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042142bc:	48 83 c0 01          	add    $0x1,%rax
  80042142c0:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  80042142c7:	eb 3c                	jmp    8004214305 <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  80042142c9:	48 b8 98 b8 22 04 80 	movabs $0x800422b898,%rax
  80042142d0:	00 00 00 
  80042142d3:	48 8b 08             	mov    (%rax),%rcx
  80042142d6:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  80042142dd:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  80042142e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042142e8:	49 89 c8             	mov    %rcx,%r8
  80042142eb:	48 89 d1             	mov    %rdx,%rcx
  80042142ee:	ba 00 00 00 00       	mov    $0x0,%edx
  80042142f3:	48 89 c7             	mov    %rax,%rdi
  80042142f6:	48 b8 a3 3d 21 04 80 	movabs $0x8004213da3,%rax
  80042142fd:	00 00 00 
  8004214300:	ff d0                	callq  *%rax
  8004214302:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214305:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421430c:	0f b6 00             	movzbl (%rax),%eax
  800421430f:	84 c0                	test   %al,%al
  8004214311:	75 b6                	jne    80042142c9 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214313:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421431a:	48 83 c0 01          	add    $0x1,%rax
  800421431e:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214325:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421432c:	48 89 c2             	mov    %rax,%rdx
  800421432f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214333:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214337:	48 29 c2             	sub    %rax,%rdx
  800421433a:	48 89 d0             	mov    %rdx,%rax
  800421433d:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214341:	48 89 c2             	mov    %rax,%rdx
  8004214344:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214348:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421434c:	48 39 c2             	cmp    %rax,%rdx
  800421434f:	74 09                	je     800421435a <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214351:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214358:	eb 54                	jmp    80042143ae <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  800421435a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421435e:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214362:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214366:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800421436a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004214371:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214378:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  800421437f:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214383:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214387:	4d 89 c1             	mov    %r8,%r9
  800421438a:	49 89 f8             	mov    %rdi,%r8
  800421438d:	48 89 c7             	mov    %rax,%rdi
  8004214390:	48 b8 eb 37 21 04 80 	movabs $0x80042137eb,%rax
  8004214397:	00 00 00 
  800421439a:	ff d0                	callq  *%rax
  800421439c:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  800421439f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042143a3:	74 02                	je     80042143a7 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  80042143a5:	eb 07                	jmp    80042143ae <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  80042143a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042143ac:	eb 03                	jmp    80042143b1 <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  80042143ae:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  80042143b1:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  80042143b8:	5b                   	pop    %rbx
  80042143b9:	5d                   	pop    %rbp
  80042143ba:	c3                   	retq   

00000080042143bb <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042143bb:	55                   	push   %rbp
  80042143bc:	48 89 e5             	mov    %rsp,%rbp
  80042143bf:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80042143c6:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042143cd:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  80042143d4:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  80042143db:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  80042143e2:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  80042143e9:	00 
  80042143ea:	75 35                	jne    8004214421 <dwarf_srclines+0x66>
  80042143ec:	48 b9 7f 9d 21 04 80 	movabs $0x8004219d7f,%rcx
  80042143f3:	00 00 00 
  80042143f6:	48 ba 47 9d 21 04 80 	movabs $0x8004219d47,%rdx
  80042143fd:	00 00 00 
  8004214400:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004214405:	48 bf 5c 9d 21 04 80 	movabs $0x8004219d5c,%rdi
  800421440c:	00 00 00 
  800421440f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214414:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421441b:	00 00 00 
  800421441e:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004214421:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004214428:	00 
  8004214429:	75 35                	jne    8004214460 <dwarf_srclines+0xa5>
  800421442b:	48 b9 83 9d 21 04 80 	movabs $0x8004219d83,%rcx
  8004214432:	00 00 00 
  8004214435:	48 ba 47 9d 21 04 80 	movabs $0x8004219d47,%rdx
  800421443c:	00 00 00 
  800421443f:	be af 01 00 00       	mov    $0x1af,%esi
  8004214444:	48 bf 5c 9d 21 04 80 	movabs $0x8004219d5c,%rdi
  800421444b:	00 00 00 
  800421444e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214453:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421445a:	00 00 00 
  800421445d:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004214460:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004214467:	ba 88 00 00 00       	mov    $0x88,%edx
  800421446c:	be 00 00 00 00       	mov    $0x0,%esi
  8004214471:	48 89 c7             	mov    %rax,%rdi
  8004214474:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  800421447b:	00 00 00 
  800421447e:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004214480:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214487:	be 10 00 00 00       	mov    $0x10,%esi
  800421448c:	48 89 c7             	mov    %rax,%rdi
  800421448f:	48 b8 85 0d 21 04 80 	movabs $0x8004210d85,%rax
  8004214496:	00 00 00 
  8004214499:	ff d0                	callq  *%rax
  800421449b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421449f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042144a4:	75 0a                	jne    80042144b0 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042144a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042144ab:	e9 84 00 00 00       	jmpq   8004214534 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  80042144b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042144b4:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042144b8:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042144bf:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  80042144c6:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  80042144cd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042144d4:	49 89 f8             	mov    %rdi,%r8
  80042144d7:	48 89 c7             	mov    %rax,%rdi
  80042144da:	48 b8 47 3e 21 04 80 	movabs $0x8004213e47,%rax
  80042144e1:	00 00 00 
  80042144e4:	ff d0                	callq  *%rax
  80042144e6:	85 c0                	test   %eax,%eax
  80042144e8:	74 07                	je     80042144f1 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  80042144ea:	b8 01 00 00 00       	mov    $0x1,%eax
  80042144ef:	eb 43                	jmp    8004214534 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  80042144f1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042144f8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042144fc:	48 89 10             	mov    %rdx,(%rax)
  80042144ff:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214503:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004214507:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421450b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421450f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214513:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214517:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421451b:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421451f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214523:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004214527:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421452b:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  800421452f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214534:	c9                   	leaveq 
  8004214535:	c3                   	retq   

0000008004214536 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004214536:	55                   	push   %rbp
  8004214537:	48 89 e5             	mov    %rsp,%rbp
  800421453a:	48 83 ec 20          	sub    $0x20,%rsp
  800421453e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004214542:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004214549:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421454a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214551:	eb 57                	jmp    80042145aa <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004214553:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  800421455a:	00 00 00 
  800421455d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214560:	48 63 d2             	movslq %edx,%rdx
  8004214563:	48 c1 e2 05          	shl    $0x5,%rdx
  8004214567:	48 01 d0             	add    %rdx,%rax
  800421456a:	48 8b 00             	mov    (%rax),%rax
  800421456d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214571:	48 89 d6             	mov    %rdx,%rsi
  8004214574:	48 89 c7             	mov    %rax,%rdi
  8004214577:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  800421457e:	00 00 00 
  8004214581:	ff d0                	callq  *%rax
  8004214583:	85 c0                	test   %eax,%eax
  8004214585:	75 1f                	jne    80042145a6 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  8004214587:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421458a:	48 98                	cltq   
  800421458c:	48 c1 e0 05          	shl    $0x5,%rax
  8004214590:	48 89 c2             	mov    %rax,%rdx
  8004214593:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  800421459a:	00 00 00 
  800421459d:	48 01 d0             	add    %rdx,%rax
  80042145a0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042145a4:	eb 0a                	jmp    80042145b0 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042145a6:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042145aa:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042145ae:	7e a3                	jle    8004214553 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042145b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042145b4:	c9                   	leaveq 
  80042145b5:	c3                   	retq   

00000080042145b6 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042145b6:	55                   	push   %rbp
  80042145b7:	48 89 e5             	mov    %rsp,%rbp
  80042145ba:	48 83 ec 40          	sub    $0x40,%rsp
  80042145be:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042145c2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042145c6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  80042145ca:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  80042145d1:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  80042145d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145d6:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042145da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145de:	48 01 d0             	add    %rdx,%rax
  80042145e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  80042145e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145e9:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042145ed:	0f b7 c0             	movzwl %ax,%eax
  80042145f0:	48 c1 e0 06          	shl    $0x6,%rax
  80042145f4:	48 89 c2             	mov    %rax,%rdx
  80042145f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145fb:	48 01 d0             	add    %rdx,%rax
  80042145fe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004214602:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214606:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421460a:	0f b7 c0             	movzwl %ax,%eax
  800421460d:	48 c1 e0 06          	shl    $0x6,%rax
  8004214611:	48 89 c2             	mov    %rax,%rdx
  8004214614:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214618:	48 01 d0             	add    %rdx,%rax
  800421461b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  800421461f:	e9 4b 02 00 00       	jmpq   800421486f <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004214624:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214628:	8b 00                	mov    (%rax),%eax
  800421462a:	89 c2                	mov    %eax,%edx
  800421462c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214630:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004214634:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214638:	48 01 c8             	add    %rcx,%rax
  800421463b:	48 01 d0             	add    %rdx,%rax
  800421463e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004214642:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214646:	48 be 8b 9d 21 04 80 	movabs $0x8004219d8b,%rsi
  800421464d:	00 00 00 
  8004214650:	48 89 c7             	mov    %rax,%rdi
  8004214653:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  800421465a:	00 00 00 
  800421465d:	ff d0                	callq  *%rax
  800421465f:	85 c0                	test   %eax,%eax
  8004214661:	75 4b                	jne    80042146ae <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004214663:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214667:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  800421466e:	00 00 00 
  8004214671:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004214675:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  800421467c:	00 00 00 
  800421467f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214683:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004214687:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421468b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421468f:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214696:	00 00 00 
  8004214699:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  800421469d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146a1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042146a5:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042146a9:	e9 bc 01 00 00       	jmpq   800421486a <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042146ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042146b2:	48 be 97 9d 21 04 80 	movabs $0x8004219d97,%rsi
  80042146b9:	00 00 00 
  80042146bc:	48 89 c7             	mov    %rax,%rdi
  80042146bf:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  80042146c6:	00 00 00 
  80042146c9:	ff d0                	callq  *%rax
  80042146cb:	85 c0                	test   %eax,%eax
  80042146cd:	75 4b                	jne    800421471a <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042146cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042146d3:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  80042146da:	00 00 00 
  80042146dd:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  80042146e1:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  80042146e8:	00 00 00 
  80042146eb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042146ef:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  80042146f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042146f7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042146fb:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214702:	00 00 00 
  8004214705:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004214709:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421470d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214711:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214715:	e9 50 01 00 00       	jmpq   800421486a <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  800421471a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421471e:	48 be af 9d 21 04 80 	movabs $0x8004219daf,%rsi
  8004214725:	00 00 00 
  8004214728:	48 89 c7             	mov    %rax,%rdi
  800421472b:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214732:	00 00 00 
  8004214735:	ff d0                	callq  *%rax
  8004214737:	85 c0                	test   %eax,%eax
  8004214739:	75 4b                	jne    8004214786 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  800421473b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421473f:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214746:	00 00 00 
  8004214749:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  800421474d:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214754:	00 00 00 
  8004214757:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421475b:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  800421475f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214763:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214767:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  800421476e:	00 00 00 
  8004214771:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  8004214775:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214779:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421477d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214781:	e9 e4 00 00 00       	jmpq   800421486a <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  8004214786:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421478a:	48 be a5 9d 21 04 80 	movabs $0x8004219da5,%rsi
  8004214791:	00 00 00 
  8004214794:	48 89 c7             	mov    %rax,%rdi
  8004214797:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  800421479e:	00 00 00 
  80042147a1:	ff d0                	callq  *%rax
  80042147a3:	85 c0                	test   %eax,%eax
  80042147a5:	75 53                	jne    80042147fa <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042147a7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147ab:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042147af:	48 89 c2             	mov    %rax,%rdx
  80042147b2:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  80042147b9:	00 00 00 
  80042147bc:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042147c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147c4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042147c8:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  80042147cf:	00 00 00 
  80042147d2:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  80042147d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147da:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042147de:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  80042147e5:	00 00 00 
  80042147e8:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  80042147ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042147f0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042147f4:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042147f8:	eb 70                	jmp    800421486a <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  80042147fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042147fe:	48 be bb 9d 21 04 80 	movabs $0x8004219dbb,%rsi
  8004214805:	00 00 00 
  8004214808:	48 89 c7             	mov    %rax,%rdi
  800421480b:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214812:	00 00 00 
  8004214815:	ff d0                	callq  *%rax
  8004214817:	85 c0                	test   %eax,%eax
  8004214819:	75 4f                	jne    800421486a <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  800421481b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421481f:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214826:	00 00 00 
  8004214829:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004214830:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214837:	00 00 00 
  800421483a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421483e:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004214845:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214849:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421484d:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214854:	00 00 00 
  8004214857:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  800421485e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214862:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214866:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  800421486a:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  800421486f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214873:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004214877:	0f 82 a7 fd ff ff    	jb     8004214624 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  800421487d:	c9                   	leaveq 
  800421487e:	c3                   	retq   

000000800421487f <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  800421487f:	55                   	push   %rbp
  8004214880:	48 89 e5             	mov    %rsp,%rbp
  8004214883:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  800421488a:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004214891:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  8004214898:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  800421489f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042148a4:	ba 14 00 00 00       	mov    $0x14,%edx
  80042148a9:	48 89 f7             	mov    %rsi,%rdi
  80042148ac:	48 89 d1             	mov    %rdx,%rcx
  80042148af:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042148b2:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042148b9:	00 
  80042148ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042148be:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042148c5:	48 01 d0             	add    %rdx,%rax
  80042148c8:	48 83 e8 01          	sub    $0x1,%rax
  80042148cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042148d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042148d4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042148d9:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042148dd:	48 89 d0             	mov    %rdx,%rax
  80042148e0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042148e4:	48 29 c2             	sub    %rax,%rdx
  80042148e7:	48 89 d0             	mov    %rdx,%rax
  80042148ea:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  80042148ee:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  80042148f5:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  80042148f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042148fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  8004214901:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004214908:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004214909:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  8004214910:	00 00 00 
  8004214913:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  800421491a:	75 11                	jne    800421492d <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  800421491c:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214923:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214927:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421492b:	eb 26                	jmp    8004214953 <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  800421492d:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214934:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214938:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421493f:	48 01 c2             	add    %rax,%rdx
  8004214942:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004214949:	ff ff ff 
  800421494c:	48 01 d0             	add    %rdx,%rax
  800421494f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004214953:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421495a:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421495e:	0f b7 c0             	movzwl %ax,%eax
  8004214961:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004214964:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421496b:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  800421496f:	0f b7 c0             	movzwl %ax,%eax
  8004214972:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004214975:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421497c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  8004214980:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004214983:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004214987:	48 63 f0             	movslq %eax,%rsi
  800421498a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421498e:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214995:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214999:	48 89 c7             	mov    %rax,%rdi
  800421499c:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  80042149a3:	00 00 00 
  80042149a6:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042149a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042149ac:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042149b0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149b4:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042149ba:	48 89 c2             	mov    %rax,%rdx
  80042149bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042149c1:	48 29 d0             	sub    %rdx,%rax
  80042149c4:	48 89 c2             	mov    %rax,%rdx
  80042149c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042149cb:	48 01 d0             	add    %rdx,%rax
  80042149ce:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042149d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042149d9:	eb 24                	jmp    80042149ff <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  80042149db:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149de:	48 98                	cltq   
  80042149e0:	48 c1 e0 06          	shl    $0x6,%rax
  80042149e4:	48 89 c2             	mov    %rax,%rdx
  80042149e7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042149eb:	48 01 c2             	add    %rax,%rdx
  80042149ee:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149f1:	48 98                	cltq   
  80042149f3:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  80042149fa:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  80042149fb:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042149ff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a02:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214a05:	7c d4                	jl     80042149db <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004214a07:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a0b:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004214a0f:	0f b7 c0             	movzwl %ax,%eax
  8004214a12:	48 98                	cltq   
  8004214a14:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a1b:	ff 
  8004214a1c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  8004214a20:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214a27:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004214a2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214a2f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a33:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214a37:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214a3b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214a42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a46:	48 01 c8             	add    %rcx,%rax
  8004214a49:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214a50:	48 89 c7             	mov    %rax,%rdi
  8004214a53:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  8004214a5a:	00 00 00 
  8004214a5d:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  8004214a5f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214a63:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a67:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214a6b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a6f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004214a73:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214a77:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214a7d:	48 29 c2             	sub    %rax,%rdx
  8004214a80:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214a84:	48 01 c2             	add    %rax,%rdx
  8004214a87:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a8b:	48 01 d0             	add    %rdx,%rax
  8004214a8e:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  8004214a92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214a99:	e9 04 05 00 00       	jmpq   8004214fa2 <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  8004214a9e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214aa1:	48 98                	cltq   
  8004214aa3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214aaa:	ff 
  8004214aab:	8b 00                	mov    (%rax),%eax
  8004214aad:	89 c2                	mov    %eax,%edx
  8004214aaf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214ab3:	48 01 d0             	add    %rdx,%rax
  8004214ab6:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004214aba:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214ac1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214ac6:	48 85 c0             	test   %rax,%rax
  8004214ac9:	74 35                	je     8004214b00 <read_section_headers+0x281>
  8004214acb:	48 b9 c6 9d 21 04 80 	movabs $0x8004219dc6,%rcx
  8004214ad2:	00 00 00 
  8004214ad5:	48 ba df 9d 21 04 80 	movabs $0x8004219ddf,%rdx
  8004214adc:	00 00 00 
  8004214adf:	be 87 00 00 00       	mov    $0x87,%esi
  8004214ae4:	48 bf f4 9d 21 04 80 	movabs $0x8004219df4,%rdi
  8004214aeb:	00 00 00 
  8004214aee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214af3:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004214afa:	00 00 00 
  8004214afd:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  8004214b00:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214b07:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004214b0b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214b0f:	48 be 8b 9d 21 04 80 	movabs $0x8004219d8b,%rsi
  8004214b16:	00 00 00 
  8004214b19:	48 89 c7             	mov    %rax,%rdi
  8004214b1c:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214b23:	00 00 00 
  8004214b26:	ff d0                	callq  *%rax
  8004214b28:	85 c0                	test   %eax,%eax
  8004214b2a:	0f 85 d8 00 00 00    	jne    8004214c08 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214b30:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b33:	48 98                	cltq   
  8004214b35:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b3c:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214b3d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b41:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b44:	48 98                	cltq   
  8004214b46:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b4d:	ff 
  8004214b4e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214b52:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214b59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b5d:	48 01 c8             	add    %rcx,%rax
  8004214b60:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214b67:	48 89 c7             	mov    %rax,%rdi
  8004214b6a:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  8004214b71:	00 00 00 
  8004214b74:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214b76:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b79:	48 98                	cltq   
  8004214b7b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b82:	ff 
  8004214b83:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214b87:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b8a:	48 98                	cltq   
  8004214b8c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b93:	ff 
  8004214b94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214b98:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004214b9c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214ba0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214ba6:	48 29 c2             	sub    %rax,%rdx
  8004214ba9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214bad:	48 01 c2             	add    %rax,%rdx
  8004214bb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214bb4:	48 01 c2             	add    %rax,%rdx
  8004214bb7:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214bbe:	00 00 00 
  8004214bc1:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004214bc5:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214bcc:	00 00 00 
  8004214bcf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214bd3:	48 89 c2             	mov    %rax,%rdx
  8004214bd6:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214bdd:	00 00 00 
  8004214be0:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004214be4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214be7:	48 98                	cltq   
  8004214be9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214bf0:	ff 
  8004214bf1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214bf5:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214bfc:	00 00 00 
  8004214bff:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214c03:	e9 96 03 00 00       	jmpq   8004214f9e <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004214c08:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214c0c:	48 be 97 9d 21 04 80 	movabs $0x8004219d97,%rsi
  8004214c13:	00 00 00 
  8004214c16:	48 89 c7             	mov    %rax,%rdi
  8004214c19:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214c20:	00 00 00 
  8004214c23:	ff d0                	callq  *%rax
  8004214c25:	85 c0                	test   %eax,%eax
  8004214c27:	0f 85 de 00 00 00    	jne    8004214d0b <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214c2d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c30:	48 98                	cltq   
  8004214c32:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c39:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214c3a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c3e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c41:	48 98                	cltq   
  8004214c43:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c4a:	ff 
  8004214c4b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214c4f:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214c56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214c5a:	48 01 c8             	add    %rcx,%rax
  8004214c5d:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214c64:	48 89 c7             	mov    %rax,%rdi
  8004214c67:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  8004214c6e:	00 00 00 
  8004214c71:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214c73:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c76:	48 98                	cltq   
  8004214c78:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c7f:	ff 
  8004214c80:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c84:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c87:	48 98                	cltq   
  8004214c89:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c90:	ff 
  8004214c91:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c95:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214c9c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214ca3:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214ca9:	48 29 c2             	sub    %rax,%rdx
  8004214cac:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214cb0:	48 01 c2             	add    %rax,%rdx
  8004214cb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214cb7:	48 01 c2             	add    %rax,%rdx
  8004214cba:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214cc1:	00 00 00 
  8004214cc4:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214cc8:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214ccf:	00 00 00 
  8004214cd2:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214cd6:	48 89 c2             	mov    %rax,%rdx
  8004214cd9:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214ce0:	00 00 00 
  8004214ce3:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214ce7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cea:	48 98                	cltq   
  8004214cec:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214cf3:	ff 
  8004214cf4:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214cf8:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214cff:	00 00 00 
  8004214d02:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214d06:	e9 93 02 00 00       	jmpq   8004214f9e <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004214d0b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214d0f:	48 be af 9d 21 04 80 	movabs $0x8004219daf,%rsi
  8004214d16:	00 00 00 
  8004214d19:	48 89 c7             	mov    %rax,%rdi
  8004214d1c:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214d23:	00 00 00 
  8004214d26:	ff d0                	callq  *%rax
  8004214d28:	85 c0                	test   %eax,%eax
  8004214d2a:	0f 85 de 00 00 00    	jne    8004214e0e <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214d30:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d33:	48 98                	cltq   
  8004214d35:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d3c:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214d3d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d41:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d44:	48 98                	cltq   
  8004214d46:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d4d:	ff 
  8004214d4e:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214d52:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214d59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d5d:	48 01 c8             	add    %rcx,%rax
  8004214d60:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214d67:	48 89 c7             	mov    %rax,%rdi
  8004214d6a:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  8004214d71:	00 00 00 
  8004214d74:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214d76:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d79:	48 98                	cltq   
  8004214d7b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d82:	ff 
  8004214d83:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214d87:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214d8a:	48 98                	cltq   
  8004214d8c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214d93:	ff 
  8004214d94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d98:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004214d9f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004214da6:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214dac:	48 29 c2             	sub    %rax,%rdx
  8004214daf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214db3:	48 01 c2             	add    %rax,%rdx
  8004214db6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214dba:	48 01 c2             	add    %rax,%rdx
  8004214dbd:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214dc4:	00 00 00 
  8004214dc7:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214dcb:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214dd2:	00 00 00 
  8004214dd5:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214dd9:	48 89 c2             	mov    %rax,%rdx
  8004214ddc:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214de3:	00 00 00 
  8004214de6:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214dea:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ded:	48 98                	cltq   
  8004214def:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214df6:	ff 
  8004214df7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214dfb:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214e02:	00 00 00 
  8004214e05:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214e09:	e9 90 01 00 00       	jmpq   8004214f9e <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004214e0e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e12:	48 be a5 9d 21 04 80 	movabs $0x8004219da5,%rsi
  8004214e19:	00 00 00 
  8004214e1c:	48 89 c7             	mov    %rax,%rdi
  8004214e1f:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214e26:	00 00 00 
  8004214e29:	ff d0                	callq  *%rax
  8004214e2b:	85 c0                	test   %eax,%eax
  8004214e2d:	75 65                	jne    8004214e94 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004214e2f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e32:	48 98                	cltq   
  8004214e34:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e3b:	ff 
  8004214e3c:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214e40:	48 89 c2             	mov    %rax,%rdx
  8004214e43:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214e4a:	00 00 00 
  8004214e4d:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004214e51:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214e58:	00 00 00 
  8004214e5b:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004214e5f:	48 89 c2             	mov    %rax,%rdx
  8004214e62:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214e69:	00 00 00 
  8004214e6c:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004214e70:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214e73:	48 98                	cltq   
  8004214e75:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214e7c:	ff 
  8004214e7d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214e81:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214e88:	00 00 00 
  8004214e8b:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214e8f:	e9 0a 01 00 00       	jmpq   8004214f9e <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004214e94:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214e98:	48 be bb 9d 21 04 80 	movabs $0x8004219dbb,%rsi
  8004214e9f:	00 00 00 
  8004214ea2:	48 89 c7             	mov    %rax,%rdi
  8004214ea5:	48 b8 19 ed 20 04 80 	movabs $0x800420ed19,%rax
  8004214eac:	00 00 00 
  8004214eaf:	ff d0                	callq  *%rax
  8004214eb1:	85 c0                	test   %eax,%eax
  8004214eb3:	0f 85 e5 00 00 00    	jne    8004214f9e <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214eb9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ebc:	48 98                	cltq   
  8004214ebe:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ec5:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214ec6:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214eca:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ecd:	48 98                	cltq   
  8004214ecf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ed6:	ff 
  8004214ed7:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214edb:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004214ee2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214ee6:	48 01 c8             	add    %rcx,%rax
  8004214ee9:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214ef0:	48 89 c7             	mov    %rax,%rdi
  8004214ef3:	48 b8 be 4f 21 04 80 	movabs $0x8004214fbe,%rax
  8004214efa:	00 00 00 
  8004214efd:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214eff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214f02:	48 98                	cltq   
  8004214f04:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214f0b:	ff 
  8004214f0c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214f10:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214f13:	48 98                	cltq   
  8004214f15:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214f1c:	ff 
  8004214f1d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f21:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004214f28:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214f2f:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214f35:	48 29 c2             	sub    %rax,%rdx
  8004214f38:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214f3c:	48 01 c2             	add    %rax,%rdx
  8004214f3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214f43:	48 01 c2             	add    %rax,%rdx
  8004214f46:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214f4d:	00 00 00 
  8004214f50:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004214f57:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214f5e:	00 00 00 
  8004214f61:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004214f68:	48 89 c2             	mov    %rax,%rdx
  8004214f6b:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214f72:	00 00 00 
  8004214f75:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004214f7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214f7f:	48 98                	cltq   
  8004214f81:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214f88:	ff 
  8004214f89:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214f8d:	48 b8 c0 b8 22 04 80 	movabs $0x800422b8c0,%rax
  8004214f94:	00 00 00 
  8004214f97:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  8004214f9e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214fa2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214fa5:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214fa8:	0f 8c f0 fa ff ff    	jl     8004214a9e <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004214fae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214fb2:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214fb9:	48 01 d0             	add    %rdx,%rax
}
  8004214fbc:	c9                   	leaveq 
  8004214fbd:	c3                   	retq   

0000008004214fbe <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004214fbe:	55                   	push   %rbp
  8004214fbf:	48 89 e5             	mov    %rsp,%rbp
  8004214fc2:	48 83 ec 30          	sub    $0x30,%rsp
  8004214fc6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214fca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214fce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214fd2:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214fd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214fda:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004214fde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214fe2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214fe6:	48 01 d0             	add    %rdx,%rax
  8004214fe9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004214fed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ff1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214ff6:	48 85 c0             	test   %rax,%rax
  8004214ff9:	74 35                	je     8004215030 <readseg+0x72>
  8004214ffb:	48 b9 02 9e 21 04 80 	movabs $0x8004219e02,%rcx
  8004215002:	00 00 00 
  8004215005:	48 ba df 9d 21 04 80 	movabs $0x8004219ddf,%rdx
  800421500c:	00 00 00 
  800421500f:	be c1 00 00 00       	mov    $0xc1,%esi
  8004215014:	48 bf f4 9d 21 04 80 	movabs $0x8004219df4,%rdi
  800421501b:	00 00 00 
  800421501e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215023:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421502a:	00 00 00 
  800421502d:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215030:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215037:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215038:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421503c:	48 c1 e8 09          	shr    $0x9,%rax
  8004215040:	48 83 c0 01          	add    $0x1,%rax
  8004215044:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215048:	eb 3c                	jmp    8004215086 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  800421504a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421504e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215052:	48 89 d6             	mov    %rdx,%rsi
  8004215055:	48 89 c7             	mov    %rax,%rdi
  8004215058:	48 b8 4e 51 21 04 80 	movabs $0x800421514e,%rax
  800421505f:	00 00 00 
  8004215062:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215064:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  800421506b:	00 
		*kvoffset += SECTSIZE;
  800421506c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215070:	48 8b 00             	mov    (%rax),%rax
  8004215073:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  800421507a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421507e:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215081:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215086:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421508a:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421508e:	72 ba                	jb     800421504a <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215090:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215094:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215099:	48 89 c2             	mov    %rax,%rdx
  800421509c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042150a0:	48 01 d0             	add    %rdx,%rax
  80042150a3:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  80042150a9:	76 2f                	jbe    80042150da <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  80042150ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150af:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042150b3:	48 89 d6             	mov    %rdx,%rsi
  80042150b6:	48 89 c7             	mov    %rax,%rdi
  80042150b9:	48 b8 4e 51 21 04 80 	movabs $0x800421514e,%rax
  80042150c0:	00 00 00 
  80042150c3:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  80042150c5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150c9:	48 8b 00             	mov    (%rax),%rax
  80042150cc:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  80042150d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150d7:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  80042150da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042150de:	48 8b 00             	mov    (%rax),%rax
  80042150e1:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042150e6:	48 85 c0             	test   %rax,%rax
  80042150e9:	74 35                	je     8004215120 <readseg+0x162>
  80042150eb:	48 b9 15 9e 21 04 80 	movabs $0x8004219e15,%rcx
  80042150f2:	00 00 00 
  80042150f5:	48 ba df 9d 21 04 80 	movabs $0x8004219ddf,%rdx
  80042150fc:	00 00 00 
  80042150ff:	be d7 00 00 00       	mov    $0xd7,%esi
  8004215104:	48 bf f4 9d 21 04 80 	movabs $0x8004219df4,%rdi
  800421510b:	00 00 00 
  800421510e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215113:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421511a:	00 00 00 
  800421511d:	41 ff d0             	callq  *%r8
}
  8004215120:	c9                   	leaveq 
  8004215121:	c3                   	retq   

0000008004215122 <waitdisk>:

void
waitdisk(void)
{
  8004215122:	55                   	push   %rbp
  8004215123:	48 89 e5             	mov    %rsp,%rbp
  8004215126:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  800421512a:	90                   	nop
  800421512b:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215132:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215135:	89 c2                	mov    %eax,%edx
  8004215137:	ec                   	in     (%dx),%al
  8004215138:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  800421513b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800421513f:	0f b6 c0             	movzbl %al,%eax
  8004215142:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215147:	83 f8 40             	cmp    $0x40,%eax
  800421514a:	75 df                	jne    800421512b <waitdisk+0x9>
		/* do nothing */;
}
  800421514c:	c9                   	leaveq 
  800421514d:	c3                   	retq   

000000800421514e <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  800421514e:	55                   	push   %rbp
  800421514f:	48 89 e5             	mov    %rsp,%rbp
  8004215152:	48 83 ec 60          	sub    $0x60,%rsp
  8004215156:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800421515a:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  800421515e:	48 b8 22 51 21 04 80 	movabs $0x8004215122,%rax
  8004215165:	00 00 00 
  8004215168:	ff d0                	callq  *%rax
  800421516a:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215171:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215175:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215179:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421517c:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  800421517d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215181:	0f b6 c0             	movzbl %al,%eax
  8004215184:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  800421518b:	88 45 f3             	mov    %al,-0xd(%rbp)
  800421518e:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215192:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215195:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215196:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421519a:	48 c1 e8 08          	shr    $0x8,%rax
  800421519e:	0f b6 c0             	movzbl %al,%eax
  80042151a1:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  80042151a8:	88 45 eb             	mov    %al,-0x15(%rbp)
  80042151ab:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042151af:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042151b2:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  80042151b3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042151b7:	48 c1 e8 10          	shr    $0x10,%rax
  80042151bb:	0f b6 c0             	movzbl %al,%eax
  80042151be:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  80042151c5:	88 45 e3             	mov    %al,-0x1d(%rbp)
  80042151c8:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042151cc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042151cf:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  80042151d0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042151d4:	48 c1 e8 18          	shr    $0x18,%rax
  80042151d8:	83 c8 e0             	or     $0xffffffe0,%eax
  80042151db:	0f b6 c0             	movzbl %al,%eax
  80042151de:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  80042151e5:	88 45 db             	mov    %al,-0x25(%rbp)
  80042151e8:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042151ec:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042151ef:	ee                   	out    %al,(%dx)
  80042151f0:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  80042151f7:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  80042151fb:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042151ff:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215202:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215203:	48 b8 22 51 21 04 80 	movabs $0x8004215122,%rax
  800421520a:	00 00 00 
  800421520d:	ff d0                	callq  *%rax
  800421520f:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215216:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421521a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800421521e:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

    static __inline void
insl(int port, void *addr, int cnt)
{
    __asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215225:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215228:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800421522c:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421522f:	48 89 ce             	mov    %rcx,%rsi
  8004215232:	48 89 f7             	mov    %rsi,%rdi
  8004215235:	89 c1                	mov    %eax,%ecx
  8004215237:	fc                   	cld    
  8004215238:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  800421523a:	89 c8                	mov    %ecx,%eax
  800421523c:	48 89 fe             	mov    %rdi,%rsi
  800421523f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215243:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215246:	c9                   	leaveq 
  8004215247:	c3                   	retq   

0000008004215248 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215248:	fa                   	cli    
	xorw    %ax, %ax
  8004215249:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  800421524b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421524d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421524f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215251:	0f 01 16             	lgdt   (%rsi)
  8004215254:	e0 70                	loopne 80042152c6 <start64+0x10>
	movl    %cr0, %eax
  8004215256:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215259:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  800421525d:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215260:	ea                   	(bad)  
  8004215261:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215265 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215265:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215269:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421526b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421526d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  800421526f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215273:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215275:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  8004215277:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif

	movl %eax,%cr4
  800421527c:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  800421527f:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421c346 <bootstack+0x1346>
	movl    %cr0, %eax
  8004215286:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215289:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  800421528c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  800421528f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215294:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215297:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  800421529c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  800421529e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  80042152a2:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  80042152a4:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  80042152a7:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  80042152ac:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  80042152af:	ea                   	(bad)  
  80042152b0:	6e                   	outsb  %ds:(%rsi),(%dx)
  80042152b1:	70 00                	jo     80042152b3 <start32+0x4e>
  80042152b3:	00 08                	add    %cl,(%rax)
	...

00000080042152b6 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  80042152b6:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  80042152ba:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  80042152bc:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  80042152be:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  80042152c0:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  80042152c4:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  80042152c6:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  80042152c8:	48 a1 58 57 37 04 80 	movabs 0x8004375758,%rax
  80042152cf:	00 00 00 
	movq    %rax,%rsp
  80042152d2:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  80042152d5:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  80042152dc:	48 b8 42 05 20 04 80 	movabs $0x8004200542,%rax
  80042152e3:	00 00 00 
	call    *%rax
  80042152e6:	ff d0                	callq  *%rax

00000080042152e8 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  80042152e8:	eb fe                	jmp    80042152e8 <spin>
  80042152ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000080042152f0 <gdt>:
	...
  80042152f8:	ff                   	(bad)  
  80042152f9:	ff 00                	incl   (%rax)
  80042152fb:	00 00                	add    %al,(%rax)
  80042152fd:	9a                   	(bad)  
  80042152fe:	af                   	scas   %es:(%rdi),%eax
  80042152ff:	00 ff                	add    %bh,%bh
  8004215301:	ff 00                	incl   (%rax)
  8004215303:	00 00                	add    %al,(%rax)
  8004215305:	92                   	xchg   %eax,%edx
  8004215306:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215308 <gdtdesc>:
  8004215308:	17                   	(bad)  
  8004215309:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421530f:	90                   	nop

0000008004215310 <gdt32>:
	...
  8004215318:	ff                   	(bad)  
  8004215319:	ff 00                	incl   (%rax)
  800421531b:	00 00                	add    %al,(%rax)
  800421531d:	9a                   	(bad)  
  800421531e:	cf                   	iret   
  800421531f:	00 ff                	add    %bh,%bh
  8004215321:	ff 00                	incl   (%rax)
  8004215323:	00 00                	add    %al,(%rax)
  8004215325:	92                   	xchg   %eax,%edx
  8004215326:	cf                   	iret   
	...

0000008004215328 <gdt32desc>:
  8004215328:	17                   	(bad)  
  8004215329:	00 c8                	add    %cl,%al
  800421532b:	70 00                	jo     800421532d <gdt32desc+0x5>
	...

000000800421532e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  800421532e:	90                   	nop

000000800421532f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  800421532f:	55                   	push   %rbp
  8004215330:	48 89 e5             	mov    %rsp,%rbp
  8004215333:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215337:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421533b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  800421533e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215345:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421534c:	eb 1a                	jmp    8004215368 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  800421534e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215351:	48 63 d0             	movslq %eax,%rdx
  8004215354:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215358:	48 01 d0             	add    %rdx,%rax
  800421535b:	0f b6 00             	movzbl (%rax),%eax
  800421535e:	0f b6 c0             	movzbl %al,%eax
  8004215361:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215364:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215368:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421536b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  800421536e:	7c de                	jl     800421534e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215370:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215373:	c9                   	leaveq 
  8004215374:	c3                   	retq   

0000008004215375 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215375:	55                   	push   %rbp
  8004215376:	48 89 e5             	mov    %rsp,%rbp
  8004215379:	48 83 ec 40          	sub    $0x40,%rsp
  800421537d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215381:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215384:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215388:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421538c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215390:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215394:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215397:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421539a:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042153a1:	00 00 00 
  80042153a4:	48 8b 00             	mov    (%rax),%rax
  80042153a7:	48 39 c2             	cmp    %rax,%rdx
  80042153aa:	72 32                	jb     80042153de <mpsearch1+0x69>
  80042153ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153b0:	48 89 c1             	mov    %rax,%rcx
  80042153b3:	48 ba 30 9e 21 04 80 	movabs $0x8004219e30,%rdx
  80042153ba:	00 00 00 
  80042153bd:	be 58 00 00 00       	mov    $0x58,%esi
  80042153c2:	48 bf 53 9e 21 04 80 	movabs $0x8004219e53,%rdi
  80042153c9:	00 00 00 
  80042153cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153d1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042153d8:	00 00 00 
  80042153db:	41 ff d0             	callq  *%r8
  80042153de:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042153e5:	00 00 00 
  80042153e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153ec:	48 01 d0             	add    %rdx,%rax
  80042153ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042153f3:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042153f6:	48 63 d0             	movslq %eax,%rdx
  80042153f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153fd:	48 01 d0             	add    %rdx,%rax
  8004215400:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215404:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215408:	48 c1 e8 0c          	shr    $0xc,%rax
  800421540c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421540f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215412:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004215419:	00 00 00 
  800421541c:	48 8b 00             	mov    (%rax),%rax
  800421541f:	48 39 c2             	cmp    %rax,%rdx
  8004215422:	72 32                	jb     8004215456 <mpsearch1+0xe1>
  8004215424:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215428:	48 89 c1             	mov    %rax,%rcx
  800421542b:	48 ba 30 9e 21 04 80 	movabs $0x8004219e30,%rdx
  8004215432:	00 00 00 
  8004215435:	be 58 00 00 00       	mov    $0x58,%esi
  800421543a:	48 bf 53 9e 21 04 80 	movabs $0x8004219e53,%rdi
  8004215441:	00 00 00 
  8004215444:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215449:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004215450:	00 00 00 
  8004215453:	41 ff d0             	callq  *%r8
  8004215456:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421545d:	00 00 00 
  8004215460:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215464:	48 01 d0             	add    %rdx,%rax
  8004215467:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  800421546b:	eb 4d                	jmp    80042154ba <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421546d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215471:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215476:	48 be 63 9e 21 04 80 	movabs $0x8004219e63,%rsi
  800421547d:	00 00 00 
  8004215480:	48 89 c7             	mov    %rax,%rdi
  8004215483:	48 b8 26 f0 20 04 80 	movabs $0x800420f026,%rax
  800421548a:	00 00 00 
  800421548d:	ff d0                	callq  *%rax
  800421548f:	85 c0                	test   %eax,%eax
  8004215491:	75 22                	jne    80042154b5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  8004215493:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215497:	be 10 00 00 00       	mov    $0x10,%esi
  800421549c:	48 89 c7             	mov    %rax,%rdi
  800421549f:	48 b8 2f 53 21 04 80 	movabs $0x800421532f,%rax
  80042154a6:	00 00 00 
  80042154a9:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042154ab:	84 c0                	test   %al,%al
  80042154ad:	75 06                	jne    80042154b5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  80042154af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154b3:	eb 14                	jmp    80042154c9 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  80042154b5:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  80042154ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154be:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042154c2:	72 a9                	jb     800421546d <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  80042154c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042154c9:	c9                   	leaveq 
  80042154ca:	c3                   	retq   

00000080042154cb <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  80042154cb:	55                   	push   %rbp
  80042154cc:	48 89 e5             	mov    %rsp,%rbp
  80042154cf:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  80042154d3:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042154da:	00 
  80042154db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154df:	48 c1 e8 0c          	shr    $0xc,%rax
  80042154e3:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042154e6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042154e9:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  80042154f0:	00 00 00 
  80042154f3:	48 8b 00             	mov    (%rax),%rax
  80042154f6:	48 39 c2             	cmp    %rax,%rdx
  80042154f9:	72 32                	jb     800421552d <mpsearch+0x62>
  80042154fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154ff:	48 89 c1             	mov    %rax,%rcx
  8004215502:	48 ba 30 9e 21 04 80 	movabs $0x8004219e30,%rdx
  8004215509:	00 00 00 
  800421550c:	be 70 00 00 00       	mov    $0x70,%esi
  8004215511:	48 bf 53 9e 21 04 80 	movabs $0x8004219e53,%rdi
  8004215518:	00 00 00 
  800421551b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215520:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004215527:	00 00 00 
  800421552a:	41 ff d0             	callq  *%r8
  800421552d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215534:	00 00 00 
  8004215537:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421553b:	48 01 d0             	add    %rdx,%rax
  800421553e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004215542:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215546:	48 83 c0 0e          	add    $0xe,%rax
  800421554a:	0f b7 00             	movzwl (%rax),%eax
  800421554d:	0f b7 c0             	movzwl %ax,%eax
  8004215550:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004215553:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004215557:	74 2c                	je     8004215585 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004215559:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  800421555d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215560:	be 00 04 00 00       	mov    $0x400,%esi
  8004215565:	48 89 c7             	mov    %rax,%rdi
  8004215568:	48 b8 75 53 21 04 80 	movabs $0x8004215375,%rax
  800421556f:	00 00 00 
  8004215572:	ff d0                	callq  *%rax
  8004215574:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004215578:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421557d:	74 49                	je     80042155c8 <mpsearch+0xfd>
			return mp;
  800421557f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215583:	eb 59                	jmp    80042155de <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004215585:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215589:	48 83 c0 13          	add    $0x13,%rax
  800421558d:	0f b7 00             	movzwl (%rax),%eax
  8004215590:	0f b7 c0             	movzwl %ax,%eax
  8004215593:	c1 e0 0a             	shl    $0xa,%eax
  8004215596:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004215599:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421559c:	2d 00 04 00 00       	sub    $0x400,%eax
  80042155a1:	89 c0                	mov    %eax,%eax
  80042155a3:	be 00 04 00 00       	mov    $0x400,%esi
  80042155a8:	48 89 c7             	mov    %rax,%rdi
  80042155ab:	48 b8 75 53 21 04 80 	movabs $0x8004215375,%rax
  80042155b2:	00 00 00 
  80042155b5:	ff d0                	callq  *%rax
  80042155b7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042155bb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042155c0:	74 06                	je     80042155c8 <mpsearch+0xfd>
			return mp;
  80042155c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042155c6:	eb 16                	jmp    80042155de <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  80042155c8:	be 00 00 01 00       	mov    $0x10000,%esi
  80042155cd:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  80042155d2:	48 b8 75 53 21 04 80 	movabs $0x8004215375,%rax
  80042155d9:	00 00 00 
  80042155dc:	ff d0                	callq  *%rax
}
  80042155de:	c9                   	leaveq 
  80042155df:	c3                   	retq   

00000080042155e0 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  80042155e0:	55                   	push   %rbp
  80042155e1:	48 89 e5             	mov    %rsp,%rbp
  80042155e4:	48 83 ec 30          	sub    $0x30,%rsp
  80042155e8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  80042155ec:	48 b8 cb 54 21 04 80 	movabs $0x80042154cb,%rax
  80042155f3:	00 00 00 
  80042155f6:	ff d0                	callq  *%rax
  80042155f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042155fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215601:	75 0a                	jne    800421560d <mpconfig+0x2d>
		return NULL;
  8004215603:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215608:	e9 f6 01 00 00       	jmpq   8004215803 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421560d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215611:	8b 40 04             	mov    0x4(%rax),%eax
  8004215614:	85 c0                	test   %eax,%eax
  8004215616:	74 0c                	je     8004215624 <mpconfig+0x44>
  8004215618:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421561c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004215620:	84 c0                	test   %al,%al
  8004215622:	74 25                	je     8004215649 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004215624:	48 bf 68 9e 21 04 80 	movabs $0x8004219e68,%rdi
  800421562b:	00 00 00 
  800421562e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215633:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800421563a:	00 00 00 
  800421563d:	ff d2                	callq  *%rdx
		return NULL;
  800421563f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215644:	e9 ba 01 00 00       	jmpq   8004215803 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004215649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421564d:	8b 40 04             	mov    0x4(%rax),%eax
  8004215650:	89 c0                	mov    %eax,%eax
  8004215652:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215656:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421565a:	48 c1 e8 0c          	shr    $0xc,%rax
  800421565e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215661:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215664:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  800421566b:	00 00 00 
  800421566e:	48 8b 00             	mov    (%rax),%rax
  8004215671:	48 39 c2             	cmp    %rax,%rdx
  8004215674:	72 32                	jb     80042156a8 <mpconfig+0xc8>
  8004215676:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421567a:	48 89 c1             	mov    %rax,%rcx
  800421567d:	48 ba 30 9e 21 04 80 	movabs $0x8004219e30,%rdx
  8004215684:	00 00 00 
  8004215687:	be 91 00 00 00       	mov    $0x91,%esi
  800421568c:	48 bf 53 9e 21 04 80 	movabs $0x8004219e53,%rdi
  8004215693:	00 00 00 
  8004215696:	b8 00 00 00 00       	mov    $0x0,%eax
  800421569b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042156a2:	00 00 00 
  80042156a5:	41 ff d0             	callq  *%r8
  80042156a8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042156af:	00 00 00 
  80042156b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042156b6:	48 01 d0             	add    %rdx,%rax
  80042156b9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042156bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156c1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042156c6:	48 be 95 9e 21 04 80 	movabs $0x8004219e95,%rsi
  80042156cd:	00 00 00 
  80042156d0:	48 89 c7             	mov    %rax,%rdi
  80042156d3:	48 b8 26 f0 20 04 80 	movabs $0x800420f026,%rax
  80042156da:	00 00 00 
  80042156dd:	ff d0                	callq  *%rax
  80042156df:	85 c0                	test   %eax,%eax
  80042156e1:	74 25                	je     8004215708 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  80042156e3:	48 bf a0 9e 21 04 80 	movabs $0x8004219ea0,%rdi
  80042156ea:	00 00 00 
  80042156ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156f2:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042156f9:	00 00 00 
  80042156fc:	ff d2                	callq  *%rdx
		return NULL;
  80042156fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215703:	e9 fb 00 00 00       	jmpq   8004215803 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004215708:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421570c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215710:	0f b7 d0             	movzwl %ax,%edx
  8004215713:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215717:	89 d6                	mov    %edx,%esi
  8004215719:	48 89 c7             	mov    %rax,%rdi
  800421571c:	48 b8 2f 53 21 04 80 	movabs $0x800421532f,%rax
  8004215723:	00 00 00 
  8004215726:	ff d0                	callq  *%rax
  8004215728:	84 c0                	test   %al,%al
  800421572a:	74 25                	je     8004215751 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421572c:	48 bf d8 9e 21 04 80 	movabs $0x8004219ed8,%rdi
  8004215733:	00 00 00 
  8004215736:	b8 00 00 00 00       	mov    $0x0,%eax
  800421573b:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215742:	00 00 00 
  8004215745:	ff d2                	callq  *%rdx
		return NULL;
  8004215747:	b8 00 00 00 00       	mov    $0x0,%eax
  800421574c:	e9 b2 00 00 00       	jmpq   8004215803 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004215751:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215755:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215759:	3c 01                	cmp    $0x1,%al
  800421575b:	74 3b                	je     8004215798 <mpconfig+0x1b8>
  800421575d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215761:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215765:	3c 04                	cmp    $0x4,%al
  8004215767:	74 2f                	je     8004215798 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004215769:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421576d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004215771:	0f b6 c0             	movzbl %al,%eax
  8004215774:	89 c6                	mov    %eax,%esi
  8004215776:	48 bf 00 9f 21 04 80 	movabs $0x8004219f00,%rdi
  800421577d:	00 00 00 
  8004215780:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215785:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  800421578c:	00 00 00 
  800421578f:	ff d2                	callq  *%rdx
		return NULL;
  8004215791:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215796:	eb 6b                	jmp    8004215803 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004215798:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421579c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042157a0:	0f b7 c0             	movzwl %ax,%eax
  80042157a3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042157a7:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042157ab:	0f b7 ca             	movzwl %dx,%ecx
  80042157ae:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042157b2:	48 01 ca             	add    %rcx,%rdx
  80042157b5:	89 c6                	mov    %eax,%esi
  80042157b7:	48 89 d7             	mov    %rdx,%rdi
  80042157ba:	48 b8 2f 53 21 04 80 	movabs $0x800421532f,%rax
  80042157c1:	00 00 00 
  80042157c4:	ff d0                	callq  *%rax
  80042157c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042157ca:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042157ce:	38 d0                	cmp    %dl,%al
  80042157d0:	74 22                	je     80042157f4 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  80042157d2:	48 bf 20 9f 21 04 80 	movabs $0x8004219f20,%rdi
  80042157d9:	00 00 00 
  80042157dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042157e1:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  80042157e8:	00 00 00 
  80042157eb:	ff d2                	callq  *%rdx
		return NULL;
  80042157ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042157f2:	eb 0f                	jmp    8004215803 <mpconfig+0x223>
	}
	*pmp = mp;
  80042157f4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157f8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042157fc:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  80042157ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004215803:	c9                   	leaveq 
  8004215804:	c3                   	retq   

0000008004215805 <mp_init>:

void
mp_init(void)
{
  8004215805:	55                   	push   %rbp
  8004215806:	48 89 e5             	mov    %rsp,%rbp
  8004215809:	53                   	push   %rbx
  800421580a:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421580e:	48 b8 40 72 37 04 80 	movabs $0x8004377240,%rax
  8004215815:	00 00 00 
  8004215818:	48 bb 20 70 37 04 80 	movabs $0x8004377020,%rbx
  800421581f:	00 00 00 
  8004215822:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004215825:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004215829:	48 89 c7             	mov    %rax,%rdi
  800421582c:	48 b8 e0 55 21 04 80 	movabs $0x80042155e0,%rax
  8004215833:	00 00 00 
  8004215836:	ff d0                	callq  *%rax
  8004215838:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421583c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215841:	75 05                	jne    8004215848 <mp_init+0x43>
		return;
  8004215843:	e9 d2 03 00 00       	jmpq   8004215c1a <mp_init+0x415>
	ismp = 1;
  8004215848:	48 b8 00 70 37 04 80 	movabs $0x8004377000,%rax
  800421584f:	00 00 00 
  8004215852:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004215858:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421585c:	8b 40 24             	mov    0x24(%rax),%eax
  800421585f:	89 c2                	mov    %eax,%edx
  8004215861:	48 b8 00 80 3b 04 80 	movabs $0x80043b8000,%rax
  8004215868:	00 00 00 
  800421586b:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421586e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215872:	48 83 c0 2c          	add    $0x2c,%rax
  8004215876:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421587a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004215881:	e9 17 02 00 00       	jmpq   8004215a9d <mp_init+0x298>
		switch (*p) {
  8004215886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421588a:	0f b6 00             	movzbl (%rax),%eax
  800421588d:	0f b6 c0             	movzbl %al,%eax
  8004215890:	85 c0                	test   %eax,%eax
  8004215892:	74 16                	je     80042158aa <mp_init+0xa5>
  8004215894:	85 c0                	test   %eax,%eax
  8004215896:	0f 88 b8 01 00 00    	js     8004215a54 <mp_init+0x24f>
  800421589c:	83 f8 04             	cmp    $0x4,%eax
  800421589f:	0f 8f af 01 00 00    	jg     8004215a54 <mp_init+0x24f>
  80042158a5:	e9 a3 01 00 00       	jmpq   8004215a4d <mp_init+0x248>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042158aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042158ae:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042158b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042158b6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042158ba:	0f b6 c0             	movzbl %al,%eax
  80042158bd:	83 e0 02             	and    $0x2,%eax
  80042158c0:	85 c0                	test   %eax,%eax
  80042158c2:	74 51                	je     8004215915 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  80042158c4:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  80042158cb:	00 00 00 
  80042158ce:	8b 00                	mov    (%rax),%eax
  80042158d0:	48 98                	cltq   
  80042158d2:	48 c1 e0 03          	shl    $0x3,%rax
  80042158d6:	48 89 c2             	mov    %rax,%rdx
  80042158d9:	48 c1 e2 04          	shl    $0x4,%rdx
  80042158dd:	48 01 d0             	add    %rdx,%rax
  80042158e0:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  80042158e7:	00 00 00 
  80042158ea:	48 01 c2             	add    %rax,%rdx
  80042158ed:	48 b8 40 72 37 04 80 	movabs $0x8004377240,%rax
  80042158f4:	00 00 00 
  80042158f7:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  80042158fa:	48 bf 4d 9f 21 04 80 	movabs $0x8004219f4d,%rdi
  8004215901:	00 00 00 
  8004215904:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215909:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215910:	00 00 00 
  8004215913:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004215915:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  800421591c:	00 00 00 
  800421591f:	8b 00                	mov    (%rax),%eax
  8004215921:	83 f8 03             	cmp    $0x3,%eax
  8004215924:	0f 8f f4 00 00 00    	jg     8004215a1e <mp_init+0x219>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421592a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421592e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004215932:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215936:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421593a:	0f b6 f0             	movzbl %al,%esi
  800421593d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215941:	8b 78 08             	mov    0x8(%rax),%edi
  8004215944:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215948:	4c 8d 50 04          	lea    0x4(%rax),%r10
  800421594c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215950:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004215954:	0f b6 c8             	movzbl %al,%ecx
  8004215957:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421595b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421595f:	0f b6 d0             	movzbl %al,%edx
  8004215962:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215966:	0f b6 00             	movzbl (%rax),%eax
  8004215969:	0f b6 c0             	movzbl %al,%eax
  800421596c:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004215971:	89 34 24             	mov    %esi,(%rsp)
  8004215974:	41 89 f9             	mov    %edi,%r9d
  8004215977:	4d 89 d0             	mov    %r10,%r8
  800421597a:	89 c6                	mov    %eax,%esi
  800421597c:	48 bf 60 9f 21 04 80 	movabs $0x8004219f60,%rdi
  8004215983:	00 00 00 
  8004215986:	b8 00 00 00 00       	mov    $0x0,%eax
  800421598b:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  8004215992:	00 00 00 
  8004215995:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  8004215998:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421599c:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042159a0:	0f b6 c0             	movzbl %al,%eax
  80042159a3:	83 e0 01             	and    $0x1,%eax
  80042159a6:	85 c0                	test   %eax,%eax
  80042159a8:	74 57                	je     8004215a01 <mp_init+0x1fc>
					cpus[ncpu].cpu_id = ncpu;
  80042159aa:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  80042159b1:	00 00 00 
  80042159b4:	8b 30                	mov    (%rax),%esi
  80042159b6:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  80042159bd:	00 00 00 
  80042159c0:	8b 00                	mov    (%rax),%eax
  80042159c2:	89 c2                	mov    %eax,%edx
  80042159c4:	48 b9 20 70 37 04 80 	movabs $0x8004377020,%rcx
  80042159cb:	00 00 00 
  80042159ce:	48 63 c6             	movslq %esi,%rax
  80042159d1:	48 c1 e0 03          	shl    $0x3,%rax
  80042159d5:	48 89 c6             	mov    %rax,%rsi
  80042159d8:	48 c1 e6 04          	shl    $0x4,%rsi
  80042159dc:	48 01 f0             	add    %rsi,%rax
  80042159df:	48 01 c8             	add    %rcx,%rax
  80042159e2:	88 10                	mov    %dl,(%rax)
					ncpu++;
  80042159e4:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  80042159eb:	00 00 00 
  80042159ee:	8b 00                	mov    (%rax),%eax
  80042159f0:	8d 50 01             	lea    0x1(%rax),%edx
  80042159f3:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  80042159fa:	00 00 00 
  80042159fd:	89 10                	mov    %edx,(%rax)
  80042159ff:	eb 45                	jmp    8004215a46 <mp_init+0x241>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004215a01:	48 bf b0 9f 21 04 80 	movabs $0x8004219fb0,%rdi
  8004215a08:	00 00 00 
  8004215a0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a10:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215a17:	00 00 00 
  8004215a1a:	ff d2                	callq  *%rdx
  8004215a1c:	eb 28                	jmp    8004215a46 <mp_init+0x241>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  8004215a1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215a22:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004215a26:	0f b6 c0             	movzbl %al,%eax
  8004215a29:	89 c6                	mov    %eax,%esi
  8004215a2b:	48 bf e0 9f 21 04 80 	movabs $0x8004219fe0,%rdi
  8004215a32:	00 00 00 
  8004215a35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a3a:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215a41:	00 00 00 
  8004215a44:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004215a46:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004215a4b:	eb 4c                	jmp    8004215a99 <mp_init+0x294>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  8004215a4d:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004215a52:	eb 45                	jmp    8004215a99 <mp_init+0x294>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004215a54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a58:	0f b6 00             	movzbl (%rax),%eax
  8004215a5b:	0f b6 c0             	movzbl %al,%eax
  8004215a5e:	89 c6                	mov    %eax,%esi
  8004215a60:	48 bf 08 a0 21 04 80 	movabs $0x800421a008,%rdi
  8004215a67:	00 00 00 
  8004215a6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a6f:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215a76:	00 00 00 
  8004215a79:	ff d2                	callq  *%rdx
			ismp = 0;
  8004215a7b:	48 b8 00 70 37 04 80 	movabs $0x8004377000,%rax
  8004215a82:	00 00 00 
  8004215a85:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004215a8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215a8f:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215a93:	0f b7 c0             	movzwl %ax,%eax
  8004215a96:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004215a99:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004215a9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215aa1:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215aa5:	0f b7 c0             	movzwl %ax,%eax
  8004215aa8:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215aab:	0f 87 d5 fd ff ff    	ja     8004215886 <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004215ab1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  8004215ab8:	eb 53                	jmp    8004215b0d <mp_init+0x308>
		cpus[i].is_vmx_root = false;
  8004215aba:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004215ac1:	00 00 00 
  8004215ac4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215ac7:	48 c1 e0 03          	shl    $0x3,%rax
  8004215acb:	48 89 c1             	mov    %rax,%rcx
  8004215ace:	48 c1 e1 04          	shl    $0x4,%rcx
  8004215ad2:	48 01 c8             	add    %rcx,%rax
  8004215ad5:	48 01 d0             	add    %rdx,%rax
  8004215ad8:	48 83 c0 70          	add    $0x70,%rax
  8004215adc:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004215ae0:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004215ae7:	00 00 00 
  8004215aea:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215aed:	48 c1 e0 03          	shl    $0x3,%rax
  8004215af1:	48 89 c1             	mov    %rax,%rcx
  8004215af4:	48 c1 e1 04          	shl    $0x4,%rcx
  8004215af8:	48 01 c8             	add    %rcx,%rax
  8004215afb:	48 01 d0             	add    %rdx,%rax
  8004215afe:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004215b02:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004215b09:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8004215b0d:	83 7d e4 03          	cmpl   $0x3,-0x1c(%rbp)
  8004215b11:	76 a7                	jbe    8004215aba <mp_init+0x2b5>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004215b13:	48 b8 40 72 37 04 80 	movabs $0x8004377240,%rax
  8004215b1a:	00 00 00 
  8004215b1d:	48 8b 00             	mov    (%rax),%rax
  8004215b20:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004215b27:	48 b8 00 70 37 04 80 	movabs $0x8004377000,%rax
  8004215b2e:	00 00 00 
  8004215b31:	8b 00                	mov    (%rax),%eax
  8004215b33:	85 c0                	test   %eax,%eax
  8004215b35:	75 41                	jne    8004215b78 <mp_init+0x373>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004215b37:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  8004215b3e:	00 00 00 
  8004215b41:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004215b47:	48 b8 00 80 3b 04 80 	movabs $0x80043b8000,%rax
  8004215b4e:	00 00 00 
  8004215b51:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004215b58:	48 bf 28 a0 21 04 80 	movabs $0x800421a028,%rdi
  8004215b5f:	00 00 00 
  8004215b62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b67:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215b6e:	00 00 00 
  8004215b71:	ff d2                	callq  *%rdx
		return;
  8004215b73:	e9 a2 00 00 00       	jmpq   8004215c1a <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004215b78:	48 b8 48 72 37 04 80 	movabs $0x8004377248,%rax
  8004215b7f:	00 00 00 
  8004215b82:	8b 10                	mov    (%rax),%edx
  8004215b84:	48 b8 40 72 37 04 80 	movabs $0x8004377240,%rax
  8004215b8b:	00 00 00 
  8004215b8e:	48 8b 00             	mov    (%rax),%rax
  8004215b91:	0f b6 00             	movzbl (%rax),%eax
  8004215b94:	0f b6 c0             	movzbl %al,%eax
  8004215b97:	89 c6                	mov    %eax,%esi
  8004215b99:	48 bf 54 a0 21 04 80 	movabs $0x800421a054,%rdi
  8004215ba0:	00 00 00 
  8004215ba3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215ba8:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  8004215baf:	00 00 00 
  8004215bb2:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004215bb4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215bb8:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004215bbc:	84 c0                	test   %al,%al
  8004215bbe:	74 5a                	je     8004215c1a <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004215bc0:	48 bf 78 a0 21 04 80 	movabs $0x800421a078,%rdi
  8004215bc7:	00 00 00 
  8004215bca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215bcf:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004215bd6:	00 00 00 
  8004215bd9:	ff d2                	callq  *%rdx
  8004215bdb:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004215be2:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215be6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004215bea:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215bed:	ee                   	out    %al,(%dx)
  8004215bee:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215bf5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215bf8:	89 c2                	mov    %eax,%edx
  8004215bfa:	ec                   	in     (%dx),%al
  8004215bfb:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  8004215bfe:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004215c02:	83 c8 01             	or     $0x1,%eax
  8004215c05:	0f b6 c0             	movzbl %al,%eax
  8004215c08:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004215c0f:	88 45 bb             	mov    %al,-0x45(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215c12:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004215c16:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004215c19:	ee                   	out    %al,(%dx)
	}
}
  8004215c1a:	48 83 c4 58          	add    $0x58,%rsp
  8004215c1e:	5b                   	pop    %rbx
  8004215c1f:	5d                   	pop    %rbp
  8004215c20:	c3                   	retq   

0000008004215c21 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004215c21:	55                   	push   %rbp
  8004215c22:	48 89 e5             	mov    %rsp,%rbp
  8004215c25:	48 83 ec 08          	sub    $0x8,%rsp
  8004215c29:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004215c2c:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004215c2f:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215c36:	00 00 00 
  8004215c39:	48 8b 00             	mov    (%rax),%rax
  8004215c3c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215c3f:	48 63 d2             	movslq %edx,%rdx
  8004215c42:	48 c1 e2 02          	shl    $0x2,%rdx
  8004215c46:	48 01 c2             	add    %rax,%rdx
  8004215c49:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004215c4c:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004215c4e:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215c55:	00 00 00 
  8004215c58:	48 8b 00             	mov    (%rax),%rax
  8004215c5b:	48 83 c0 20          	add    $0x20,%rax
  8004215c5f:	8b 00                	mov    (%rax),%eax
}
  8004215c61:	c9                   	leaveq 
  8004215c62:	c3                   	retq   

0000008004215c63 <lapic_init>:

void
lapic_init(void)
{
  8004215c63:	55                   	push   %rbp
  8004215c64:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004215c67:	48 b8 00 80 3b 04 80 	movabs $0x80043b8000,%rax
  8004215c6e:	00 00 00 
  8004215c71:	48 8b 00             	mov    (%rax),%rax
  8004215c74:	48 85 c0             	test   %rax,%rax
  8004215c77:	75 05                	jne    8004215c7e <lapic_init+0x1b>
		return;
  8004215c79:	e9 da 01 00 00       	jmpq   8004215e58 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004215c7e:	48 b8 00 80 3b 04 80 	movabs $0x80043b8000,%rax
  8004215c85:	00 00 00 
  8004215c88:	48 8b 00             	mov    (%rax),%rax
  8004215c8b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004215c90:	48 89 c7             	mov    %rax,%rdi
  8004215c93:	48 b8 77 45 20 04 80 	movabs $0x8004204577,%rax
  8004215c9a:	00 00 00 
  8004215c9d:	ff d0                	callq  *%rax
  8004215c9f:	48 ba 08 80 3b 04 80 	movabs $0x80043b8008,%rdx
  8004215ca6:	00 00 00 
  8004215ca9:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004215cac:	be 27 01 00 00       	mov    $0x127,%esi
  8004215cb1:	bf 3c 00 00 00       	mov    $0x3c,%edi
  8004215cb6:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215cbd:	00 00 00 
  8004215cc0:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004215cc2:	be 0b 00 00 00       	mov    $0xb,%esi
  8004215cc7:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004215ccc:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215cd3:	00 00 00 
  8004215cd6:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004215cd8:	be 20 00 02 00       	mov    $0x20020,%esi
  8004215cdd:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215ce2:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215ce9:	00 00 00 
  8004215cec:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004215cee:	be 80 96 98 00       	mov    $0x989680,%esi
  8004215cf3:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004215cf8:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215cff:	00 00 00 
  8004215d02:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004215d04:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004215d0b:	00 00 00 
  8004215d0e:	ff d0                	callq  *%rax
  8004215d10:	48 98                	cltq   
  8004215d12:	48 c1 e0 03          	shl    $0x3,%rax
  8004215d16:	48 89 c2             	mov    %rax,%rdx
  8004215d19:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d1d:	48 01 d0             	add    %rdx,%rax
  8004215d20:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004215d27:	00 00 00 
  8004215d2a:	48 01 c2             	add    %rax,%rdx
  8004215d2d:	48 b8 40 72 37 04 80 	movabs $0x8004377240,%rax
  8004215d34:	00 00 00 
  8004215d37:	48 8b 00             	mov    (%rax),%rax
  8004215d3a:	48 39 c2             	cmp    %rax,%rdx
  8004215d3d:	74 16                	je     8004215d55 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004215d3f:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215d44:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004215d49:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215d50:	00 00 00 
  8004215d53:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004215d55:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215d5a:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004215d5f:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215d66:	00 00 00 
  8004215d69:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004215d6b:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215d72:	00 00 00 
  8004215d75:	48 8b 00             	mov    (%rax),%rax
  8004215d78:	48 83 c0 30          	add    $0x30,%rax
  8004215d7c:	8b 00                	mov    (%rax),%eax
  8004215d7e:	c1 e8 10             	shr    $0x10,%eax
  8004215d81:	0f b6 c0             	movzbl %al,%eax
  8004215d84:	83 f8 03             	cmp    $0x3,%eax
  8004215d87:	76 16                	jbe    8004215d9f <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004215d89:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215d8e:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004215d93:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215d9a:	00 00 00 
  8004215d9d:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004215d9f:	be 33 00 00 00       	mov    $0x33,%esi
  8004215da4:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004215da9:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215db0:	00 00 00 
  8004215db3:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004215db5:	be 00 00 00 00       	mov    $0x0,%esi
  8004215dba:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215dbf:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215dc6:	00 00 00 
  8004215dc9:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004215dcb:	be 00 00 00 00       	mov    $0x0,%esi
  8004215dd0:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215dd5:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215ddc:	00 00 00 
  8004215ddf:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215de1:	be 00 00 00 00       	mov    $0x0,%esi
  8004215de6:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215deb:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215df2:	00 00 00 
  8004215df5:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004215df7:	be 00 00 00 00       	mov    $0x0,%esi
  8004215dfc:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215e01:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215e08:	00 00 00 
  8004215e0b:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215e0d:	be 00 85 08 00       	mov    $0x88500,%esi
  8004215e12:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215e17:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215e1e:	00 00 00 
  8004215e21:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004215e23:	90                   	nop
  8004215e24:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215e2b:	00 00 00 
  8004215e2e:	48 8b 00             	mov    (%rax),%rax
  8004215e31:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215e37:	8b 00                	mov    (%rax),%eax
  8004215e39:	25 00 10 00 00       	and    $0x1000,%eax
  8004215e3e:	85 c0                	test   %eax,%eax
  8004215e40:	75 e2                	jne    8004215e24 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004215e42:	be 00 00 00 00       	mov    $0x0,%esi
  8004215e47:	bf 20 00 00 00       	mov    $0x20,%edi
  8004215e4c:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215e53:	00 00 00 
  8004215e56:	ff d0                	callq  *%rax
}
  8004215e58:	5d                   	pop    %rbp
  8004215e59:	c3                   	retq   

0000008004215e5a <cpunum>:

int
cpunum(void)
{
  8004215e5a:	55                   	push   %rbp
  8004215e5b:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215e5e:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215e65:	00 00 00 
  8004215e68:	48 8b 00             	mov    (%rax),%rax
  8004215e6b:	48 85 c0             	test   %rax,%rax
  8004215e6e:	74 18                	je     8004215e88 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004215e70:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215e77:	00 00 00 
  8004215e7a:	48 8b 00             	mov    (%rax),%rax
  8004215e7d:	48 83 c0 20          	add    $0x20,%rax
  8004215e81:	8b 00                	mov    (%rax),%eax
  8004215e83:	c1 e8 18             	shr    $0x18,%eax
  8004215e86:	eb 05                	jmp    8004215e8d <cpunum+0x33>
	return 0;
  8004215e88:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215e8d:	5d                   	pop    %rbp
  8004215e8e:	c3                   	retq   

0000008004215e8f <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004215e8f:	55                   	push   %rbp
  8004215e90:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215e93:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  8004215e9a:	00 00 00 
  8004215e9d:	48 8b 00             	mov    (%rax),%rax
  8004215ea0:	48 85 c0             	test   %rax,%rax
  8004215ea3:	74 16                	je     8004215ebb <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004215ea5:	be 00 00 00 00       	mov    $0x0,%esi
  8004215eaa:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215eaf:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215eb6:	00 00 00 
  8004215eb9:	ff d0                	callq  *%rax
}
  8004215ebb:	5d                   	pop    %rbp
  8004215ebc:	c3                   	retq   

0000008004215ebd <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004215ebd:	55                   	push   %rbp
  8004215ebe:	48 89 e5             	mov    %rsp,%rbp
  8004215ec1:	48 83 ec 04          	sub    $0x4,%rsp
  8004215ec5:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004215ec8:	c9                   	leaveq 
  8004215ec9:	c3                   	retq   

0000008004215eca <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004215eca:	55                   	push   %rbp
  8004215ecb:	48 89 e5             	mov    %rsp,%rbp
  8004215ece:	48 83 ec 40          	sub    $0x40,%rsp
  8004215ed2:	89 f8                	mov    %edi,%eax
  8004215ed4:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004215ed7:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004215eda:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004215ee1:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004215ee5:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215ee9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215eec:	ee                   	out    %al,(%dx)
  8004215eed:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004215ef4:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004215ef8:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215efc:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215eff:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004215f00:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004215f07:	00 
  8004215f08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f0c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215f10:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215f13:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215f16:	48 b8 78 57 37 04 80 	movabs $0x8004375778,%rax
  8004215f1d:	00 00 00 
  8004215f20:	48 8b 00             	mov    (%rax),%rax
  8004215f23:	48 39 c2             	cmp    %rax,%rdx
  8004215f26:	72 32                	jb     8004215f5a <lapic_startap+0x90>
  8004215f28:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f2c:	48 89 c1             	mov    %rax,%rcx
  8004215f2f:	48 ba c0 a0 21 04 80 	movabs $0x800421a0c0,%rdx
  8004215f36:	00 00 00 
  8004215f39:	be 98 00 00 00       	mov    $0x98,%esi
  8004215f3e:	48 bf e3 a0 21 04 80 	movabs $0x800421a0e3,%rdi
  8004215f45:	00 00 00 
  8004215f48:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f4d:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004215f54:	00 00 00 
  8004215f57:	41 ff d0             	callq  *%r8
  8004215f5a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215f61:	00 00 00 
  8004215f64:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f68:	48 01 d0             	add    %rdx,%rax
  8004215f6b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004215f6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f73:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004215f78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f7c:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004215f80:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215f83:	c1 e8 04             	shr    $0x4,%eax
  8004215f86:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004215f89:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215f8d:	c1 e0 18             	shl    $0x18,%eax
  8004215f90:	89 c6                	mov    %eax,%esi
  8004215f92:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215f97:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215f9e:	00 00 00 
  8004215fa1:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004215fa3:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004215fa8:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215fad:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215fb4:	00 00 00 
  8004215fb7:	ff d0                	callq  *%rax
	microdelay(200);
  8004215fb9:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215fbe:	48 b8 bd 5e 21 04 80 	movabs $0x8004215ebd,%rax
  8004215fc5:	00 00 00 
  8004215fc8:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004215fca:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215fcf:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215fd4:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  8004215fdb:	00 00 00 
  8004215fde:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215fe0:	bf 64 00 00 00       	mov    $0x64,%edi
  8004215fe5:	48 b8 bd 5e 21 04 80 	movabs $0x8004215ebd,%rax
  8004215fec:	00 00 00 
  8004215fef:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215ff1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215ff8:	eb 4b                	jmp    8004216045 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004215ffa:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215ffe:	c1 e0 18             	shl    $0x18,%eax
  8004216001:	89 c6                	mov    %eax,%esi
  8004216003:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216008:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  800421600f:	00 00 00 
  8004216012:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004216014:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216017:	c1 e8 0c             	shr    $0xc,%eax
  800421601a:	80 cc 06             	or     $0x6,%ah
  800421601d:	89 c6                	mov    %eax,%esi
  800421601f:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216024:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  800421602b:	00 00 00 
  800421602e:	ff d0                	callq  *%rax
		microdelay(200);
  8004216030:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216035:	48 b8 bd 5e 21 04 80 	movabs $0x8004215ebd,%rax
  800421603c:	00 00 00 
  800421603f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216041:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216045:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216049:	7e af                	jle    8004215ffa <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  800421604b:	c9                   	leaveq 
  800421604c:	c3                   	retq   

000000800421604d <lapic_ipi>:

void
lapic_ipi(int vector)
{
  800421604d:	55                   	push   %rbp
  800421604e:	48 89 e5             	mov    %rsp,%rbp
  8004216051:	48 83 ec 08          	sub    $0x8,%rsp
  8004216055:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216058:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421605b:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004216060:	89 c6                	mov    %eax,%esi
  8004216062:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216067:	48 b8 21 5c 21 04 80 	movabs $0x8004215c21,%rax
  800421606e:	00 00 00 
  8004216071:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004216073:	90                   	nop
  8004216074:	48 b8 08 80 3b 04 80 	movabs $0x80043b8008,%rax
  800421607b:	00 00 00 
  800421607e:	48 8b 00             	mov    (%rax),%rax
  8004216081:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216087:	8b 00                	mov    (%rax),%eax
  8004216089:	25 00 10 00 00       	and    $0x1000,%eax
  800421608e:	85 c0                	test   %eax,%eax
  8004216090:	75 e2                	jne    8004216074 <lapic_ipi+0x27>
		;
}
  8004216092:	c9                   	leaveq 
  8004216093:	c3                   	retq   

0000008004216094 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004216094:	55                   	push   %rbp
  8004216095:	48 89 e5             	mov    %rsp,%rbp
  8004216098:	48 83 ec 1c          	sub    $0x1c,%rsp
  800421609c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042160a0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042160a3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042160a7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042160aa:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042160ae:	f0 87 02             	lock xchg %eax,(%rdx)
  80042160b1:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042160b4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042160b7:	c9                   	leaveq 
  80042160b8:	c3                   	retq   

00000080042160b9 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  80042160b9:	55                   	push   %rbp
  80042160ba:	48 89 e5             	mov    %rsp,%rbp
  80042160bd:	48 83 ec 28          	sub    $0x28,%rsp
  80042160c1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042160c5:	48 89 e8             	mov    %rbp,%rax
  80042160c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    return rbp;
  80042160cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  80042160d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  80042160d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042160db:	eb 45                	jmp    8004216122 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  80042160dd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042160e2:	74 44                	je     8004216128 <get_caller_pcs+0x6f>
  80042160e4:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042160eb:	00 00 00 
  80042160ee:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042160f2:	76 34                	jbe    8004216128 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  80042160f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042160f7:	48 98                	cltq   
  80042160f9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216100:	00 
  8004216101:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216105:	48 01 c2             	add    %rax,%rdx
  8004216108:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421610c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216110:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216117:	48 8b 00             	mov    (%rax),%rax
  800421611a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  800421611e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216122:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216126:	7e b5                	jle    80042160dd <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216128:	eb 1f                	jmp    8004216149 <get_caller_pcs+0x90>
		pcs[i] = 0;
  800421612a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421612d:	48 98                	cltq   
  800421612f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216136:	00 
  8004216137:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421613b:	48 01 d0             	add    %rdx,%rax
  800421613e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216145:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216149:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  800421614d:	7e db                	jle    800421612a <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  800421614f:	c9                   	leaveq 
  8004216150:	c3                   	retq   

0000008004216151 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216151:	55                   	push   %rbp
  8004216152:	48 89 e5             	mov    %rsp,%rbp
  8004216155:	53                   	push   %rbx
  8004216156:	48 83 ec 18          	sub    $0x18,%rsp
  800421615a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  800421615e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216162:	8b 00                	mov    (%rax),%eax
  8004216164:	85 c0                	test   %eax,%eax
  8004216166:	74 3d                	je     80042161a5 <holding+0x54>
  8004216168:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421616c:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216170:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004216177:	00 00 00 
  800421617a:	ff d0                	callq  *%rax
  800421617c:	48 98                	cltq   
  800421617e:	48 c1 e0 03          	shl    $0x3,%rax
  8004216182:	48 89 c2             	mov    %rax,%rdx
  8004216185:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216189:	48 01 d0             	add    %rdx,%rax
  800421618c:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004216193:	00 00 00 
  8004216196:	48 01 d0             	add    %rdx,%rax
  8004216199:	48 39 c3             	cmp    %rax,%rbx
  800421619c:	75 07                	jne    80042161a5 <holding+0x54>
  800421619e:	b8 01 00 00 00       	mov    $0x1,%eax
  80042161a3:	eb 05                	jmp    80042161aa <holding+0x59>
  80042161a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042161aa:	48 83 c4 18          	add    $0x18,%rsp
  80042161ae:	5b                   	pop    %rbx
  80042161af:	5d                   	pop    %rbp
  80042161b0:	c3                   	retq   

00000080042161b1 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  80042161b1:	55                   	push   %rbp
  80042161b2:	48 89 e5             	mov    %rsp,%rbp
  80042161b5:	48 83 ec 10          	sub    $0x10,%rsp
  80042161b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80042161bd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  80042161c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042161c5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  80042161cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042161cf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042161d3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  80042161d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042161db:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042161e2:	00 
#endif
}
  80042161e3:	c9                   	leaveq 
  80042161e4:	c3                   	retq   

00000080042161e5 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  80042161e5:	55                   	push   %rbp
  80042161e6:	48 89 e5             	mov    %rsp,%rbp
  80042161e9:	53                   	push   %rbx
  80042161ea:	48 83 ec 18          	sub    $0x18,%rsp
  80042161ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  80042161f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042161f6:	48 89 c7             	mov    %rax,%rdi
  80042161f9:	48 b8 51 61 21 04 80 	movabs $0x8004216151,%rax
  8004216200:	00 00 00 
  8004216203:	ff d0                	callq  *%rax
  8004216205:	85 c0                	test   %eax,%eax
  8004216207:	74 44                	je     800421624d <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421620d:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216211:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004216218:	00 00 00 
  800421621b:	ff d0                	callq  *%rax
  800421621d:	49 89 d8             	mov    %rbx,%r8
  8004216220:	89 c1                	mov    %eax,%ecx
  8004216222:	48 ba 00 a1 21 04 80 	movabs $0x800421a100,%rdx
  8004216229:	00 00 00 
  800421622c:	be 41 00 00 00       	mov    $0x41,%esi
  8004216231:	48 bf 2a a1 21 04 80 	movabs $0x800421a12a,%rdi
  8004216238:	00 00 00 
  800421623b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216240:	49 b9 08 06 20 04 80 	movabs $0x8004200608,%r9
  8004216247:	00 00 00 
  800421624a:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  800421624d:	eb 02                	jmp    8004216251 <spin_lock+0x6c>
		asm volatile ("pause");
  800421624f:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216255:	be 01 00 00 00       	mov    $0x1,%esi
  800421625a:	48 89 c7             	mov    %rax,%rdi
  800421625d:	48 b8 94 60 21 04 80 	movabs $0x8004216094,%rax
  8004216264:	00 00 00 
  8004216267:	ff d0                	callq  *%rax
  8004216269:	85 c0                	test   %eax,%eax
  800421626b:	75 e2                	jne    800421624f <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  800421626d:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004216274:	00 00 00 
  8004216277:	ff d0                	callq  *%rax
  8004216279:	48 98                	cltq   
  800421627b:	48 c1 e0 03          	shl    $0x3,%rax
  800421627f:	48 89 c2             	mov    %rax,%rdx
  8004216282:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216286:	48 01 d0             	add    %rdx,%rax
  8004216289:	48 ba 20 70 37 04 80 	movabs $0x8004377020,%rdx
  8004216290:	00 00 00 
  8004216293:	48 01 c2             	add    %rax,%rdx
  8004216296:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421629a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  800421629e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042162a2:	48 83 c0 18          	add    $0x18,%rax
  80042162a6:	48 89 c7             	mov    %rax,%rdi
  80042162a9:	48 b8 b9 60 21 04 80 	movabs $0x80042160b9,%rax
  80042162b0:	00 00 00 
  80042162b3:	ff d0                	callq  *%rax
#endif
}
  80042162b5:	48 83 c4 18          	add    $0x18,%rsp
  80042162b9:	5b                   	pop    %rbx
  80042162ba:	5d                   	pop    %rbp
  80042162bb:	c3                   	retq   

00000080042162bc <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  80042162bc:	55                   	push   %rbp
  80042162bd:	48 89 e5             	mov    %rsp,%rbp
  80042162c0:	41 54                	push   %r12
  80042162c2:	53                   	push   %rbx
  80042162c3:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  80042162ca:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  80042162d1:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042162d8:	48 89 c7             	mov    %rax,%rdi
  80042162db:	48 b8 51 61 21 04 80 	movabs $0x8004216151,%rax
  80042162e2:	00 00 00 
  80042162e5:	ff d0                	callq  *%rax
  80042162e7:	85 c0                	test   %eax,%eax
  80042162e9:	0f 85 d2 01 00 00    	jne    80042164c1 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  80042162ef:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042162f6:	48 8d 48 18          	lea    0x18(%rax),%rcx
  80042162fa:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216301:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216306:	48 89 ce             	mov    %rcx,%rsi
  8004216309:	48 89 c7             	mov    %rax,%rdi
  800421630c:	48 b8 db ee 20 04 80 	movabs $0x800420eedb,%rax
  8004216313:	00 00 00 
  8004216316:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216318:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421631f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216323:	48 85 c0             	test   %rax,%rax
  8004216326:	75 39                	jne    8004216361 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216328:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421632f:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216333:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  800421633a:	00 00 00 
  800421633d:	ff d0                	callq  *%rax
  800421633f:	48 89 da             	mov    %rbx,%rdx
  8004216342:	89 c6                	mov    %eax,%esi
  8004216344:	48 bf 40 a1 21 04 80 	movabs $0x800421a140,%rdi
  800421634b:	00 00 00 
  800421634e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216353:	48 b9 7f 97 20 04 80 	movabs $0x800420977f,%rcx
  800421635a:	00 00 00 
  800421635d:	ff d1                	callq  *%rcx
  800421635f:	eb 4d                	jmp    80042163ae <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216361:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216368:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421636c:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  800421636f:	44 0f b6 e0          	movzbl %al,%r12d
  8004216373:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421637a:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421637e:	48 b8 5a 5e 21 04 80 	movabs $0x8004215e5a,%rax
  8004216385:	00 00 00 
  8004216388:	ff d0                	callq  *%rax
  800421638a:	44 89 e1             	mov    %r12d,%ecx
  800421638d:	48 89 da             	mov    %rbx,%rdx
  8004216390:	89 c6                	mov    %eax,%esi
  8004216392:	48 bf 80 a1 21 04 80 	movabs $0x800421a180,%rdi
  8004216399:	00 00 00 
  800421639c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163a1:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  80042163a8:	00 00 00 
  80042163ab:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042163ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042163b5:	e9 c3 00 00 00       	jmpq   800421647d <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  80042163ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042163bd:	48 98                	cltq   
  80042163bf:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042163c6:	89 c0                	mov    %eax,%eax
  80042163c8:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  80042163cf:	48 89 d6             	mov    %rdx,%rsi
  80042163d2:	48 89 c7             	mov    %rax,%rdi
  80042163d5:	48 b8 7b da 20 04 80 	movabs $0x800420da7b,%rax
  80042163dc:	00 00 00 
  80042163df:	ff d0                	callq  *%rax
  80042163e1:	85 c0                	test   %eax,%eax
  80042163e3:	78 6b                	js     8004216450 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  80042163e5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042163e8:	48 98                	cltq   
  80042163ea:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  80042163f1:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  80042163f3:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  80042163fa:	48 29 c2             	sub    %rax,%rdx
  80042163fd:	49 89 d0             	mov    %rdx,%r8
  8004216400:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216407:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421640d:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216413:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800421641a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421641d:	48 98                	cltq   
  800421641f:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216426:	4c 89 04 24          	mov    %r8,(%rsp)
  800421642a:	49 89 f9             	mov    %rdi,%r9
  800421642d:	41 89 f0             	mov    %esi,%r8d
  8004216430:	89 c6                	mov    %eax,%esi
  8004216432:	48 bf b6 a1 21 04 80 	movabs $0x800421a1b6,%rdi
  8004216439:	00 00 00 
  800421643c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216441:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  8004216448:	00 00 00 
  800421644b:	41 ff d2             	callq  *%r10
  800421644e:	eb 29                	jmp    8004216479 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004216450:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216453:	48 98                	cltq   
  8004216455:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421645c:	89 c6                	mov    %eax,%esi
  800421645e:	48 bf cd a1 21 04 80 	movabs $0x800421a1cd,%rdi
  8004216465:	00 00 00 
  8004216468:	b8 00 00 00 00       	mov    $0x0,%eax
  800421646d:	48 ba 7f 97 20 04 80 	movabs $0x800420977f,%rdx
  8004216474:	00 00 00 
  8004216477:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216479:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800421647d:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004216481:	7f 14                	jg     8004216497 <spin_unlock+0x1db>
  8004216483:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216486:	48 98                	cltq   
  8004216488:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421648f:	85 c0                	test   %eax,%eax
  8004216491:	0f 85 23 ff ff ff    	jne    80042163ba <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004216497:	48 ba d5 a1 21 04 80 	movabs $0x800421a1d5,%rdx
  800421649e:	00 00 00 
  80042164a1:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042164a6:	48 bf 2a a1 21 04 80 	movabs $0x800421a12a,%rdi
  80042164ad:	00 00 00 
  80042164b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164b5:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  80042164bc:	00 00 00 
  80042164bf:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  80042164c1:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042164c8:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80042164cf:	00 
	lk->cpu = 0;
  80042164d0:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042164d7:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80042164de:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  80042164df:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042164e6:	be 00 00 00 00       	mov    $0x0,%esi
  80042164eb:	48 89 c7             	mov    %rax,%rdi
  80042164ee:	48 b8 94 60 21 04 80 	movabs $0x8004216094,%rax
  80042164f5:	00 00 00 
  80042164f8:	ff d0                	callq  *%rax
}
  80042164fa:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004216501:	5b                   	pop    %rbx
  8004216502:	41 5c                	pop    %r12
  8004216504:	5d                   	pop    %rbp
  8004216505:	c3                   	retq   

0000008004216506 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004216506:	55                   	push   %rbp
  8004216507:	48 89 e5             	mov    %rsp,%rbp
  800421650a:	48 83 ec 20          	sub    $0x20,%rsp
  800421650e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004216511:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004216514:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004216517:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  800421651a:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004216521:	76 35                	jbe    8004216558 <pci_conf1_set_addr+0x52>
  8004216523:	48 b9 e8 a1 21 04 80 	movabs $0x800421a1e8,%rcx
  800421652a:	00 00 00 
  800421652d:	48 ba f2 a1 21 04 80 	movabs $0x800421a1f2,%rdx
  8004216534:	00 00 00 
  8004216537:	be 29 00 00 00       	mov    $0x29,%esi
  800421653c:	48 bf 07 a2 21 04 80 	movabs $0x800421a207,%rdi
  8004216543:	00 00 00 
  8004216546:	b8 00 00 00 00       	mov    $0x0,%eax
  800421654b:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004216552:	00 00 00 
  8004216555:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004216558:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  800421655c:	76 35                	jbe    8004216593 <pci_conf1_set_addr+0x8d>
  800421655e:	48 b9 12 a2 21 04 80 	movabs $0x800421a212,%rcx
  8004216565:	00 00 00 
  8004216568:	48 ba f2 a1 21 04 80 	movabs $0x800421a1f2,%rdx
  800421656f:	00 00 00 
  8004216572:	be 2a 00 00 00       	mov    $0x2a,%esi
  8004216577:	48 bf 07 a2 21 04 80 	movabs $0x800421a207,%rdi
  800421657e:	00 00 00 
  8004216581:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216586:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  800421658d:	00 00 00 
  8004216590:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004216593:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004216597:	76 35                	jbe    80042165ce <pci_conf1_set_addr+0xc8>
  8004216599:	48 b9 1b a2 21 04 80 	movabs $0x800421a21b,%rcx
  80042165a0:	00 00 00 
  80042165a3:	48 ba f2 a1 21 04 80 	movabs $0x800421a1f2,%rdx
  80042165aa:	00 00 00 
  80042165ad:	be 2b 00 00 00       	mov    $0x2b,%esi
  80042165b2:	48 bf 07 a2 21 04 80 	movabs $0x800421a207,%rdi
  80042165b9:	00 00 00 
  80042165bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165c1:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  80042165c8:	00 00 00 
  80042165cb:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042165ce:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  80042165d5:	76 35                	jbe    800421660c <pci_conf1_set_addr+0x106>
  80042165d7:	48 b9 24 a2 21 04 80 	movabs $0x800421a224,%rcx
  80042165de:	00 00 00 
  80042165e1:	48 ba f2 a1 21 04 80 	movabs $0x800421a1f2,%rdx
  80042165e8:	00 00 00 
  80042165eb:	be 2c 00 00 00       	mov    $0x2c,%esi
  80042165f0:	48 bf 07 a2 21 04 80 	movabs $0x800421a207,%rdi
  80042165f7:	00 00 00 
  80042165fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165ff:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004216606:	00 00 00 
  8004216609:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  800421660c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421660f:	83 e0 03             	and    $0x3,%eax
  8004216612:	85 c0                	test   %eax,%eax
  8004216614:	74 35                	je     800421664b <pci_conf1_set_addr+0x145>
  8004216616:	48 b9 31 a2 21 04 80 	movabs $0x800421a231,%rcx
  800421661d:	00 00 00 
  8004216620:	48 ba f2 a1 21 04 80 	movabs $0x800421a1f2,%rdx
  8004216627:	00 00 00 
  800421662a:	be 2d 00 00 00       	mov    $0x2d,%esi
  800421662f:	48 bf 07 a2 21 04 80 	movabs $0x800421a207,%rdi
  8004216636:	00 00 00 
  8004216639:	b8 00 00 00 00       	mov    $0x0,%eax
  800421663e:	49 b8 08 06 20 04 80 	movabs $0x8004200608,%r8
  8004216645:	00 00 00 
  8004216648:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  800421664b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421664e:	c1 e0 10             	shl    $0x10,%eax
  8004216651:	89 c2                	mov    %eax,%edx
  8004216653:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216656:	c1 e0 0b             	shl    $0xb,%eax
  8004216659:	09 c2                	or     %eax,%edx
  800421665b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421665e:	c1 e0 08             	shl    $0x8,%eax
  8004216661:	09 d0                	or     %edx,%eax
  8004216663:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004216666:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421666b:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  800421666e:	48 b8 e4 b9 22 04 80 	movabs $0x800422b9e4,%rax
  8004216675:	00 00 00 
  8004216678:	8b 00                	mov    (%rax),%eax
  800421667a:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800421667d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216680:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004216683:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216686:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004216689:	ef                   	out    %eax,(%dx)
}
  800421668a:	c9                   	leaveq 
  800421668b:	c3                   	retq   

000000800421668c <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  800421668c:	55                   	push   %rbp
  800421668d:	48 89 e5             	mov    %rsp,%rbp
  8004216690:	48 83 ec 20          	sub    $0x20,%rsp
  8004216694:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216698:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  800421669b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421669f:	8b 50 0c             	mov    0xc(%rax),%edx
  80042166a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042166a6:	8b 70 08             	mov    0x8(%rax),%esi
  80042166a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042166ad:	48 8b 00             	mov    (%rax),%rax
  80042166b0:	8b 40 08             	mov    0x8(%rax),%eax
  80042166b3:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042166b6:	89 c7                	mov    %eax,%edi
  80042166b8:	48 b8 06 65 21 04 80 	movabs $0x8004216506,%rax
  80042166bf:	00 00 00 
  80042166c2:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  80042166c4:	48 b8 e8 b9 22 04 80 	movabs $0x800422b9e8,%rax
  80042166cb:	00 00 00 
  80042166ce:	8b 00                	mov    (%rax),%eax
  80042166d0:	89 45 fc             	mov    %eax,-0x4(%rbp)

    static __inline uint32_t
inl(int port)
{
    uint32_t data;
    __asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  80042166d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042166d6:	89 c2                	mov    %eax,%edx
  80042166d8:	ed                   	in     (%dx),%eax
  80042166d9:	89 45 f8             	mov    %eax,-0x8(%rbp)
    return data;
  80042166dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042166df:	c9                   	leaveq 
  80042166e0:	c3                   	retq   

00000080042166e1 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  80042166e1:	55                   	push   %rbp
  80042166e2:	48 89 e5             	mov    %rsp,%rbp
  80042166e5:	48 83 ec 20          	sub    $0x20,%rsp
  80042166e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042166ed:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80042166f0:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  80042166f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042166f7:	8b 50 0c             	mov    0xc(%rax),%edx
  80042166fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042166fe:	8b 70 08             	mov    0x8(%rax),%esi
  8004216701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216705:	48 8b 00             	mov    (%rax),%rax
  8004216708:	8b 40 08             	mov    0x8(%rax),%eax
  800421670b:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421670e:	89 c7                	mov    %eax,%edi
  8004216710:	48 b8 06 65 21 04 80 	movabs $0x8004216506,%rax
  8004216717:	00 00 00 
  800421671a:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  800421671c:	48 b8 e8 b9 22 04 80 	movabs $0x800422b9e8,%rax
  8004216723:	00 00 00 
  8004216726:	8b 00                	mov    (%rax),%eax
  8004216728:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421672b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421672e:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004216731:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216734:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004216737:	ef                   	out    %eax,(%dx)
}
  8004216738:	c9                   	leaveq 
  8004216739:	c3                   	retq   

000000800421673a <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  800421673a:	55                   	push   %rbp
  800421673b:	48 89 e5             	mov    %rsp,%rbp
  800421673e:	48 83 ec 30          	sub    $0x30,%rsp
  8004216742:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004216745:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004216748:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800421674c:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004216750:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216757:	e9 aa 00 00 00       	jmpq   8004216806 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  800421675c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421675f:	48 c1 e0 04          	shl    $0x4,%rax
  8004216763:	48 89 c2             	mov    %rax,%rdx
  8004216766:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421676a:	48 01 d0             	add    %rdx,%rax
  800421676d:	8b 00                	mov    (%rax),%eax
  800421676f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004216772:	0f 85 8a 00 00 00    	jne    8004216802 <pci_attach_match+0xc8>
  8004216778:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421677b:	48 c1 e0 04          	shl    $0x4,%rax
  800421677f:	48 89 c2             	mov    %rax,%rdx
  8004216782:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216786:	48 01 d0             	add    %rdx,%rax
  8004216789:	8b 40 04             	mov    0x4(%rax),%eax
  800421678c:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421678f:	75 71                	jne    8004216802 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  8004216791:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216794:	48 c1 e0 04          	shl    $0x4,%rax
  8004216798:	48 89 c2             	mov    %rax,%rdx
  800421679b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421679f:	48 01 d0             	add    %rdx,%rax
  80042167a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042167a6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042167aa:	48 89 d7             	mov    %rdx,%rdi
  80042167ad:	ff d0                	callq  *%rax
  80042167af:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042167b2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042167b6:	7e 05                	jle    80042167bd <pci_attach_match+0x83>
				return r;
  80042167b8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042167bb:	eb 6c                	jmp    8004216829 <pci_attach_match+0xef>
			if (r < 0)
  80042167bd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042167c1:	79 3f                	jns    8004216802 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  80042167c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042167c6:	48 c1 e0 04          	shl    $0x4,%rax
  80042167ca:	48 89 c2             	mov    %rax,%rdx
  80042167cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042167d1:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  80042167d4:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042167d8:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80042167db:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042167de:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042167e1:	41 89 f0             	mov    %esi,%r8d
  80042167e4:	89 c6                	mov    %eax,%esi
  80042167e6:	48 bf 48 a2 21 04 80 	movabs $0x800421a248,%rdi
  80042167ed:	00 00 00 
  80042167f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042167f5:	49 b9 7f 97 20 04 80 	movabs $0x800420977f,%r9
  80042167fc:	00 00 00 
  80042167ff:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004216802:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216806:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216809:	48 c1 e0 04          	shl    $0x4,%rax
  800421680d:	48 89 c2             	mov    %rax,%rdx
  8004216810:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216814:	48 01 d0             	add    %rdx,%rax
  8004216817:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421681b:	48 85 c0             	test   %rax,%rax
  800421681e:	0f 85 38 ff ff ff    	jne    800421675c <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004216824:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216829:	c9                   	leaveq 
  800421682a:	c3                   	retq   

000000800421682b <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  800421682b:	55                   	push   %rbp
  800421682c:	48 89 e5             	mov    %rsp,%rbp
  800421682f:	48 83 ec 10          	sub    $0x10,%rsp
  8004216833:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004216837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421683b:	8b 40 14             	mov    0x14(%rax),%eax
  800421683e:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004216841:	0f b6 c0             	movzbl %al,%eax
  8004216844:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216848:	8b 52 14             	mov    0x14(%rdx),%edx
  800421684b:	89 d7                	mov    %edx,%edi
  800421684d:	c1 ef 18             	shr    $0x18,%edi
  8004216850:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216854:	48 89 d1             	mov    %rdx,%rcx
  8004216857:	48 ba 00 ba 22 04 80 	movabs $0x800422ba00,%rdx
  800421685e:	00 00 00 
  8004216861:	89 c6                	mov    %eax,%esi
  8004216863:	48 b8 3a 67 21 04 80 	movabs $0x800421673a,%rax
  800421686a:	00 00 00 
  800421686d:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  800421686f:	85 c0                	test   %eax,%eax
  8004216871:	75 39                	jne    80042168ac <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  8004216873:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216877:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  800421687a:	c1 e8 10             	shr    $0x10,%eax
  800421687d:	89 c6                	mov    %eax,%esi
  800421687f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216883:	8b 40 10             	mov    0x10(%rax),%eax
  8004216886:	0f b7 c0             	movzwl %ax,%eax
  8004216889:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421688d:	48 89 d1             	mov    %rdx,%rcx
  8004216890:	48 ba 10 57 37 04 80 	movabs $0x8004375710,%rdx
  8004216897:	00 00 00 
  800421689a:	89 c7                	mov    %eax,%edi
  800421689c:	48 b8 3a 67 21 04 80 	movabs $0x800421673a,%rax
  80042168a3:	00 00 00 
  80042168a6:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042168a8:	85 c0                	test   %eax,%eax
  80042168aa:	74 07                	je     80042168b3 <pci_attach+0x88>
  80042168ac:	b8 01 00 00 00       	mov    $0x1,%eax
  80042168b1:	eb 05                	jmp    80042168b8 <pci_attach+0x8d>
  80042168b3:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042168b8:	c9                   	leaveq 
  80042168b9:	c3                   	retq   

00000080042168ba <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042168ba:	55                   	push   %rbp
  80042168bb:	48 89 e5             	mov    %rsp,%rbp
  80042168be:	48 83 ec 40          	sub    $0x40,%rsp
  80042168c2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  80042168c6:	48 b8 20 ba 22 04 80 	movabs $0x800422ba20,%rax
  80042168cd:	00 00 00 
  80042168d0:	48 8b 00             	mov    (%rax),%rax
  80042168d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  80042168d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042168db:	8b 40 14             	mov    0x14(%rax),%eax
  80042168de:	c1 e8 18             	shr    $0x18,%eax
  80042168e1:	83 f8 06             	cmp    $0x6,%eax
  80042168e4:	77 20                	ja     8004216906 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  80042168e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042168ea:	8b 40 14             	mov    0x14(%rax),%eax
  80042168ed:	c1 e8 18             	shr    $0x18,%eax
  80042168f0:	89 c2                	mov    %eax,%edx
  80042168f2:	48 b8 20 ba 22 04 80 	movabs $0x800422ba20,%rax
  80042168f9:	00 00 00 
  80042168fc:	89 d2                	mov    %edx,%edx
  80042168fe:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004216902:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004216906:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421690a:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421690e:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004216911:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216915:	8b 40 14             	mov    0x14(%rax),%eax
  8004216918:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421691b:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  800421691e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216922:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216925:	c1 e8 18             	shr    $0x18,%eax
  8004216928:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421692b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421692f:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216932:	c1 e8 10             	shr    $0x10,%eax
  8004216935:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421693c:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421693f:	44 0f b7 c0          	movzwl %ax,%r8d
  8004216943:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216947:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421694a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421694e:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004216951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216955:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216958:	8b 40 08             	mov    0x8(%rax),%eax
  800421695b:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  800421695f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8004216963:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004216968:	89 74 24 08          	mov    %esi,0x8(%rsp)
  800421696c:	44 89 0c 24          	mov    %r9d,(%rsp)
  8004216970:	45 89 d1             	mov    %r10d,%r9d
  8004216973:	89 c6                	mov    %eax,%esi
  8004216975:	48 bf e8 a2 21 04 80 	movabs $0x800421a2e8,%rdi
  800421697c:	00 00 00 
  800421697f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216984:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  800421698b:	00 00 00 
  800421698e:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  8004216991:	c9                   	leaveq 
  8004216992:	c3                   	retq   

0000008004216993 <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  8004216993:	55                   	push   %rbp
  8004216994:	48 89 e5             	mov    %rsp,%rbp
  8004216997:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421699e:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042169a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042169ac:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042169b0:	ba 50 00 00 00       	mov    $0x50,%edx
  80042169b5:	be 00 00 00 00       	mov    $0x0,%esi
  80042169ba:	48 89 c7             	mov    %rax,%rdi
  80042169bd:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  80042169c4:	00 00 00 
  80042169c7:	ff d0                	callq  *%rax
	df.bus = bus;
  80042169c9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042169d0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042169d4:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  80042169db:	e9 22 02 00 00       	jmpq   8004216c02 <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  80042169e0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042169e4:	be 0c 00 00 00       	mov    $0xc,%esi
  80042169e9:	48 89 c7             	mov    %rax,%rdi
  80042169ec:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  80042169f3:	00 00 00 
  80042169f6:	ff d0                	callq  *%rax
  80042169f8:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  80042169fb:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042169fe:	c1 e8 10             	shr    $0x10,%eax
  8004216a01:	83 e0 7f             	and    $0x7f,%eax
  8004216a04:	83 f8 01             	cmp    $0x1,%eax
  8004216a07:	0f 87 ec 01 00 00    	ja     8004216bf9 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  8004216a0d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004216a11:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216a15:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004216a1c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216a20:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004216a27:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004216a2b:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004216a32:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004216a36:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004216a3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216a41:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004216a48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216a4c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004216a53:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216a57:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004216a5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216a62:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004216a69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216a6d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004216a74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216a78:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004216a7f:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  8004216a86:	00 00 00 
  8004216a89:	e9 45 01 00 00       	jmpq   8004216bd3 <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  8004216a8e:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004216a95:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004216a9c:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004216aa3:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004216aaa:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004216ab1:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004216ab8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004216abf:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004216ac6:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004216acd:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004216ad4:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216adb:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004216ae2:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004216ae9:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004216aed:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004216af4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004216af8:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004216aff:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004216b03:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004216b0a:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  8004216b0e:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004216b15:	be 00 00 00 00       	mov    $0x0,%esi
  8004216b1a:	48 89 c7             	mov    %rax,%rdi
  8004216b1d:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216b24:	00 00 00 
  8004216b27:	ff d0                	callq  *%rax
  8004216b29:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004216b2f:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004216b35:	0f b7 c0             	movzwl %ax,%eax
  8004216b38:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004216b3d:	0f 84 81 00 00 00    	je     8004216bc4 <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004216b43:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216b4a:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004216b4f:	48 89 c7             	mov    %rax,%rdi
  8004216b52:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216b59:	00 00 00 
  8004216b5c:	ff d0                	callq  *%rax
  8004216b5e:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004216b61:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216b64:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004216b67:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216b6e:	be 08 00 00 00       	mov    $0x8,%esi
  8004216b73:	48 89 c7             	mov    %rax,%rdi
  8004216b76:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216b7d:	00 00 00 
  8004216b80:	ff d0                	callq  *%rax
  8004216b82:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004216b88:	48 b8 e0 b9 22 04 80 	movabs $0x800422b9e0,%rax
  8004216b8f:	00 00 00 
  8004216b92:	8b 00                	mov    (%rax),%eax
  8004216b94:	85 c0                	test   %eax,%eax
  8004216b96:	74 16                	je     8004216bae <pci_scan_bus+0x21b>
				pci_print_func(&af);
  8004216b98:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216b9f:	48 89 c7             	mov    %rax,%rdi
  8004216ba2:	48 b8 ba 68 21 04 80 	movabs $0x80042168ba,%rax
  8004216ba9:	00 00 00 
  8004216bac:	ff d0                	callq  *%rax
			pci_attach(&af);
  8004216bae:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216bb5:	48 89 c7             	mov    %rax,%rdi
  8004216bb8:	48 b8 2b 68 21 04 80 	movabs $0x800421682b,%rax
  8004216bbf:	00 00 00 
  8004216bc2:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004216bc4:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004216bca:	83 c0 01             	add    $0x1,%eax
  8004216bcd:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004216bd3:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004216bd9:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216bdc:	25 00 00 80 00       	and    $0x800000,%eax
  8004216be1:	85 c0                	test   %eax,%eax
  8004216be3:	74 07                	je     8004216bec <pci_scan_bus+0x259>
  8004216be5:	b8 08 00 00 00       	mov    $0x8,%eax
  8004216bea:	eb 05                	jmp    8004216bf1 <pci_scan_bus+0x25e>
  8004216bec:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216bf1:	39 c2                	cmp    %eax,%edx
  8004216bf3:	0f 82 95 fe ff ff    	jb     8004216a8e <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004216bf9:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004216bfc:	83 c0 01             	add    $0x1,%eax
  8004216bff:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004216c02:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004216c05:	83 f8 1f             	cmp    $0x1f,%eax
  8004216c08:	0f 86 d2 fd ff ff    	jbe    80042169e0 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  8004216c0e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216c11:	c9                   	leaveq 
  8004216c12:	c3                   	retq   

0000008004216c13 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004216c13:	55                   	push   %rbp
  8004216c14:	48 89 e5             	mov    %rsp,%rbp
  8004216c17:	48 83 ec 30          	sub    $0x30,%rsp
  8004216c1b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  8004216c1f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c23:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004216c28:	48 89 c7             	mov    %rax,%rdi
  8004216c2b:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216c32:	00 00 00 
  8004216c35:	ff d0                	callq  *%rax
  8004216c37:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  8004216c3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c3e:	be 18 00 00 00       	mov    $0x18,%esi
  8004216c43:	48 89 c7             	mov    %rax,%rdi
  8004216c46:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216c4d:	00 00 00 
  8004216c50:	ff d0                	callq  *%rax
  8004216c52:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004216c55:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216c58:	83 e0 0f             	and    $0xf,%eax
  8004216c5b:	83 f8 01             	cmp    $0x1,%eax
  8004216c5e:	75 40                	jne    8004216ca0 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004216c60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c64:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004216c67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c6b:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004216c6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c72:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004216c75:	8b 40 08             	mov    0x8(%rax),%eax
  8004216c78:	89 c6                	mov    %eax,%esi
  8004216c7a:	48 bf 28 a3 21 04 80 	movabs $0x800421a328,%rdi
  8004216c81:	00 00 00 
  8004216c84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c89:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004216c90:	00 00 00 
  8004216c93:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  8004216c96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c9b:	e9 a1 00 00 00       	jmpq   8004216d41 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  8004216ca0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004216ca4:	ba 10 00 00 00       	mov    $0x10,%edx
  8004216ca9:	be 00 00 00 00       	mov    $0x0,%esi
  8004216cae:	48 89 c7             	mov    %rax,%rdi
  8004216cb1:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004216cb8:	00 00 00 
  8004216cbb:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004216cbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cc1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  8004216cc5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216cc8:	c1 e8 08             	shr    $0x8,%eax
  8004216ccb:	0f b6 c0             	movzbl %al,%eax
  8004216cce:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004216cd1:	48 b8 e0 b9 22 04 80 	movabs $0x800422b9e0,%rax
  8004216cd8:	00 00 00 
  8004216cdb:	8b 00                	mov    (%rax),%eax
  8004216cdd:	85 c0                	test   %eax,%eax
  8004216cdf:	74 48                	je     8004216d29 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004216ce1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216ce4:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216ce7:	0f b6 f8             	movzbl %al,%edi
  8004216cea:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8004216ced:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cf1:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004216cf4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cf8:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004216cfb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cff:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216d02:	8b 40 08             	mov    0x8(%rax),%eax
  8004216d05:	41 89 f9             	mov    %edi,%r9d
  8004216d08:	41 89 f0             	mov    %esi,%r8d
  8004216d0b:	89 c6                	mov    %eax,%esi
  8004216d0d:	48 bf 60 a3 21 04 80 	movabs $0x800421a360,%rdi
  8004216d14:	00 00 00 
  8004216d17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d1c:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  8004216d23:	00 00 00 
  8004216d26:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004216d29:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004216d2d:	48 89 c7             	mov    %rax,%rdi
  8004216d30:	48 b8 93 69 21 04 80 	movabs $0x8004216993,%rax
  8004216d37:	00 00 00 
  8004216d3a:	ff d0                	callq  *%rax
	return 1;
  8004216d3c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004216d41:	c9                   	leaveq 
  8004216d42:	c3                   	retq   

0000008004216d43 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004216d43:	55                   	push   %rbp
  8004216d44:	48 89 e5             	mov    %rsp,%rbp
  8004216d47:	48 83 ec 40          	sub    $0x40,%rsp
  8004216d4b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004216d4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d53:	ba 07 00 00 00       	mov    $0x7,%edx
  8004216d58:	be 04 00 00 00       	mov    $0x4,%esi
  8004216d5d:	48 89 c7             	mov    %rax,%rdi
  8004216d60:	48 b8 e1 66 21 04 80 	movabs $0x80042166e1,%rax
  8004216d67:	00 00 00 
  8004216d6a:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004216d6c:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  8004216d73:	e9 ee 01 00 00       	jmpq   8004216f66 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004216d78:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004216d7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d7f:	89 d6                	mov    %edx,%esi
  8004216d81:	48 89 c7             	mov    %rax,%rdi
  8004216d84:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216d8b:	00 00 00 
  8004216d8e:	ff d0                	callq  *%rax
  8004216d90:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  8004216d93:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004216d9a:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004216d9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216da1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004216da6:	89 ce                	mov    %ecx,%esi
  8004216da8:	48 89 c7             	mov    %rax,%rdi
  8004216dab:	48 b8 e1 66 21 04 80 	movabs $0x80042166e1,%rax
  8004216db2:	00 00 00 
  8004216db5:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004216db7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004216dba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dbe:	89 d6                	mov    %edx,%esi
  8004216dc0:	48 89 c7             	mov    %rax,%rdi
  8004216dc3:	48 b8 8c 66 21 04 80 	movabs $0x800421668c,%rax
  8004216dca:	00 00 00 
  8004216dcd:	ff d0                	callq  *%rax
  8004216dcf:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004216dd2:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004216dd6:	75 05                	jne    8004216ddd <pci_func_enable+0x9a>
			continue;
  8004216dd8:	e9 83 01 00 00       	jmpq   8004216f60 <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  8004216ddd:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216de0:	83 e8 10             	sub    $0x10,%eax
  8004216de3:	c1 e8 02             	shr    $0x2,%eax
  8004216de6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004216de9:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216dec:	83 e0 01             	and    $0x1,%eax
  8004216def:	85 c0                	test   %eax,%eax
  8004216df1:	75 65                	jne    8004216e58 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004216df3:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216df6:	83 e0 06             	and    $0x6,%eax
  8004216df9:	83 f8 04             	cmp    $0x4,%eax
  8004216dfc:	75 07                	jne    8004216e05 <pci_func_enable+0xc2>
				bar_width = 8;
  8004216dfe:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004216e05:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216e08:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216e0b:	f7 d8                	neg    %eax
  8004216e0d:	23 45 e8             	and    -0x18(%rbp),%eax
  8004216e10:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216e13:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004216e16:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216e19:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216e1c:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004216e1f:	48 b8 20 57 37 04 80 	movabs $0x8004375720,%rax
  8004216e26:	00 00 00 
  8004216e29:	8b 00                	mov    (%rax),%eax
  8004216e2b:	85 c0                	test   %eax,%eax
  8004216e2d:	74 7a                	je     8004216ea9 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004216e2f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004216e32:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216e35:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216e38:	89 c6                	mov    %eax,%esi
  8004216e3a:	48 bf 90 a3 21 04 80 	movabs $0x800421a390,%rdi
  8004216e41:	00 00 00 
  8004216e44:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e49:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004216e50:	00 00 00 
  8004216e53:	41 ff d0             	callq  *%r8
  8004216e56:	eb 51                	jmp    8004216ea9 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004216e58:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216e5b:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216e5e:	f7 d8                	neg    %eax
  8004216e60:	23 45 e8             	and    -0x18(%rbp),%eax
  8004216e63:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216e66:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004216e69:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216e6c:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216e6f:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004216e72:	48 b8 20 57 37 04 80 	movabs $0x8004375720,%rax
  8004216e79:	00 00 00 
  8004216e7c:	8b 00                	mov    (%rax),%eax
  8004216e7e:	85 c0                	test   %eax,%eax
  8004216e80:	74 27                	je     8004216ea9 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004216e82:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004216e85:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216e88:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216e8b:	89 c6                	mov    %eax,%esi
  8004216e8d:	48 bf b8 a3 21 04 80 	movabs $0x800421a3b8,%rdi
  8004216e94:	00 00 00 
  8004216e97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e9c:	49 b8 7f 97 20 04 80 	movabs $0x800420977f,%r8
  8004216ea3:	00 00 00 
  8004216ea6:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004216ea9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216eac:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004216eaf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216eb3:	89 ce                	mov    %ecx,%esi
  8004216eb5:	48 89 c7             	mov    %rax,%rdi
  8004216eb8:	48 b8 e1 66 21 04 80 	movabs $0x80042166e1,%rax
  8004216ebf:	00 00 00 
  8004216ec2:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004216ec4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216ec8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216ecb:	48 63 d2             	movslq %edx,%rdx
  8004216ece:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004216ed2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216ed5:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004216ed9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216edd:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216ee0:	48 63 d2             	movslq %edx,%rdx
  8004216ee3:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004216ee7:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216eea:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004216eed:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004216ef1:	74 6d                	je     8004216f60 <pci_func_enable+0x21d>
  8004216ef3:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004216ef7:	75 67                	jne    8004216f60 <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216ef9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216efd:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216f00:	c1 e8 10             	shr    $0x10,%eax
  8004216f03:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216f06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f0a:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216f0d:	0f b7 f8             	movzwl %ax,%edi
  8004216f10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f14:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004216f17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f1b:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004216f1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f22:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216f25:	8b 40 08             	mov    0x8(%rax),%eax
  8004216f28:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004216f2b:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004216f2f:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004216f32:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004216f36:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004216f39:	89 34 24             	mov    %esi,(%rsp)
  8004216f3c:	45 89 c1             	mov    %r8d,%r9d
  8004216f3f:	41 89 f8             	mov    %edi,%r8d
  8004216f42:	89 c6                	mov    %eax,%esi
  8004216f44:	48 bf e0 a3 21 04 80 	movabs $0x800421a3e0,%rdi
  8004216f4b:	00 00 00 
  8004216f4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f53:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  8004216f5a:	00 00 00 
  8004216f5d:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004216f60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216f63:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004216f66:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004216f6a:	0f 86 08 fe ff ff    	jbe    8004216d78 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004216f70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f74:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216f77:	c1 e8 10             	shr    $0x10,%eax
  8004216f7a:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004216f7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f80:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216f83:	0f b7 f0             	movzwl %ax,%esi
  8004216f86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f8a:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004216f8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f91:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004216f94:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216f98:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216f9b:	8b 40 08             	mov    0x8(%rax),%eax
  8004216f9e:	41 89 f9             	mov    %edi,%r9d
  8004216fa1:	41 89 f0             	mov    %esi,%r8d
  8004216fa4:	89 c6                	mov    %eax,%esi
  8004216fa6:	48 bf 40 a4 21 04 80 	movabs $0x800421a440,%rdi
  8004216fad:	00 00 00 
  8004216fb0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fb5:	49 ba 7f 97 20 04 80 	movabs $0x800420977f,%r10
  8004216fbc:	00 00 00 
  8004216fbf:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004216fc2:	c9                   	leaveq 
  8004216fc3:	c3                   	retq   

0000008004216fc4 <pci_init>:

int
pci_init(void)
{
  8004216fc4:	55                   	push   %rbp
  8004216fc5:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004216fc8:	ba 10 00 00 00       	mov    $0x10,%edx
  8004216fcd:	be 00 00 00 00       	mov    $0x0,%esi
  8004216fd2:	48 bf 30 57 37 04 80 	movabs $0x8004375730,%rdi
  8004216fd9:	00 00 00 
  8004216fdc:	48 b8 50 ee 20 04 80 	movabs $0x800420ee50,%rax
  8004216fe3:	00 00 00 
  8004216fe6:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004216fe8:	48 bf 30 57 37 04 80 	movabs $0x8004375730,%rdi
  8004216fef:	00 00 00 
  8004216ff2:	48 b8 93 69 21 04 80 	movabs $0x8004216993,%rax
  8004216ff9:	00 00 00 
  8004216ffc:	ff d0                	callq  *%rax
}
  8004216ffe:	5d                   	pop    %rbp
  8004216fff:	c3                   	retq   

0000008004217000 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004217000:	55                   	push   %rbp
  8004217001:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004217004:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  800421700b:	00 00 00 
  800421700e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004217014:	5d                   	pop    %rbp
  8004217015:	c3                   	retq   

0000008004217016 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004217016:	55                   	push   %rbp
  8004217017:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  800421701a:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  8004217021:	00 00 00 
  8004217024:	8b 00                	mov    (%rax),%eax
  8004217026:	8d 50 01             	lea    0x1(%rax),%edx
  8004217029:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  8004217030:	00 00 00 
  8004217033:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004217035:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  800421703c:	00 00 00 
  800421703f:	8b 10                	mov    (%rax),%edx
  8004217041:	89 d0                	mov    %edx,%eax
  8004217043:	c1 e0 02             	shl    $0x2,%eax
  8004217046:	01 d0                	add    %edx,%eax
  8004217048:	01 c0                	add    %eax,%eax
  800421704a:	89 c2                	mov    %eax,%edx
  800421704c:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  8004217053:	00 00 00 
  8004217056:	8b 00                	mov    (%rax),%eax
  8004217058:	39 c2                	cmp    %eax,%edx
  800421705a:	73 2a                	jae    8004217086 <time_tick+0x70>
		panic("time_tick: time overflowed");
  800421705c:	48 ba 6f a4 21 04 80 	movabs $0x800421a46f,%rdx
  8004217063:	00 00 00 
  8004217066:	be 13 00 00 00       	mov    $0x13,%esi
  800421706b:	48 bf 8a a4 21 04 80 	movabs $0x800421a48a,%rdi
  8004217072:	00 00 00 
  8004217075:	b8 00 00 00 00       	mov    $0x0,%eax
  800421707a:	48 b9 08 06 20 04 80 	movabs $0x8004200608,%rcx
  8004217081:	00 00 00 
  8004217084:	ff d1                	callq  *%rcx
}
  8004217086:	5d                   	pop    %rbp
  8004217087:	c3                   	retq   

0000008004217088 <time_msec>:

unsigned int
time_msec(void)
{
  8004217088:	55                   	push   %rbp
  8004217089:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  800421708c:	48 b8 40 57 37 04 80 	movabs $0x8004375740,%rax
  8004217093:	00 00 00 
  8004217096:	8b 10                	mov    (%rax),%edx
  8004217098:	89 d0                	mov    %edx,%eax
  800421709a:	c1 e0 02             	shl    $0x2,%eax
  800421709d:	01 d0                	add    %edx,%eax
  800421709f:	01 c0                	add    %eax,%eax
}
  80042170a1:	5d                   	pop    %rbp
  80042170a2:	c3                   	retq   
